# API TODO List

This document lists potential areas for improvement and future development for the API.

## Functionality Enhancements

*   **`append_to_page` Endpoint:**
    *   Consider adding a new endpoint `POST /api/v1/pages.php` with `action: "append"` or a dedicated endpoint like `POST /api/v1/pages/{id}/append`.
    *   This endpoint would allow appending content (e.g., new notes or raw text) to an existing page, which could be useful for integrations with external applications or quick capture tools.
    *   Define behavior: Does it create a new note at the end of the page? Append to a specific section?

*   **Granular Property Updates:**
    *   The current Properties API (`POST /api/v1/properties.php` with `action: "set"`) replaces the entire property.
    *   Introduce actions like `action: "add_value"` or `action: "remove_value"` to allow modifying multi-value properties without resending all existing values.
    *   Example: `POST /api/v1/properties.php` with `{"action": "add_value", "entity_type": "note", "entity_id": 123, "name": "tags", "value": "new_tag"}`.

*   **More Specific Webhook Events:**
    *   The current Webhooks API allows subscribing to `property_change` or `entity_created`.
    *   Expand event types for more granular notifications, e.g., `note_created`, `note_deleted`, `note_updated_content`, `note_updated_parent`, `attachment_created`, `attachment_deleted`, `page_created`, `page_deleted`.

*   **Dedicated Note Reordering:**
    *   While `order_index` can be updated per note, a dedicated endpoint or a batch action specifically for reordering multiple notes within a page or changing their parent might be more efficient and user-friendly.
    *   Example: `POST /api/v1/pages/{id}/reorder_notes` or a batch operation type.

*   **Search Within a Specific Page:**
    *   The current Search API (`GET /api/v1/search.php`) is global.
    *   Add functionality to search for content specifically within a given `page_id`. This could be a parameter to the existing search endpoint or a new endpoint like `GET /api/v1/pages/{id}/search?q={term}`.

*   **User Management/Authentication (Optional):**
    *   If the application requires multi-user support or restricted access, API endpoints for user registration, login, token management, and permissions would be necessary. (Currently out of scope of the primary API functionality but a common extension).

## Performance Optimizations

*   **Eager Loading / Field Selection (Projections):**
    *   For list endpoints (e.g., getting notes for a page, listing pages), allow clients to specify which fields they need (e.g., `fields=id,name,properties.tags`).
    *   For endpoints returning related entities (like pages with notes), allow control over which fields of the related entities are returned. This can significantly reduce data transfer and processing.

*   **Caching Strategies:**
    *   Implement server-side caching for frequently accessed but rarely changing data. Examples:
        *   Property definitions.
        *   Templates.
        *   Resolved page aliases if they are static for periods.
    *   Utilize HTTP caching headers (ETags, Last-Modified) where appropriate.

*   **Database Indexing Review:**
    *   Periodically review database queries generated by the API, especially those involving filtering, sorting, and joining.
    *   Ensure that appropriate database indexes are in place for all commonly queried fields to optimize query performance. `DataManager.php` would be a key file to review for query patterns.

*   **Optimization of `getPageWithNotes` and Similar Methods:**
    *   Methods that aggregate data from multiple tables (e.g., `DataManager::getPageWithNotes`) can become performance bottlenecks if not carefully optimized.
    *   Review these methods for efficient querying, minimizing N+1 query problems. The current implementation fetching all notes for a page and then all their properties in a second query is good, but ensure this scales.

## General API Design & Consistency

*   **File Serving for Attachments (Revisit):**
    *   Currently, `GET /api/v1/attachments.php?id={id}` returns metadata including a direct URL to the file. This relies on the webserver to serve the file.
    *   For more control (e.g., fine-grained access permissions, dynamic `Content-Disposition`), consider if the API should directly stream file content. This was the original spec design. This is a trade-off between simplicity and control.

*   **Error Reporting Granularity:**
    *   For batch operations, ensure detailed error reporting for each sub-operation is consistently implemented and easy for clients to parse.
    *   Consider a standardized error code system beyond HTTP status codes for more specific API errors.

```
