diff --git a/api/data_manager.php b/api/data_manager.php
index 1f9060c..105b265 100644
--- a/api/data_manager.php
+++ b/api/data_manager.php
@@ -1,255 +1,262 @@
 <?php
 
-require_once 'response_utils.php';
+require_once __DIR__ . '/../config.php';
 
 class DataManager {
-    private $pdo;
+    protected $pdo;
 
     public function __construct(PDO $pdo) {
         $this->pdo = $pdo;
     }
 
-    // Placeholder for _formatProperties helper method
-    private function _formatProperties($propertiesResult, $includeInternal = false) {
-        $formattedProperties = [];
-        if (empty($propertiesResult)) {
-            return $formattedProperties;
-        }
-
-        // Group properties by name first
-        $groupedByName = [];
+    /**
+     * Formats raw property results into the API structure, grouping by name.
+     */
+    private function _formatProperties(array $propertiesResult): array {
+        $formatted = [];
         foreach ($propertiesResult as $prop) {
-            $groupedByName[$prop['name']][] = ['value' => $prop['value'], 'internal' => (int)$prop['internal']];
-        }
-
-        foreach ($groupedByName as $name => $values) {
-            if (count($values) === 1) {
-                // If only one property value
-                if (!$includeInternal && $values[0]['internal'] == 0) {
-                    // If not including internal and the property is not internal, simplify to value
-                    $formattedProperties[$name] = $values[0]['value'];
-                } else {
-                    // Otherwise, keep as an object to show internal flag or if it's an internal property
-                    $formattedProperties[$name] = $values[0];
-                }
-            } else {
-                // For multiple values (lists)
-                if (!$includeInternal) {
-                    // Filter out internal properties if not included
-                    $filteredValues = array_filter($values, function($value) {
-                        return $value['internal'] == 0;
-                    });
-                    // If all were internal and filtered out, this property might become empty or just not be set.
-                    // If after filtering, only one non-internal item remains, simplify it.
-                    if (count($filteredValues) === 1) {
-                         $singleValue = array_values($filteredValues)[0]; // Get the single item
-                         $formattedProperties[$name] = $singleValue['value'];
-                    } elseif (count($filteredValues) > 1) {
-                        // If multiple non-internal items, return array of values
-                        $formattedProperties[$name] = array_map(function($v) { return $v['value']; }, $filteredValues);
-                    } else {
-                        // If all values were internal and includeInternal is false, the property is effectively empty or not shown
-                        // Depending on desired behavior, one might choose to add an empty array or skip the property.
-                        // For now, let's skip it if all are internal and not included.
-                    }
-                } else {
-                    // If including internal, return all values as an array of objects
-                    $formattedProperties[$name] = $values;
-                }
+            $key = $prop['name'];
+            if (!isset($formatted[$key])) {
+                $formatted[$key] = [];
             }
+            $formatted[$key][] = [
+                'value' => $prop['value'],
+                'internal' => (int)($prop['weight'] ?? 2) > 2 // Simplified check
+            ];
         }
-        return $formattedProperties;
+        return $formatted;
     }
 
-    public function getPageProperties($pageId, $includeInternal = false) {
-        error_log("[DEBUG] getPageProperties called for pageId: " . $pageId . ", includeInternal: " . ($includeInternal ? 'true' : 'false'));
-        
-        $sql = "SELECT name, value, internal FROM Properties WHERE page_id = :pageId AND note_id IS NULL";
+    /**
+     * Retrieves properties for a single page.
+     */
+    public function getPageProperties(int $pageId, bool $includeInternal = false): array {
+        $sql = "SELECT name, value, weight, created_at FROM Properties WHERE page_id = :pageId AND active = 1";
         if (!$includeInternal) {
-            $sql .= " AND internal = 0";
+            // Assuming weight 3+ is internal, consistent with config.php
+            $sql .= " AND weight < 3";
         }
-        $sql .= " ORDER BY name"; 
-        error_log("[DEBUG] SQL query: " . $sql);
-        
+        $sql .= " ORDER BY created_at ASC";
         $stmt = $this->pdo->prepare($sql);
-        $stmt->bindParam(':pageId', $pageId, PDO::PARAM_INT);
-        $stmt->execute();
-        $propertiesResult = $stmt->fetchAll(PDO::FETCH_ASSOC);
-        error_log("[DEBUG] Raw properties from database: " . json_encode($propertiesResult));
-        
-        $formattedProperties = $this->_formatProperties($propertiesResult, $includeInternal);
-        error_log("[DEBUG] Formatted properties: " . json_encode($formattedProperties));
-        
-        return $formattedProperties;
+        $stmt->execute([':pageId' => $pageId]);
+        return $this->_formatProperties($stmt->fetchAll(PDO::FETCH_ASSOC));
     }
-
-    public function getNoteProperties($noteId, $includeInternal = false) {
-        $sql = "SELECT name, value, internal FROM Properties WHERE note_id = :noteId";
+    
+    /**
+     * Retrieves properties for a single note.
+     */
+    public function getNoteProperties(int $noteId, bool $includeInternal = false): array {
+        $sql = "SELECT name, value, weight, created_at FROM Properties WHERE note_id = :noteId AND active = 1";
         if (!$includeInternal) {
-            $sql .= " AND internal = 0";
+            $sql .= " AND weight < 3";
         }
-        $sql .= " ORDER BY name";
-        
+        $sql .= " ORDER BY created_at ASC";
         $stmt = $this->pdo->prepare($sql);
-        $stmt->bindParam(':noteId', $noteId, PDO::PARAM_INT);
-        $stmt->execute();
-        $propertiesResult = $stmt->fetchAll(PDO::FETCH_ASSOC);
-        
-        return $this->_formatProperties($propertiesResult, $includeInternal);
+        $stmt->execute([':noteId' => $noteId]);
+        return $this->_formatProperties($stmt->fetchAll(PDO::FETCH_ASSOC));
     }
-
-    public function getNoteById($noteId, $includeInternal = false) {
-        $sql = "SELECT Notes.*, EXISTS(SELECT 1 FROM Attachments WHERE Attachments.note_id = Notes.id) as has_attachments FROM Notes WHERE Notes.id = :id";
+    
+    /**
+     * Efficiently fetches properties for multiple note IDs.
+     */
+    public function getPropertiesForNoteIds(array $noteIds, bool $includeInternal = false): array {
+        if (empty($noteIds)) {
+            return [];
+        }
+        $placeholders = implode(',', array_fill(0, count($noteIds), '?'));
+        $sql = "SELECT note_id, name, value, weight, created_at FROM Properties WHERE note_id IN ($placeholders) AND active = 1";
         if (!$includeInternal) {
-            // This condition needs to be carefully considered.
-            // If a note itself is marked internal, should it be excluded here?
-            // The original api/notes.php had "AND internal = 0" for the note itself.
-            // Let's assume for now that `includeInternal` refers to properties primarily,
-            // but if a note itself is internal, it might be filtered by the calling context or a direct SQL clause.
-            // For now, let's stick to the provided signature and focus on properties' internal status.
-            // The `internal` column on the Notes table itself will be returned as is.
+            $sql .= " AND weight < 3";
         }
+        $sql .= " ORDER BY note_id, created_at ASC";
+        
         $stmt = $this->pdo->prepare($sql);
-        $stmt->bindParam(':id', $noteId, PDO::PARAM_INT);
-        $stmt->execute();
+        $stmt->execute($noteIds);
+        $allProps = $stmt->fetchAll(PDO::FETCH_ASSOC);
+
+        $results = array_fill_keys($noteIds, []);
+        foreach ($allProps as $prop) {
+            $noteId = $prop['note_id'];
+            $key = $prop['name'];
+            if (!isset($results[$noteId][$key])) {
+                $results[$noteId][$key] = [];
+            }
+            $results[$noteId][$key][] = [
+                'value' => $prop['value'],
+                'internal' => (int)($prop['weight'] ?? 2) > 2
+            ];
+        }
+        return $results;
+    }
+
+    /**
+     * Retrieves a single note by its ID, including its formatted properties.
+     */
+    public function getNoteById(int $noteId, bool $includeInternal = false): ?array {
+        $stmt = $this->pdo->prepare("SELECT * FROM Notes WHERE id = :id AND active = 1");
+        $stmt->execute([':id' => $noteId]);
         $note = $stmt->fetch(PDO::FETCH_ASSOC);
 
         if ($note) {
-            if (!$includeInternal && $note['internal'] == 1) {
-                return null; // If the note itself is internal and we are not including internal items.
-            }
             $note['properties'] = $this->getNoteProperties($noteId, $includeInternal);
         }
-        
-        return $note;
+        return $note ?: null;
     }
 
-    public function getNotesByPageId($pageId, $includeInternal = false) {
-        $notesSql = "SELECT Notes.*, EXISTS(SELECT 1 FROM Attachments WHERE Attachments.note_id = Notes.id) as has_attachments FROM Notes WHERE Notes.page_id = :pageId";
-        if (!$includeInternal) {
-            $notesSql .= " AND Notes.internal = 0"; // Added Notes. prefix for clarity
-        }
-        $notesSql .= " ORDER BY Notes.order_index ASC"; // Added Notes. prefix for clarity
-        
-        error_log("[DEBUG] getNotesByPageId called for pageId: " . $pageId . ", includeInternal: " . ($includeInternal ? 'true' : 'false'));
-        error_log("[DEBUG] SQL query: " . $notesSql);
-        
-        $stmt = $this->pdo->prepare($notesSql);
-        $stmt->bindParam(':pageId', $pageId, PDO::PARAM_INT);
-        $stmt->execute();
-        $notes = $stmt->fetchAll(PDO::FETCH_ASSOC);
-        
-        error_log("[DEBUG] Found " . count($notes) . " notes for pageId: " . $pageId);
-        if (!empty($notes)) {
-            error_log("[DEBUG] First note: " . json_encode($notes[0]));
-        }
-        
-        if (empty($notes)) {
-            return [];
-        }
+
+    /**
+     * Retrieves all notes for a page, with properties embedded.
+     */
+    public function getNotesByPageId(int $pageId, bool $includeInternal = false): array {
+        $notesStmt = $this->pdo->prepare("SELECT * FROM Notes WHERE page_id = :pageId AND active = 1 ORDER BY order_index ASC");
+        $notesStmt->execute([':pageId' => $pageId]);
+        $notes = $notesStmt->fetchAll(PDO::FETCH_ASSOC);
+
+        if (empty($notes)) return [];
 
         $noteIds = array_column($notes, 'id');
-        
-        // Fetch all properties for these notes in a single query
-        $placeholders = str_repeat('?,', count($noteIds) - 1) . '?';
-        $propSql = "SELECT note_id, name, value, internal FROM Properties WHERE note_id IN ($placeholders)";
-        if (!$includeInternal) {
-            $propSql .= " AND internal = 0";
-        }
-        $propSql .= " ORDER BY name";
+        $propertiesByNoteId = $this->getPropertiesForNoteIds($noteIds, $includeInternal);
 
-        $stmtProps = $this->pdo->prepare($propSql);
-        $stmtProps->execute($noteIds);
-        $allPropertiesResult = $stmtProps->fetchAll(PDO::FETCH_ASSOC);
-        
-        // Group properties by note_id
-        $propertiesByNoteId = [];
-        foreach ($allPropertiesResult as $prop) {
-            $propertiesByNoteId[$prop['note_id']][] = $prop;
-        }
-        
-        // Embed properties into each note
         foreach ($notes as &$note) {
-            $currentNoteProperties = $propertiesByNoteId[$note['id']] ?? [];
-            $note['properties'] = $this->_formatProperties($currentNoteProperties, $includeInternal);
+            $note['properties'] = $propertiesByNoteId[$note['id']] ?? [];
         }
-        unset($note); // Break the reference
-        
+
         return $notes;
     }
 
-    public function getPageDetailsById($pageId, $includeInternal = false) {
-        error_log("[DEBUG] getPageDetailsById called for pageId: " . $pageId);
-        
-        $stmt = $this->pdo->prepare("SELECT * FROM Pages WHERE id = :id");
-        $stmt->bindParam(':id', $pageId, PDO::PARAM_INT);
-        $stmt->execute();
+    /**
+     * Retrieves a single page by its ID, with properties.
+     */
+    public function getPageById(int $pageId): ?array {
+        $stmt = $this->pdo->prepare("SELECT * FROM Pages WHERE id = :id AND active = 1");
+        $stmt->execute([':id' => $pageId]);
         $page = $stmt->fetch(PDO::FETCH_ASSOC);
-        error_log("[DEBUG] Raw page data from database: " . json_encode($page));
 
         if ($page) {
-            error_log("[DEBUG] Getting page properties");
-            $page['properties'] = $this->getPageProperties($pageId, $includeInternal);
-            error_log("[DEBUG] Page properties: " . json_encode($page['properties']));
+            $page['properties'] = $this->getPageProperties($pageId, true); // Get all properties for page details
+        }
+        return $page ?: null;
+    }
+    
+    /**
+     * Retrieves page details by name, optionally including notes.
+     */
+    public function getPageDetailsByName(string $name, bool $includeNotes = false): ?array {
+        $page = $this->getPageByName($name);
+        if ($page && $includeNotes) {
+            $page['notes'] = $this->getNotesByPageId($page['id']);
+        }
+        return $page;
+    }
+    
+    /**
+     * Retrieves page details by ID, optionally including notes.
+     */
+    public function getPageDetailsById(int $id, bool $includeNotes = false): ?array {
+        $page = $this->getPageById($id);
+        if ($page && $includeNotes) {
+            $page['notes'] = $this->getNotesByPageId($page['id']);
         }
         return $page;
     }
 
-    public function getPageWithNotes($pageId, $includeInternal = false) {
-        error_log("[DEBUG] getPageWithNotes called for pageId: " . $pageId);
-        
-        $pageDetails = $this->getPageDetailsById($pageId, $includeInternal);
-        error_log("[DEBUG] getPageDetailsById result: " . json_encode($pageDetails));
+    /**
+     * Retrieves a single page by its name, with properties.
+     */
+    public function getPageByName(string $name): ?array {
+        $stmt = $this->pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(:name) AND active = 1");
+        $stmt->execute([':name' => $name]);
+        $page = $stmt->fetch(PDO::FETCH_ASSOC);
 
-        if (!$pageDetails) {
-            error_log("[DEBUG] Page not found by getPageDetailsById for ID: " . $pageId . ". Returning null from getPageWithNotes."); // Updated log
-            return null; // Added this line
+        if ($page) {
+            $page['properties'] = $this->getPageProperties($page['id'], true);
         }
-        
-        // If $pageDetails was null, the function now exits above.
-        // The original code continued here:
-        // error_log("[DEBUG] Page not found for ID: " . $pageId); // This log might be confusing if pageDetails is null and we proceed.
-        // We should ensure this part is only reached if $pageDetails is valid.
-
-        $notes = $this->getNotesByPageId($pageId, $includeInternal);
-        error_log("[DEBUG] getNotesByPageId result: " . json_encode($notes));
-        
-        return [
-            'page' => $pageDetails,
-            'notes' => $notes
-        ];
+        return $page ?: null;
     }
 
-    public function getPropertiesForNoteIds(array $noteIds, $includeInternal = false) {
-        if (empty($noteIds)) {
-            return [];
+    /**
+     * Retrieves a list of pages with pagination.
+     */
+    public function getPages(int $page = 1, int $per_page = 20, array $options = []): array {
+        $offset = ($page - 1) * $per_page;
+        $baseSql = "FROM Pages WHERE active = 1";
+        $params = [];
+
+        if (!empty($options['exclude_journal'])) {
+            // Note: This check relies on a {type::journal} property being in the page content.
+            // A more robust way would be to check the Properties table if available.
+            $baseSql .= " AND (content IS NULL OR content NOT LIKE '%{type::journal}%')";
         }
 
-        $placeholders = str_repeat('?,', count($noteIds) - 1) . '?';
-        $propSql = "SELECT note_id, name, value, internal FROM Properties WHERE note_id IN ($placeholders)";
-        
-        // Consider if properties themselves should be filtered by their own 'internal' flag here
-        // For now, this method fetches all properties and relies on _formatProperties to handle the includeInternal display logic.
-        // If an `AND internal = 0` clause is needed here based on $includeInternal, it would be:
-        // if (!$includeInternal) { $propSql .= " AND internal = 0"; }
-        // However, _formatProperties is designed to handle this at the formatting stage.
+        $countSql = "SELECT COUNT(*) " . $baseSql;
+        $countStmt = $this->pdo->prepare($countSql);
+        $countStmt->execute($params);
+        $totalItems = (int)$countStmt->fetchColumn();
+
+        $dataSql = "SELECT id, name, content, alias, updated_at " . $baseSql . " ORDER BY updated_at DESC LIMIT :limit OFFSET :offset";
+        $dataStmt = $this->pdo->prepare($dataSql);
+        $dataStmt->bindValue(':limit', $per_page, PDO::PARAM_INT);
+        $dataStmt->bindValue(':offset', $offset, PDO::PARAM_INT);
+        foreach ($params as $key => $value) {
+            $dataStmt->bindValue($key + 1, $value);
+        }
+        $dataStmt->execute();
+        $pages = $dataStmt->fetchAll(PDO::FETCH_ASSOC);
+
+        return [
+            'data' => $pages,
+            'pagination' => [
+                'total_items' => $totalItems,
+                'per_page' => $per_page,
+                'current_page' => $page,
+                'total_pages' => (int)ceil($totalItems / $per_page)
+            ]
+        ];
+    }
 
-        $propSql .= " ORDER BY note_id, name"; // Order by note_id for easier grouping
+    /**
+     * Retrieves pages that have a 'date' property matching a given date.
+     * @param string $date The date in 'YYYY-MM-DD' format.
+     * @return array A list of pages found.
+     */
+    public function getPagesByDate(string $date): array {
+        // Find page IDs that have a 'date' property with the specified value
+        $sql = "
+            SELECT p.id, p.name, p.content, p.alias, p.updated_at
+            FROM Pages p
+            JOIN Properties prop ON p.id = prop.page_id
+            WHERE prop.name = 'date' AND prop.value = :date AND p.active = 1 AND prop.active = 1
+            ORDER BY p.name ASC
+        ";
+        $stmt = $this->pdo->prepare($sql);
+        $stmt->execute([':date' => $date]);
+        return $stmt->fetchAll(PDO::FETCH_ASSOC);
+    }
 
-        $stmtProps = $this->pdo->prepare($propSql);
-        $stmtProps->execute($noteIds);
-        $allPropertiesResult = $stmtProps->fetchAll(PDO::FETCH_ASSOC);
+    /**
+     * Retrieves pages that are direct children of a given namespace.
+     * @param string $namespace The parent page/namespace name.
+     * @return array A list of child pages found.
+     */
+    public function getChildPages(string $namespace): array {
+        // We are looking for pages under the namespace, e.g., "Namespace/Child"
+        $prefix = rtrim($namespace, '/') . '/';
 
-        $propertiesByNoteIdRaw = [];
-        foreach ($allPropertiesResult as $prop) {
-            $propertiesByNoteIdRaw[$prop['note_id']][] = $prop;
-        }
+        // This query finds pages that are direct children of the namespace.
+        // It avoids matching deeper descendants (e.g., ns/child/grandchild)
+        // by checking that there are no additional slashes in the name after the prefix.
+        $sql = "
+            SELECT id, name, updated_at
+            FROM Pages
+            WHERE
+                LOWER(name) LIKE LOWER(:prefix) || '%' AND
+                SUBSTR(LOWER(name), LENGTH(LOWER(:prefix)) + 1) NOT LIKE '%/%' AND
+                active = 1
+            ORDER BY name ASC
+        ";
 
-        $formattedPropertiesByNoteId = [];
-        foreach ($propertiesByNoteIdRaw as $noteId => $props) {
-            $formattedPropertiesByNoteId[$noteId] = $this->_formatProperties($props, $includeInternal);
-        }
-        
-        return $formattedPropertiesByNoteId;
+        $stmt = $this->pdo->prepare($sql);
+        $stmt->execute([':prefix' => $prefix]);
+        return $stmt->fetchAll(PDO::FETCH_ASSOC);
     }
 }
\ No newline at end of file
diff --git a/api/db_connect.php b/api/db_connect.php
index f93792c..8607f31 100644
--- a/api/db_connect.php
+++ b/api/db_connect.php
@@ -1,182 +1,123 @@
 <?php
 require_once __DIR__ . '/../config.php';
-require_once __DIR__ . '/../db/setup_db.php'; // Make the setup function available globally
+require_once __DIR__ . '/../db/setup_db.php';
 
-if (!function_exists('log_db_error')) {
-    function log_db_error($message, $context = []) {
-        $logMessage = date('Y-m-d H:i:s') . " [DB] " . $message;
-        if (!empty($context)) {
-            $logMessage .= " Context: " . json_encode($context);
+// Helper for creating a NOTE and its properties during setup
+if (!function_exists('_create_note_and_index_properties')) {
+    function _create_note_and_index_properties(PDO $pdo, int $page_id, string $content, int $order_index) {
+        require_once __DIR__ . '/property_parser.php';
+        $stmt_insert_note = $pdo->prepare("INSERT INTO Notes (page_id, content, order_index) VALUES (?, ?, ?)");
+        $stmt_insert_note->execute([$page_id, $content, $order_index]);
+        $noteId = $pdo->lastInsertId();
+        if (!$noteId) throw new Exception("Failed to create note record for welcome note.");
+        $propertyParser = new PropertyParser($pdo);
+        $parsedProperties = $propertyParser->parsePropertiesFromContent($content);
+        if (!empty($parsedProperties)) {
+            $stmt_insert_prop = $pdo->prepare("INSERT INTO Properties (note_id, name, value, weight) VALUES (?, ?, ?, ?)");
+            foreach ($parsedProperties as $prop) {
+                $stmt_insert_prop->execute([$noteId, $prop['name'], (string)$prop['value'], $prop['weight']]);
+            }
         }
-        error_log($logMessage);
     }
 }
 
-function get_db_connection() {
-    static $pdo = null;
-    if ($pdo !== null) {
-        return $pdo;
-    }
+// --- NEW HELPER ---
+// Helper for creating a PAGE and its properties during setup
+if (!function_exists('_create_page_and_index_properties')) {
+    function _create_page_and_index_properties(PDO $pdo, string $name, ?string $content = null) {
+        require_once __DIR__ . '/property_parser.php';
+        $stmt_create_page = $pdo->prepare("INSERT INTO Pages (name, content) VALUES (?, ?)");
+        $stmt_create_page->execute([$name, $content]);
+        $pageId = $pdo->lastInsertId();
+        if (!$pageId) throw new Exception("Failed to create page record for '$name'.");
 
-    $max_retries = 5;
-    $retry_delay = 200000; // 200ms
-    $attempt = 0;
-    
-    while ($attempt < $max_retries) {
-        try {
-            $db_path = DB_PATH;
-            $attempt++;
-            
-            $db_dir = dirname($db_path);
-            if (!is_dir($db_dir)) {
-                if (!mkdir($db_dir, 0777, true)) {
-                    throw new Exception("Failed to create database directory: $db_dir");
+        if ($content) {
+            $propertyParser = new PropertyParser($pdo);
+            $parsedProperties = $propertyParser->parsePropertiesFromContent($content);
+            if (!empty($parsedProperties)) {
+                $stmt_insert_prop = $pdo->prepare("INSERT INTO Properties (page_id, name, value, weight) VALUES (?, ?, ?, ?)");
+                foreach ($parsedProperties as $prop) {
+                    $stmt_insert_prop->execute([$pageId, $prop['name'], (string)$prop['value'], $prop['weight']]);
                 }
             }
-            
-            $pdo = new PDO('sqlite:' . $db_path, null, null, [
-                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
-                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
-                PDO::ATTR_TIMEOUT => 5
-            ]);
-            
-            $pdo->exec('PRAGMA busy_timeout = 5000;');
-            $pdo->exec('PRAGMA foreign_keys = ON;');
-            $pdo->exec('PRAGMA journal_mode = WAL;');
-            $pdo->exec('PRAGMA synchronous = NORMAL;');
-
-            $stmt = $pdo->query("SELECT name FROM sqlite_master WHERE type='table' AND name='Pages'");
-            $setup_needed = ($stmt->fetch(PDO::FETCH_ASSOC) === false);
-
-            if ($setup_needed) {
-                $lock_file = $db_path . '.setup.lock';
-                $lock_fp = fopen($lock_file, 'w+');
-
-                if ($lock_fp && flock($lock_fp, LOCK_EX)) {
-                    try {
-                        // Re-check inside the lock to prevent race conditions
-                        $stmt_check = $pdo->query("SELECT name FROM sqlite_master WHERE type='table' AND name='Pages'");
-                        if ($stmt_check->fetch(PDO::FETCH_ASSOC) === false) {
-                            log_db_error("Running setup script...");
-                            run_database_setup($pdo); // Call the setup function
-                            
-                            // Load welcome notes if it's a fresh setup
-                            log_db_error("Checking for welcome notes...");
-                            $welcome_notes_path = __DIR__ . '/../assets/template/page/welcome_notes.json';
-                            if (file_exists($welcome_notes_path)) {
-                                // Create a page with today's date for welcome notes.
-                                $todays_date_page_name = date('Y-m-d');
+        }
+        return $pageId;
+    }
+}
 
-                                // We can ensure it's there by trying to fetch it.
-                                $stmt_check_page = $pdo->prepare("SELECT id FROM Pages WHERE name = ?");
-                                $stmt_check_page->execute([$todays_date_page_name]);
-                                $page = $stmt_check_page->fetch(PDO::FETCH_ASSOC);
-                                $page_id = null;
 
-                                if ($page) {
-                                    $page_id = $page['id'];
-                                } else {
-                                    // If a page for today doesn't exist, create it.
-                                    try {
-                                        $stmt_create_page = $pdo->prepare("INSERT INTO Pages (name, updated_at) VALUES (?, CURRENT_TIMESTAMP)");
-                                        $stmt_create_page->execute([$todays_date_page_name]);
-                                        $page_id = $pdo->lastInsertId();
-                                        if ($page_id) {
-                                            // Add journal property
-                                            $stmt_add_prop = $pdo->prepare("INSERT INTO Properties (page_id, name, value) VALUES (?, 'type', 'journal')");
-                                            $stmt_add_prop->execute([$page_id]);
-                                            log_db_error("Created page '" . $todays_date_page_name . "' with ID: " . $page_id . " for welcome notes.");
-                                        }
-                                    } catch (PDOException $e) {
-                                        log_db_error("Could not create page '" . $todays_date_page_name . "' for welcome notes: " . $e->getMessage());
-                                    }
-                                }
+if (!function_exists('log_db_error')) {
+    function log_db_error($message, $context = []) {
+        error_log(date('Y-m-d H:i:s') . " [DB] " . $message . " " . json_encode($context));
+    }
+}
 
-                                if ($page_id) {
-                                    // Check if welcome notes have already been added to this page to prevent duplicates
-                                    $stmt_check_welcome_tag = $pdo->prepare("SELECT 1 FROM Properties WHERE page_id = ? AND name = 'welcome_notes_added' AND value = 'true'");
-                                    $stmt_check_welcome_tag->execute([$page_id]);
-                                    if ($stmt_check_welcome_tag->fetch(PDO::FETCH_ASSOC)) {
-                                        log_db_error("Welcome notes already added to " . $todays_date_page_name . " page. Skipping.");
-                                    } else {
-                                        log_db_error("Loading welcome notes from JSON...");
-                                        $notes_json = file_get_contents($welcome_notes_path);
-                                        $notes_to_insert = json_decode($notes_json, true); // This will now be an array of strings
+function get_db_connection() {
+    static $pdo = null;
+    if ($pdo !== null) return $pdo;
 
-                                        if (is_array($notes_to_insert)) {
-                                            // Note: No 'title' column in the INSERT statement anymore
-                                            $stmt_insert_note = $pdo->prepare(
-                                                "INSERT INTO Notes (page_id, content, order_index, created_at, updated_at) 
-                                                 VALUES (?, ?, ?, datetime('now'), datetime('now'))"
-                                            );
-                                            $order_index = 1; 
-                                            $stmt_max_order = $pdo->prepare("SELECT MAX(order_index) as max_order FROM Notes WHERE page_id = ?");
-                                            $stmt_max_order->execute([$page_id]);
-                                            $max_order_result = $stmt_max_order->fetch(PDO::FETCH_ASSOC);
-                                            if ($max_order_result && $max_order_result['max_order'] !== null) {
-                                                $order_index = $max_order_result['max_order'] + 1;
-                                            }
+    try {
+        $db_path = DB_PATH;
+        $db_dir = dirname($db_path);
+        if (!is_dir($db_dir) && !mkdir($db_dir, 0777, true)) {
+            throw new Exception("Failed to create database directory: $db_dir");
+        }
+        
+        $pdo = new PDO('sqlite:' . $db_path, null, null, ['ATTR_ERRMODE' => PDO::ERRMODE_EXCEPTION, 'ATTR_DEFAULT_FETCH_MODE' => PDO::FETCH_ASSOC]);
+        $pdo->exec('PRAGMA foreign_keys = ON;');
 
-                                            foreach ($notes_to_insert as $note_content) { // $note_content is now a string
-                                                if (is_string($note_content) && !empty(trim($note_content))) { // Check if it's a non-empty string
-                                                    $stmt_insert_note->execute([
-                                                        $page_id,
-                                                        $note_content, // Use the string directly as content
-                                                        $order_index
-                                                    ]);
-                                                    $order_index++;
-                                                    // Adjust logging if desired, e.g., log a snippet or just "Inserted welcome note"
-                                                    $log_content_snippet = substr($note_content, 0, 50) . (strlen($note_content) > 50 ? "..." : "");
-                                                    log_db_error("Inserted welcome note starting with: " . $log_content_snippet);
-                                                }
-                                            }
-                                            // Add a property to mark that welcome notes have been added
-                                            $stmt_mark_added = $pdo->prepare("INSERT INTO Properties (page_id, name, value) VALUES (?, 'welcome_notes_added', 'true')");
-                                            $stmt_mark_added->execute([$page_id]);
-                                            log_db_error("Finished adding welcome notes to " . $todays_date_page_name . " page.");
-                                        } else {
-                                            log_db_error("Failed to decode welcome notes JSON or it's not an array.");
-                                        }
+        $stmt = $pdo->query("SELECT name FROM sqlite_master WHERE type='table' AND name='Pages'");
+        if ($stmt->fetch() === false) {
+            $lock_file = $db_path . '.setup.lock';
+            $lock_fp = fopen($lock_file, 'w+');
+            if ($lock_fp && flock($lock_fp, LOCK_EX)) {
+                try {
+                    if ($pdo->query("SELECT name FROM sqlite_master WHERE type='table' AND name='Pages'")->fetch() === false) {
+                        log_db_error("Running database setup...");
+                        run_database_setup($pdo);
+                        
+                        $welcome_notes_path = __DIR__ . '/../assets/template/page/welcome_notes.json';
+                        if (file_exists($welcome_notes_path)) {
+                            log_db_error("Adding welcome notes...");
+                            $pdo->beginTransaction();
+                            try {
+                                // --- THIS IS THE FIX ---
+                                // Create page for today WITH content, using the new helper
+                                $todays_page_name = date('Y-m-d');
+                                $page_content = "{type::journal}";
+                                $page_id = _create_page_and_index_properties($pdo, $todays_page_name, $page_content);
+                                
+                                // Add welcome notes from JSON to this new page
+                                $notes_json = file_get_contents($welcome_notes_path);
+                                $notes_to_insert = json_decode($notes_json, true);
+                                if (is_array($notes_to_insert)) {
+                                    $order_index = 1;
+                                    foreach ($notes_to_insert as $note_content) {
+                                        _create_note_and_index_properties($pdo, $page_id, $note_content, $order_index++);
                                     }
-                                } else {
-                                    log_db_error("Page with today's date '" . $todays_date_page_name . "' ID not found or created. Cannot add welcome notes.");
                                 }
-                            } else {
-                                log_db_error("Welcome notes file not found at: " . $welcome_notes_path);
+                                $pdo->commit();
+                                log_db_error("Welcome notes added successfully.");
+                            } catch (Exception $e) {
+                                $pdo->rollBack();
+                                log_db_error("Failed to add welcome notes: " . $e->getMessage());
+                                throw $e;
                             }
                         }
-                    } finally {
-                        flock($lock_fp, LOCK_UN);
-                        fclose($lock_fp);
-                        @unlink($lock_file);
                     }
-                } else {
-                    if ($lock_fp) fclose($lock_fp);
-                    throw new PDOException("Could not acquire setup lock.", "HY000");
+                } finally {
+                    flock($lock_fp, LOCK_UN);
+                    fclose($lock_fp);
+                    @unlink($lock_file);
                 }
             }
-            
-            return $pdo; // Return on success
-            
-        } catch (PDOException $e) {
-            log_db_error("Database PDOException", ['attempt' => $attempt, 'error' => $e->getMessage()]);
-            if ($attempt < $max_retries) {
-                usleep($retry_delay);
-                continue;
-            }
-            header('Content-Type: application/json', true, 500);
-            echo json_encode(['error' => 'Database connection failed.', 'details' => $e->getMessage()]);
-            exit;
-        } catch (Exception $e) {
-            log_db_error("Database connection Exception", ['error' => $e->getMessage()]);
-            header('Content-Type: application/json', true, 500);
-            echo json_encode(['error' => 'A critical error occurred during database setup.', 'details' => $e->getMessage()]);
-            exit;
         }
+        return $pdo;
+    } catch (Exception $e) {
+        log_db_error("CRITICAL DATABASE SETUP FAILED: " . $e->getMessage());
+        http_response_code(500);
+        header('Content-Type: application/json');
+        echo json_encode(['status' => 'error', 'message' => 'A critical error occurred during database setup.', 'details' => $e->getMessage()]);
+        exit;
     }
-    
-    log_db_error("Failed to establish database connection after all attempts.");
-    header('Content-Type: application/json', true, 500);
-    echo json_encode(['error' => 'Failed to connect to the database after multiple attempts.']);
-    exit;
 }
\ No newline at end of file
diff --git a/api/property_parser.php b/api/property_parser.php
index d6ab0e2..2b16359 100644
--- a/api/property_parser.php
+++ b/api/property_parser.php
@@ -1,131 +1,57 @@
 <?php
-require_once 'db_connect.php';
-require_once 'response_utils.php';
+// This file requires other dependencies which are loaded by the calling script.
+// It should not be accessed directly.
 
 class PropertyParser {
     private $pdo;
 
-    public function __construct($pdo) {
+    /**
+     * Constructor for the PropertyParser.
+     *
+     * @param PDO $pdo A connected PDO object.
+     */
+    public function __construct(PDO $pdo) {
         $this->pdo = $pdo;
     }
 
+    /**
+     * Parses a content string to extract all properties defined with the {key::value} syntax.
+     * This parser specifically looks for bracket-enclosed properties to avoid ambiguity.
+     *
+     * @param string $content The text content to parse.
+     * @return array An array of parsed properties, each with name, value, and weight.
+     */
     public function parsePropertiesFromContent($content) {
-        $parsedProperties = [];
-        $lines = explode("\n", $content);
-
-        foreach ($lines as $line) {
-            $line = trim($line);
-            if (empty($line)) continue;
-
-            // Updated regex to reliably capture key, separator, and value.
-            // It correctly distinguishes between '::' and ':::' separators, and enforces matching braces.
-            if (preg_match('/^(\{)?([^:]+)(:{2,3})(.+?)(?(1)\})$/', $line, $matches)) {
-                $key = trim($matches[2]);
-                $separator = $matches[3];
-                $value = trim($matches[4]);
-
-                // Skip empty keys
-                if (empty($key)) continue;
-
-                $is_internal = false;
-                // Property is internal if key starts with '_'
-                if (strpos($key, '_') === 0) { // Example for legacy internal
-                    $is_internal = true;
-                }
-
-                // Property is also internal if ':::' separator is used.
-                if ($separator === ':::') { // {key:::value}
-                    $is_internal = true;
-                }
-                
-                $parsedProperties[] = [
-                    'name' => $key,
-                    'value' => $value,
-                    'is_internal' => $is_internal
-                ];
-            }
-        }
+        $properties = [];
         
-        return $parsedProperties;
-    }
-
-    public function syncNotePropertiesFromContent($noteId, $content) {
-        try {
-            $this->pdo->beginTransaction();
-            
-            // Get existing properties
-            $stmt = $this->pdo->prepare("SELECT name, value, internal FROM Properties WHERE note_id = ?");
-            $stmt->execute([$noteId]);
-            $existingProperties = $stmt->fetchAll(PDO::FETCH_ASSOC);
-            
-            // Convert to associative array for easier lookup
-            $existingPropsMap = [];
-            foreach ($existingProperties as $prop) {
-                $existingPropsMap[$prop['name']] = $prop; // Store the whole prop object
-            }
-            
-            // Parse properties from content using the updated function
-            $parsedContentProperties = $this->parsePropertiesFromContent($content);
-            
-            $propertiesToAdd = [];
-            $propertiesToUpdate = [];
-            
-            foreach ($parsedContentProperties as $prop) {
-                $name = $prop['name'];
-                $value = $prop['value'];
-                $is_internal = $prop['is_internal'];
-                $internal_db_val = $is_internal ? 1 : 0;
-
-                if (!isset($existingPropsMap[$name])) {
-                    $propertiesToAdd[] = [
-                        'name' => $name, 
-                        'value' => $value, 
-                        'internal' => $internal_db_val
-                    ];
-                } elseif (
-                    $existingPropsMap[$name]['value'] !== $value ||
-                    (int)$existingPropsMap[$name]['internal'] !== $internal_db_val 
-                ) {
-                    $propertiesToUpdate[] = [
-                        'name' => $name, 
-                        'value' => $value, 
-                        'internal' => $internal_db_val
-                    ];
-                }
-            }
-            
-            // Add new properties
-            if (!empty($propertiesToAdd)) {
-                $insertStmt = $this->pdo->prepare(
-                    "INSERT INTO Properties (note_id, name, value, internal) VALUES (?, ?, ?, ?)"
-                );
-                foreach ($propertiesToAdd as $prop) {
-                    $insertStmt->execute([$noteId, $prop['name'], $prop['value'], $prop['internal']]);
-                }
-            }
-            
-            // Update existing properties
-            if (!empty($propertiesToUpdate)) {
-                $updateStmt = $this->pdo->prepare(
-                    "UPDATE Properties SET value = ?, internal = ? WHERE note_id = ? AND name = ?"
-                );
-                foreach ($propertiesToUpdate as $prop) {
-                    $updateStmt->execute([$prop['value'], $prop['internal'], $noteId, $prop['name']]);
-                }
-            }
-            
-            $this->pdo->commit();
-            return true;
-        } catch (PDOException $e) {
-            if ($this->pdo->inTransaction()) {
-                $this->pdo->rollBack();
-            }
-            error_log("Error syncing note properties: " . $e->getMessage());
-            return false;
+        // --- THIS IS THE CORRECTED REGEX ---
+        // It specifically looks for content inside curly braces {} and stops matching the
+        // value at the closing brace, allowing for multiple properties on one line.
+        // It captures: 1) the key, 2) the colons, 3) the value (anything not a '}')
+        $regex = '/\{([a-zA-Z0-9_\.-]+)(:{2,})([^}]+)\}/m';
+
+        preg_match_all($regex, $content, $matches, PREG_SET_ORDER);
+
+        foreach ($matches as $match) {
+            // $match[0] is the full matched string, e.g., "{priority::high}"
+            // $match[1] is the key, e.g., "priority"
+            // $match[2] is the colons, e.g., "::"
+            // $match[3] is the value, e.g., "high"
+            
+            $key = trim($match[1]);
+            $colons = $match[2];
+            $value = trim($match[3]);
+            
+            // The weight is determined by the number of colons.
+            $weight = strlen($colons);
+
+            $properties[] = [
+                'name' => $key,
+                'value' => $value,
+                'weight' => $weight
+            ];
         }
-    }
-}
 
-// Initialize and handle the request
-$pdo = get_db_connection();
-$propertyParser = new PropertyParser($pdo); 
\ No newline at end of file
+        return $properties;
+    }
+}
\ No newline at end of file
diff --git a/api/property_utils.php b/api/property_utils.php
index 3923d4a..c8878e0 100644
--- a/api/property_utils.php
+++ b/api/property_utils.php
@@ -1,117 +1,50 @@
 <?php
-require_once 'db_connect.php';
-require_once 'response_utils.php';
 
-if (!class_exists('PropertyUtils')) {
-    class PropertyUtils {
-        private $pdo;
+/**
+ * Utility class for handling application-wide properties and configurations.
+ */
+class PropertyUtils {
+
+    /**
+     * Finds all available extensions by scanning the extensions directory,
+     * then filters them based on the ACTIVE_EXTENSIONS constant from config.php.
+     *
+     * @return array An array of active extension details, each containing 'name' and 'featherIcon'.
+     */
+    public static function getActiveExtensionDetails() {
+        // Ensure the ACTIVE_EXTENSIONS constant is defined and is an array.
+        if (!defined('ACTIVE_EXTENSIONS') || !is_array(ACTIVE_EXTENSIONS)) {
+            return [];
+        }
 
-        public static function getActiveExtensionDetails() {
-            if (!defined('ACTIVE_EXTENSIONS')) {
-                return [];
-            }
+        $active_extensions_list = ACTIVE_EXTENSIONS;
+        $extensions_dir = __DIR__ . '/../extensions';
+        $found_extensions = [];
+
+        // Scan the extensions directory for subdirectories.
+        if (is_dir($extensions_dir)) {
+            $subdirectories = glob($extensions_dir . '/*', GLOB_ONLYDIR);
 
-            $extensionDetails = [];
-            foreach (ACTIVE_EXTENSIONS as $extensionFolderName) {
-                $configPath = __DIR__ . '/../extensions/' . $extensionFolderName . '/config.json';
-                if (file_exists($configPath) && is_readable($configPath)) {
-                    $configContent = file_get_contents($configPath);
-                    $decodedConfig = json_decode($configContent);
+            foreach ($subdirectories as $dir) {
+                $extension_name = basename($dir);
+                $config_path = $dir . '/config.json';
 
-                    if ($decodedConfig && isset($decodedConfig->featherIcon)) {
-                        $extensionDetails[] = [
-                            'name' => $extensionFolderName,
-                            'featherIcon' => $decodedConfig->featherIcon
+                // Check if the discovered extension is in the active list.
+                if (in_array($extension_name, $active_extensions_list) && file_exists($config_path)) {
+                    $config_content = file_get_contents($config_path);
+                    $config_data = json_decode($config_content, true);
+
+                    // If the config is valid and contains a featherIcon, add it to our list.
+                    if (json_last_error() === JSON_ERROR_NONE && isset($config_data['featherIcon'])) {
+                        $found_extensions[] = [
+                            'name' => $extension_name,
+                            'featherIcon' => $config_data['featherIcon']
                         ];
                     }
                 }
             }
-            return $extensionDetails;
-        }
-
-        public function __construct(PDO $pdo) {
-        $this->pdo = $pdo;
-    }
-
-    public function getPropertyValue($entityType, $entityId, $propertyName) {
-        $table = $this->getTableForEntityType($entityType);
-        $idColumn = $this->getIdColumnForEntityType($entityType);
-        
-        $stmt = $this->pdo->prepare("SELECT value FROM Properties WHERE {$idColumn} = ? AND name = ?");
-        $stmt->execute([$entityId, $propertyName]);
-        $result = $stmt->fetch(PDO::FETCH_ASSOC);
-        
-        return $result ? $result['value'] : null;
-    }
-
-    public function setPropertyValue($entityType, $entityId, $propertyName, $propertyValue) {
-        $table = $this->getTableForEntityType($entityType);
-        $idColumn = $this->getIdColumnForEntityType($entityType);
-        
-        // Check if property exists
-        $stmt = $this->pdo->prepare("SELECT id FROM Properties WHERE {$idColumn} = ? AND name = ?");
-        $stmt->execute([$entityId, $propertyName]);
-        $existing = $stmt->fetch();
-        
-        if ($existing) {
-            // Update existing property
-            $stmt = $this->pdo->prepare("UPDATE Properties SET value = ? WHERE {$idColumn} = ? AND name = ?");
-            $stmt->execute([$propertyValue, $entityId, $propertyName]);
-        } else {
-            // Insert new property
-            $stmt = $this->pdo->prepare("INSERT INTO Properties ({$idColumn}, name, value) VALUES (?, ?, ?)");
-            $stmt->execute([$entityId, $propertyName, $propertyValue]);
         }
-        
-        return true;
-    }
-
-    public function deleteProperty($entityType, $entityId, $propertyName) {
-        $table = $this->getTableForEntityType($entityType);
-        $idColumn = $this->getIdColumnForEntityType($entityType);
-        
-        $stmt = $this->pdo->prepare("DELETE FROM Properties WHERE {$idColumn} = ? AND name = ?");
-        $stmt->execute([$entityId, $propertyName]);
-        
-        return true;
-    }
-
-    public function getAllProperties($entityType, $entityId) {
-        $table = $this->getTableForEntityType($entityType);
-        $idColumn = $this->getIdColumnForEntityType($entityType);
-        
-        $stmt = $this->pdo->prepare("SELECT name, value FROM Properties WHERE {$idColumn} = ?");
-        $stmt->execute([$entityId]);
-        $properties = $stmt->fetchAll(PDO::FETCH_ASSOC);
-        
-        $result = [];
-        foreach ($properties as $prop) {
-            $result[$prop['name']] = $prop['value'];
-        }
-        
-        return $result;
-    }
 
-    private function getTableForEntityType($entityType) {
-        $tables = [
-            'note' => 'Notes',
-            'page' => 'Pages'
-        ];
-        
-        return $tables[$entityType] ?? null;
+        return $found_extensions;
     }
-
-    private function getIdColumnForEntityType($entityType) {
-        $columns = [
-            'note' => 'note_id',
-            'page' => 'page_id'
-        ];
-        
-        return $columns[$entityType] ?? null;
-        }
-    }
-}
-
-// Initialize and handle the request
-$pdo = get_db_connection();
-$propertyUtils = new PropertyUtils($pdo); 
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/api/response_utils.php b/api/response_utils.php
index cf8a7c7..1eeca85 100644
--- a/api/response_utils.php
+++ b/api/response_utils.php
@@ -1,26 +1,36 @@
 <?php
 
 class ApiResponse {
-    public static function success($data, $statusCode = 200) {
+    public static function success($data, $statusCode = 200, $metadata = []) {
         http_response_code($statusCode);
         header('Content-Type: application/json');
-        echo json_encode([
-            'status' => 'success', // Changed from 'success' => true
+        
+        $response = [
+            'status' => 'success',
             'data' => $data
-        ]);
+        ];
+        
+        if (!empty($metadata)) {
+            $response = array_merge($response, $metadata);
+        }
+
+        echo json_encode($response);
     }
 
     public static function error($message, $statusCode = 400, $details = null) {
         http_response_code($statusCode);
         header('Content-Type: application/json');
+        
         $response = [
-            'status' => 'error', // Changed from 'success' => false
-            'message' => $message // Moved up from 'error']['message']
+            'status' => 'error',
+            'message' => $message
         ];
+
         if ($details !== null) {
-            $response['details'] = $details; // Moved up from 'error']['details']
+            $response['details'] = $details;
         }
+
         echo json_encode($response);
     }
 }
-?>
+?>
\ No newline at end of file
diff --git a/api/v1/append_to_page.php b/api/v1/append_to_page.php
index 5dceaf7..4858d66 100644
--- a/api/v1/append_to_page.php
+++ b/api/v1/append_to_page.php
@@ -5,66 +5,61 @@ require_once __DIR__ . '/../response_utils.php';
 require_once __DIR__ . '/../data_manager.php';
 require_once __DIR__ . '/../property_parser.php';
 require_once __DIR__ . '/../validator_utils.php';
-// For property processing, we might need functions from notes.php or properties.php
-require_once __DIR__ . '/../property_auto_internal.php'; // For determinePropertyInternalStatus
-require_once __DIR__ . '/properties.php'; // For _updateOrAddPropertyAndDispatchTriggers (if used directly)
-
+require_once __DIR__ . '/../property_auto_internal.php';
+require_once __DIR__ . '/properties.php'; // For _updateOrAddPropertyAndDispatchTriggers
+
+// New "Smart Property Indexer"
+// This function is the single source of truth for processing properties from content.
+if (!function_exists('_indexPropertiesFromContent')) {
+    function _indexPropertiesFromContent($pdo, $entityType, $entityId, $content) {
+        // For notes, check if encrypted. If so, do not process properties from content.
+        if ($entityType === 'note') {
+            $encryptedStmt = $pdo->prepare("SELECT 1 FROM Properties WHERE note_id = :note_id AND name = 'encrypted' AND value = 'true' AND internal = 1 LIMIT 1");
+            $encryptedStmt->execute([':note_id' => $entityId]);
+            if ($encryptedStmt->fetch()) {
+                return []; // Note is encrypted, do not parse/modify properties from its content.
+            }
+        }
 
-// Helper function (adapted from api/v1/notes.php - needs careful placement or inclusion)
-// Ensure this function is defined or accessible in this script's scope.
-// For this subtask, we can define it directly in the script if it's not too large,
-// or assume it's available if properties.php is correctly included and defines it globally.
-// To be safe, let's re-declare a simplified version or ensure it's truly available.
-// For now, we'll assume _updateOrAddPropertyAndDispatchTriggers and determinePropertyInternalStatus are accessible.
+        // 1. Clear existing 'replaceable' properties.
+        $deleteSql = "DELETE FROM Properties WHERE {$entityType}_id = ? AND weight < 4";
+        $stmtDelete = $pdo->prepare($deleteSql);
+        $stmtDelete->execute([$entityId]);
 
-if (!function_exists('local_processNoteContentAndProperties')) {
-    function local_processNoteContentAndProperties($pdo, $content, $entityType, $entityId) {
+        // 2. Parse new properties from content.
         $propertyParser = new PropertyParser($pdo);
-        // property_parser.php provides parsePropertiesFromContent which returns an array of ['name' => ..., 'value' => ..., 'is_internal' => ...]
-        $parsedPropertiesRaw = $propertyParser->parsePropertiesFromContent($content);
-        
-        $finalPropertiesData = [];
+        $parsedProperties = $propertyParser->parsePropertiesFromContent($content);
+
+        // 3. Save all parsed properties and check for the 'internal' flag.
+        $finalPropertiesForResponse = [];
+        $hasInternalTrue = false;
+
+        foreach ($parsedProperties as $prop) {
+            $name = $prop['name'];
+            $value = (string)$prop['value'];
+            $isInternal = determinePropertyInternalStatus($name, $value);
 
-        foreach ($parsedPropertiesRaw as $prop) {
-            $isInternal = $prop['is_internal'] || determinePropertyInternalStatus($prop['name'], $prop['value']);
-            // Directly save/update. _updateOrAddPropertyAndDispatchTriggers handles complex logic including triggers.
-            // For this endpoint, a direct save might be initially simpler if triggers aren't essential for the first pass.
-            // However, using the existing function ensures consistency.
-             _updateOrAddPropertyAndDispatchTriggers(
-                $pdo,
-                $entityType,
-                $entityId,
-                $prop['name'],
-                $prop['value'],
-                $isInternal, // Pass the determined internal status
-                false // No individual commit within the loop
-            );
-            if (!isset($finalPropertiesData[$prop['name']])) {
-                $finalPropertiesData[$prop['name']] = [];
+            _updateOrAddPropertyAndDispatchTriggers($pdo, $entityType, $entityId, $name, $value, $isInternal, false);
+
+            if (strtolower($name) === 'internal' && strtolower($value) === 'true') {
+                $hasInternalTrue = true;
             }
-            $finalPropertiesData[$prop['name']][] = ['value' => $prop['value'], 'internal' => (int)$isInternal];
-        }
-        return $finalPropertiesData; // Return structured properties for the response
-    }
-}
 
-if (!function_exists('local_checkAndSetNoteInternalFlag')) {
-    function local_checkAndSetNoteInternalFlag($pdo, $noteId) {
-        $stmt = $pdo->prepare("SELECT value FROM Properties WHERE note_id = ? AND name = 'internal' AND active = 1");
-        $stmt->execute([$noteId]);
-        $properties = $stmt->fetchAll(PDO::FETCH_ASSOC);
+            if (!isset($finalPropertiesForResponse[$name])) $finalPropertiesForResponse[$name] = [];
+            $finalPropertiesForResponse[$name][] = ['value' => $value, 'internal' => (int)$isInternal];
+        }
 
-        foreach ($properties as $prop) {
-            if (strtolower($prop['value']) === 'true') {
-                $updateStmt = $pdo->prepare("UPDATE Notes SET internal = 1 WHERE id = ?");
-                $updateStmt->execute([$noteId]);
-                return true;
+        // 4. Update the note's 'internal' flag.
+        if ($entityType === 'note') {
+             try {
+                $updateStmt = $pdo->prepare("UPDATE Notes SET internal = ? WHERE id = ?");
+                $updateStmt->execute([$hasInternalTrue ? 1 : 0, $entityId]);
+            } catch (PDOException $e) {
+                error_log("Could not update Notes.internal flag in append_to_page.php. Error: " . $e->getMessage());
             }
         }
-        // Ensure note is not internal if property is not set or false
-        $updateStmt = $pdo->prepare("UPDATE Notes SET internal = 0 WHERE id = ?");
-        $updateStmt->execute([$noteId]);
-        return false;
+        
+        return $finalPropertiesForResponse;
     }
 }
 
@@ -79,7 +74,7 @@ if ($method !== 'POST') {
     exit;
 }
 
-// 1. Validate input: page_name
+// 1. Validate input
 if (!isset($input['page_name']) || !is_string($input['page_name']) || empty(trim($input['page_name']))) {
     ApiResponse::error('page_name is required and must be a non-empty string.', 400);
     exit;
@@ -90,167 +85,77 @@ $page_id = null;
 $page_data = null;
 $created_page = false;
 $created_notes_list = [];
-$temp_id_map = []; // For mapping client-side temporary IDs to actual DB IDs
+$temp_id_map = [];
 
 try {
     $pdo->beginTransaction();
 
-    // 2. Page Handling (Retrieve or Create) - (from previous step)
-    $stmt = $pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(?)");
-    $stmt->execute([$page_name]);
-    $page_data = $stmt->fetch(PDO::FETCH_ASSOC);
+    // 2. Page Handling (Retrieve or Create)
+    $dataManager = new DataManager($pdo);
+    $page_data = $dataManager->getPageDetailsByName($page_name, true);
 
     if ($page_data) {
         $page_id = $page_data['id'];
-        if (preg_match('/^\d{4}-\d{2}-\d{2}$/', $page_name) || strtolower($page_name) === 'journal') {
-            $propStmt = $pdo->prepare("SELECT 1 FROM Properties WHERE page_id = ? AND name = 'type' AND value = 'journal'");
-            $propStmt->execute([$page_id]);
-            if (!$propStmt->fetch()) {
-                $insertPropStmt = $pdo->prepare("INSERT INTO Properties (page_id, name, value, internal) VALUES (?, 'type', 'journal', 0)");
-                $insertPropStmt->execute([$page_id]);
-            }
-        }
     } else {
         $insertStmt = $pdo->prepare("INSERT INTO Pages (name, updated_at) VALUES (?, CURRENT_TIMESTAMP)");
         $insertStmt->execute([$page_name]);
         $page_id = $pdo->lastInsertId();
         if (!$page_id) {
-            $pdo->rollBack();
-            ApiResponse::error('Failed to create page.', 500);
-            exit;
+            throw new Exception('Failed to create page.');
         }
         $created_page = true;
-        if (preg_match('/^\d{4}-\d{2}-\d{2}$/', $page_name) || strtolower($page_name) === 'journal') {
-            $insertPropStmt = $pdo->prepare("INSERT INTO Properties (page_id, name, value, internal) VALUES (?, 'type', 'journal', 0)");
-            $insertPropStmt->execute([$page_id]);
-        }
-        $stmt = $pdo->prepare("SELECT * FROM Pages WHERE id = ?");
-        $stmt->execute([$page_id]);
-        $page_data = $stmt->fetch(PDO::FETCH_ASSOC);
+    }
+    
+    // Ensure journal property for journal-like pages
+    if (preg_match('/^\d{4}-\d{2}-\d{2}$/', $page_name) || strtolower($page_name) === 'journal') {
+        $propStmt = $pdo->prepare("INSERT INTO Properties (page_id, name, value, internal) VALUES (?, 'type', 'journal', 0) ON CONFLICT(page_id, name) DO NOTHING");
+        $propStmt->execute([$page_id]);
     }
 
     // 3. Note Handling
     if (!isset($input['notes'])) {
-        $pdo->rollBack(); // Nothing to append
-        ApiResponse::error('notes field is required.', 400);
-        exit;
+        throw new Exception('notes field is required.');
     }
-
-    $notes_input = $input['notes'];
-    if (is_string($notes_input)) {
-        $notes_input = [['content' => $notes_input]]; // Convert single string to array of one note
-    }
-
+    $notes_input = is_string($input['notes']) ? [['content' => $input['notes']]] : $input['notes'];
     if (!is_array($notes_input)) {
-        if ($pdo->inTransaction()) $pdo->rollBack();
-        ApiResponse::error('notes field must be a string or an array of note objects.', 400);
-        exit;
+        throw new Exception('notes field must be a string or an array of note objects.');
     }
 
     foreach ($notes_input as $index => $note_item) {
-        if (!is_array($note_item)) {
-            if ($pdo->inTransaction()) $pdo->rollBack();
-            ApiResponse::error("Each item in notes array must be an object (associative array). Error at index {$index}.", 400);
-            exit;
+        if (!is_array($note_item) || !isset($note_item['content']) || !is_string($note_item['content'])) {
+            throw new Exception("Each note item must be an object with a 'content' string. Error at index {$index}.");
         }
 
-        $client_temp_id = $note_item['client_temp_id'] ?? null;
-
-        // Validate 'content'
-        if (!isset($note_item['content']) || !is_string($note_item['content'])) {
-            if ($pdo->inTransaction()) $pdo->rollBack();
-            ApiResponse::error("Note item at index {$index} ('{$client_temp_id}') must have a 'content' field of type string.", 400);
-            exit;
-        }
         $content = $note_item['content'];
+        $client_temp_id = $note_item['client_temp_id'] ?? null;
+        $order_index = (int)($note_item['order_index'] ?? 0);
+        $collapsed = (int)($note_item['collapsed'] ?? 0);
         
-        // Validate 'parent_note_id' (type check)
-        if (isset($note_item['parent_note_id'])) {
-            $temp_parent_id_val = $note_item['parent_note_id'];
-            if (!is_string($temp_parent_id_val) && !is_numeric($temp_parent_id_val) && $temp_parent_id_val !== null) {
-                if ($pdo->inTransaction()) $pdo->rollBack();
-                ApiResponse::error("Note item at index {$index} ('{$client_temp_id}') has an invalid 'parent_note_id'. It must be a string (temp ID), a number (DB ID), or null.", 400);
-                exit;
-            }
-        }
-        
-        // Validate 'order_index' and set default
-        $order_index = $note_item['order_index'] ?? 0; 
-        if (isset($note_item['order_index'])) {
-             if (is_string($note_item['order_index']) && is_numeric($note_item['order_index'])) {
-                 $order_index = (int)$note_item['order_index'];
-             } elseif (!is_int($note_item['order_index'])) { // Handles cases where it might be float or non-numeric string
-                if ($pdo->inTransaction()) $pdo->rollBack();
-                ApiResponse::error("Note item at index {$index} ('{$client_temp_id}') has an invalid 'order_index'. It must be an integer or a numeric string.", 400);
-                exit;
-             }
-        }
-
-        // Validate 'collapsed' and set default
-        $collapsed = $note_item['collapsed'] ?? 0; 
-        if (isset($note_item['collapsed'])) {
-            if (is_bool($note_item['collapsed'])) {
-                $collapsed = (int)$note_item['collapsed'];
-            } elseif (is_string($note_item['collapsed']) && ($note_item['collapsed'] === '0' || $note_item['collapsed'] === '1')) {
-                $collapsed = (int)$note_item['collapsed'];
-            } elseif (is_int($note_item['collapsed']) && ($note_item['collapsed'] === 0 || $note_item['collapsed'] === 1)) {
-                // $collapsed is already correctly set as an int (0 or 1)
-            } else { // Covers non-numeric strings, floats, integers not 0 or 1
-                if ($pdo->inTransaction()) $pdo->rollBack();
-                ApiResponse::error("Note item at index {$index} ('{$client_temp_id}') has an invalid 'collapsed' value. It must be a boolean, integer (0 or 1), or string ('0' or '1').", 400);
-                exit;
-            }
-        }
-        
-        // Validate 'client_temp_id'
-        if ($client_temp_id !== null && !is_string($client_temp_id)) {
-            if ($pdo->inTransaction()) $pdo->rollBack();
-            ApiResponse::error("Note item at index {$index} has an invalid 'client_temp_id'. It must be a string if provided.", 400);
-            exit;
-        }
-        
-        $final_parent_note_id_for_sql = null;
+        $final_parent_note_id = null;
         if (isset($note_item['parent_note_id'])) {
-            $temp_parent_id_val_sql = $note_item['parent_note_id'];
-            if (is_string($temp_parent_id_val_sql) && isset($temp_id_map[$temp_parent_id_val_sql])) {
-                $final_parent_note_id_for_sql = $temp_id_map[$temp_parent_id_val_sql];
-            } elseif (is_numeric($temp_parent_id_val_sql)) {
-                $final_parent_note_id_for_sql = (int)$temp_parent_id_val_sql;
-            } elseif ($temp_parent_id_val_sql === null){
-                $final_parent_note_id_for_sql = null;
+            $parent_id = $note_item['parent_note_id'];
+            if (is_string($parent_id) && isset($temp_id_map[$parent_id])) {
+                $final_parent_note_id = $temp_id_map[$parent_id];
+            } elseif (is_numeric($parent_id)) {
+                $final_parent_note_id = (int)$parent_id;
             }
         }
 
-        $sql_note_fields = ['page_id', 'content', 'parent_note_id', 'order_index', 'collapsed'];
-        $sql_note_params = [
-            ':page_id' => $page_id,
-            ':content' => $content,
-            ':parent_note_id' => $final_parent_note_id_for_sql,
-            ':order_index' => $order_index,
-            ':collapsed' => $collapsed
-        ];
-        
-        $sql_note_field_placeholders = implode(', ', $sql_note_fields);
-        $sql_note_value_placeholders = ':' . implode(', :', $sql_note_fields);
-        
-        $sql = "INSERT INTO Notes ($sql_note_field_placeholders) VALUES ($sql_note_value_placeholders)";
-        
+        $sql = "INSERT INTO Notes (page_id, content, parent_note_id, order_index, collapsed) VALUES (?, ?, ?, ?, ?)";
         $stmt = $pdo->prepare($sql);
-        $stmt->execute($sql_note_params);
+        $stmt->execute([$page_id, $content, $final_parent_note_id, $order_index, $collapsed]);
         $note_id = $pdo->lastInsertId();
 
         if (!$note_id) {
-            if ($pdo->inTransaction()) $pdo->rollBack();
-            ApiResponse::error("Failed to create note entry for item at index {$index} ('{$client_temp_id}').", 500);
-            exit;
+            throw new Exception("Failed to create note entry for item at index {$index}.");
         }
 
-        if ($client_temp_id !== null) {
+        if ($client_temp_id) {
             $temp_id_map[$client_temp_id] = $note_id;
         }
 
-        $note_properties = local_processNoteContentAndProperties($pdo, $content, 'note', $note_id);
-        local_checkAndSetNoteInternalFlag($pdo, $note_id);
+        // Use the new centralized indexer
+        $note_properties = _indexPropertiesFromContent($pdo, 'note', $note_id, $content);
 
         $stmt_new_note = $pdo->prepare("SELECT * FROM Notes WHERE id = :id");
         $stmt_new_note->execute([':id' => $note_id]);
@@ -259,13 +164,12 @@ try {
             $new_note_data['properties'] = $note_properties;
             $created_notes_list[] = $new_note_data;
         }
-    } // End of foreach
+    }
 
     $pdo->commit();
 
-    // Re-fetch page_data to include any new properties like 'type: journal' if it was added.
-    $dataManager = new DataManager($pdo); // Use DataManager for consistency
-    $final_page_data = $dataManager->getPageDetailsById($page_id, true); // true for includeInternal
+    // Re-fetch page_data to include any new properties
+    $final_page_data = $dataManager->getPageDetailsById($page_id, true);
 
     ApiResponse::success([
         'message' => ($created_page ? 'Page created' : 'Page retrieved') . ' and notes appended successfully.',
@@ -278,8 +182,5 @@ try {
         $pdo->rollBack();
     }
     error_log("Error in append_to_page.php: " . $e->getMessage() . " Trace: " . $e->getTraceAsString());
-    ApiResponse::error('An error occurred: ' . $e->getMessage(), 500, ['trace' => $e->getTraceAsString()]);
-    exit;
-}
-
-?>
+    ApiResponse::error('An error occurred: ' . $e->getMessage(), 500);
+}
\ No newline at end of file
diff --git a/api/v1/child_pages.php b/api/v1/child_pages.php
new file mode 100644
index 0000000..dff9f5b
--- /dev/null
+++ b/api/v1/child_pages.php
@@ -0,0 +1,38 @@
+<?php
+// api/v1/child_pages.php
+
+require_once __DIR__ . '/../../config.php';
+require_once __DIR__ . '/../../api/db_connect.php';
+require_once __DIR__ . '/../../api/response_utils.php';
+require_once __DIR__ . '/../../api/data_manager.php';
+require_once __DIR__ . '/../../api/validator_utils.php';
+
+header('Content-Type: application/json');
+
+if ($_SERVER['REQUEST_METHOD'] !== 'GET') {
+    ApiResponse::error('Only GET method is accepted.', 405);
+    exit;
+}
+
+$namespace = $_GET['namespace'] ?? null;
+
+if (!$namespace || !Validator::isNotEmpty($namespace)) {
+    ApiResponse::error('Namespace parameter is required.', 400);
+    exit;
+}
+
+try {
+    $pdo = get_db_connection();
+    $dataManager = new DataManager($pdo);
+    
+    $childPages = $dataManager->getChildPages($namespace);
+    
+    ApiResponse::success($childPages);
+} catch (PDOException $e) {
+    // Log the error for debugging
+    error_log("Database error in child_pages.php: " . $e->getMessage());
+    ApiResponse::error('Database error.', 500);
+} catch (Exception $e) {
+    error_log("Error in child_pages.php: " . $e->getMessage());
+    ApiResponse::error('An unexpected error occurred.', 500);
+} 
\ No newline at end of file
diff --git a/api/v1/extensions.php b/api/v1/extensions.php
index 020706a..7aaf4c5 100644
--- a/api/v1/extensions.php
+++ b/api/v1/extensions.php
@@ -1,35 +1,41 @@
 <?php
 // api/v1/extensions.php
 
-// Include base files - db_connect.php often handles session, error reporting, and base includes
+/**
+ * This endpoint retrieves details about the active extensions by dynamically
+ * reading their configuration files. It adheres to the new API specification.
+ */
+
+// db_connect.php includes config.php and sets up global error handlers.
 require_once __DIR__ . '/../db_connect.php'; 
-require_once __DIR__ . '/../property_utils.php'; // For PropertyUtils class
+// property_utils.php contains the logic for finding and parsing extension configs.
+require_once __DIR__ . '/../property_utils.php'; 
 
+// Set the response content type to JSON
 header('Content-Type: application/json');
 
 try {
-    // Ensure PropertyUtils class and its method exist
+    // Check if the required utility class exists to prevent a fatal error.
     if (!class_exists('PropertyUtils') || !method_exists('PropertyUtils', 'getActiveExtensionDetails')) {
-        throw new Exception('Required utility class or method not found.');
+        // Throw a specific exception that can be caught by the global handler.
+        throw new Exception('Server misconfiguration: PropertyUtils class or method is missing.');
     }
 
+    // Get the array of active extensions.
     $activeExtensions = PropertyUtils::getActiveExtensionDetails();
     
+    // Respond using the new API specification format for a successful request.
     echo json_encode([
-        'success' => true,
-        'extensions' => $activeExtensions
+        'status' => 'success',
+        'data' => [
+            'extensions' => $activeExtensions
+        ]
     ]);
 
 } catch (Exception $e) {
-    // Send a generic error response
-    // In a production environment, log $e->getMessage() and avoid sending detailed errors to the client
-    header('HTTP/1.1 500 Internal Server Error');
-    echo json_encode([
-        'success' => false,
-        'error' => 'An error occurred while fetching extension details.',
-        // 'debug_message' => $e->getMessage() // Optional: for debugging, not for production
-    ]);
+    // Let the global exception handler (set in config.php) catch this.
+    // This will format the JSON error response correctly according to the API spec.
+    throw $e;
 }
 
-exit;
-?>
+exit;
\ No newline at end of file
diff --git a/api/v1/notes.php b/api/v1/notes.php
index 4aa2acd..17ca217 100644
--- a/api/v1/notes.php
+++ b/api/v1/notes.php
@@ -1,82 +1,86 @@
 <?php
 require_once __DIR__ . '/../../config.php';
 require_once __DIR__ . '/../db_connect.php';
-require_once __DIR__ . '/../property_trigger_service.php';
-require_once __DIR__ . '/../pattern_processor.php';
 require_once __DIR__ . '/../property_parser.php';
-require_once __DIR__ . '/../property_auto_internal.php'; // Added for determinePropertyInternalStatus
-require_once __DIR__ . '/properties.php'; // Required for _updateOrAddPropertyAndDispatchTriggers
 require_once __DIR__ . '/../data_manager.php';
 require_once __DIR__ . '/../response_utils.php';
 
 $pdo = get_db_connection();
+$dataManager = new DataManager($pdo);
 $method = $_SERVER['REQUEST_METHOD'];
 $input = json_decode(file_get_contents('php://input'), true);
 
-// Handle method overriding for PUT via POST (e.g., for phpdesktop)
 if ($method === 'POST' && isset($input['_method'])) {
     $overrideMethod = strtoupper($input['_method']);
     if ($overrideMethod === 'PUT' || $overrideMethod === 'DELETE') {
         $method = $overrideMethod;
     }
-    // Optionally, remove _method from $input if it could interfere with validation or processing
-    // unset($input['_method']); 
-    // However, validateNoteData only checks for 'content', so it's likely fine to leave it.
 }
 
-// Helper function to validate note data
-if (!function_exists('validateNoteData')) {
-    function validateNoteData($data) {
-        if (!isset($data['content'])) {
-            ApiResponse::error('Note content is required', 400);
-        }
-        return true;
-    }
-}
-
-// Helper function to check for 'internal' property and update Notes.internal
-if (!function_exists('_checkAndSetNoteInternalFlag')) {
-    function _checkAndSetNoteInternalFlag($pdo, $noteId) {
-        $stmt = $pdo->prepare("SELECT value FROM Properties WHERE note_id = ? AND name = 'internal' AND active = 1");
-        $stmt->execute([$noteId]);
-        $properties = $stmt->fetchAll(PDO::FETCH_ASSOC);
-
-        foreach ($properties as $prop) {
-            if (strtolower($prop['value']) === 'true') {
-                $updateStmt = $pdo->prepare("UPDATE Notes SET internal = 1 WHERE id = ?");
-                $updateStmt->execute([$noteId]);
-                return true; // Flag set
+// New "Smart Property Indexer"
+// This function is the single source of truth for processing properties from content.
+// It is fully compliant with the new weight and update_behavior system from config.php.
+if (!function_exists('_indexPropertiesFromContent')) {
+    function _indexPropertiesFromContent($pdo, $entityType, $entityId, $content) {
+        // For notes, check if an 'encrypted' property exists. If so, do not parse content.
+        if ($entityType === 'note') {
+            $encryptedStmt = $pdo->prepare("SELECT 1 FROM Properties WHERE note_id = :note_id AND name = 'encrypted' AND value = 'true' LIMIT 1");
+            $encryptedStmt->execute([':note_id' => $entityId]);
+            if ($encryptedStmt->fetch()) {
+                // Note is marked as encrypted, so we do not parse or modify properties from its content.
+                return;
+            }
+        }
+
+        // 1. Get weights for properties with 'replace' behavior from config
+        $replaceableWeights = [];
+        if (defined('PROPERTY_WEIGHTS')) {
+            foreach (PROPERTY_WEIGHTS as $weight => $config) {
+                if (isset($config['update_behavior']) && $config['update_behavior'] === 'replace') {
+                    $replaceableWeights[] = (int)$weight;
+                }
             }
         }
-        return false; // Flag not set or property not found/not true
-    }
-}
+        
+        // 2. Clear all existing 'replaceable' properties for the entity.
+        // Properties with 'append' behavior (like system logs) are preserved.
+        if (!empty($replaceableWeights)) {
+            $placeholders = str_repeat('?,', count($replaceableWeights) - 1) . '?';
+            $idColumn = $entityType . '_id';
+            $deleteSql = "DELETE FROM Properties WHERE {$idColumn} = ? AND weight IN ($placeholders)";
+            $stmtDelete = $pdo->prepare($deleteSql);
+            $stmtDelete->execute(array_merge([$entityId], $replaceableWeights));
+        }
 
-// Helper function to process note content and extract properties
-if (!function_exists('processNoteContent')) {
-    function processNoteContent($pdo, $content, $entityType, $entityId) {
-        // Create a PropertyParser instance and use it to process the content
+        // 3. Parse new properties from the provided content.
         $propertyParser = new PropertyParser($pdo);
-        $properties = $propertyParser->parsePropertiesFromContent($content);
-        
-        // Save the properties using the centralized function
-        foreach ($properties as $name => $value) {
-            _updateOrAddPropertyAndDispatchTriggers(
-                $pdo,
-                $entityType,
-                $entityId,
-                $name,
-                $value
-            );
+        $parsedProperties = $propertyParser->parsePropertiesFromContent($content);
+
+        // 4. Insert all parsed properties into the database.
+        // This adds new 'replaceable' properties and all 'appendable' properties.
+        if (!empty($parsedProperties)) {
+            $idColumn = $entityType . '_id';
+            $insertSql = "INSERT INTO Properties ({$idColumn}, name, value, weight) VALUES (?, ?, ?, ?)";
+            $stmtInsert = $pdo->prepare($insertSql);
+
+            foreach ($parsedProperties as $prop) {
+                $stmtInsert->execute([
+                    $entityId,
+                    $prop['name'],
+                    (string)$prop['value'],
+                    $prop['weight']
+                ]);
+            }
         }
         
-        return $properties;
+        // Future enhancement: Webhook dispatch logic should be triggered here to notify
+        // other systems of the property changes.
     }
 }
 
 // Batch operation helper functions
 if (!function_exists('_createNoteInBatch')) {
-    function _createNoteInBatch($pdo, $payload, &$tempIdMap) {
+    function _createNoteInBatch($pdo, $dataManager, $payload, &$tempIdMap) {
         if (!isset($payload['page_id']) || !is_numeric($payload['page_id'])) {
             return ['type' => 'create', 'status' => 'error', 'message' => 'Missing or invalid page_id for create operation', 'client_temp_id' => $payload['client_temp_id'] ?? null];
         }
@@ -88,29 +92,20 @@ if (!function_exists('_createNoteInBatch')) {
             $parentNoteId = ($payload['parent_note_id'] === null || $payload['parent_note_id'] === '') ? null : (int)$payload['parent_note_id'];
         }
         $orderIndex = $payload['order_index'] ?? null;
-        $collapsed = $payload['collapsed'] ?? 0; // Default to not collapsed
+        $collapsed = $payload['collapsed'] ?? 0;
         $clientTempId = $payload['client_temp_id'] ?? null;
-        $propertiesExplicit = $payload['properties_explicit'] ?? null;
 
         try {
-            // 1. Create the note
+            // 1. Create the note record
             $sqlFields = ['page_id', 'content', 'parent_note_id', 'collapsed'];
-            $sqlParams = [
-                ':page_id' => $pageId,
-                ':content' => $content,
-                ':parent_note_id' => $parentNoteId,
-                ':collapsed' => (int)$collapsed
-            ];
+            $sqlParams = [':page_id' => $pageId, ':content' => $content, ':parent_note_id' => $parentNoteId, ':collapsed' => (int)$collapsed];
 
             if ($orderIndex !== null && is_numeric($orderIndex)) {
                 $sqlFields[] = 'order_index';
                 $sqlParams[':order_index'] = (int)$orderIndex;
             }
             
-            $sqlFieldPlaceholders = implode(', ', $sqlFields);
-            $sqlValuePlaceholders = ':' . implode(', :', $sqlFields);
-            
-            $sql = "INSERT INTO Notes ($sqlFieldPlaceholders) VALUES ($sqlValuePlaceholders)";
+            $sql = "INSERT INTO Notes (" . implode(', ', $sqlFields) . ") VALUES (:" . implode(', :', $sqlFields) . ")";
             
             $stmt = $pdo->prepare($sql);
             $stmt->execute($sqlParams);
@@ -120,897 +115,207 @@ if (!function_exists('_createNoteInBatch')) {
                  return ['type' => 'create', 'status' => 'error', 'message' => 'Failed to create note record in database.', 'client_temp_id' => $clientTempId];
             }
 
-            // 2. Handle properties
-            $finalProperties = [];
-
-            if (is_array($propertiesExplicit)) {
-                 // Clear existing non-internal properties (though for a new note, there shouldn't be any)
-                $stmtDeleteOld = $pdo->prepare("DELETE FROM Properties WHERE note_id = :note_id AND internal = 0");
-                $stmtDeleteOld->execute([':note_id' => $noteId]);
-
-                foreach ($propertiesExplicit as $name => $values) {
-                    if (!is_array($values)) $values = [$values]; // Ensure values are in an array
-                    foreach ($values as $value) {
-                        $isInternal = determinePropertyInternalStatus($name, $value);
-                         _updateOrAddPropertyAndDispatchTriggers($pdo, 'note', $noteId, $name, (string)$value, $isInternal, false); // No individual commit
-                        // Collect for response, mimicking structure from single GET/POST
-                        if (!isset($finalProperties[$name])) $finalProperties[$name] = [];
-                        $finalProperties[$name][] = ['value' => (string)$value, 'internal' => (int)$isInternal];
-                    }
-                }
-            } elseif (trim($content) !== '') {
-                // Parse and save properties from content if no explicit properties given
-                // processNoteContent already calls _updateOrAddPropertyAndDispatchTriggers
-                // which in turn calls determinePropertyInternalStatus.
-                // We need to ensure processNoteContent can run without individual commits or adapt it.
-                // For now, let's assume processNoteContent works within a transaction.
-                $parsedProps = processNoteContent($pdo, $content, 'note', $noteId); // This function needs to be transaction-aware or not commit itself.
-                                                                                     // It internally calls _updateOrAddPropertyAndDispatchTriggers.
-                // Structure $parsedProps for $finalProperties
-                foreach($parsedProps as $name => $value) { // processNoteContent returns a simple key/value map
-                    if (!isset($finalProperties[$name])) $finalProperties[$name] = [];
-                     // Assuming processNoteContent gives single values, adjust if it can give arrays
-                    $isInternal = determinePropertyInternalStatus($name, $value); // Re-check internal status as processNoteContent might not return it structured
-                    $finalProperties[$name][] = ['value' => $value, 'internal' => (int)$isInternal];
-                }
+            // 2. Index properties from its content
+            if (trim($content) !== '') {
+                _indexPropertiesFromContent($pdo, 'note', $noteId, $content);
             }
-            
-            _checkAndSetNoteInternalFlag($pdo, $noteId);
 
-            // 3. Fetch the newly created note to return it
-            $stmt = $pdo->prepare("SELECT * FROM Notes WHERE id = :id");
-            $stmt->execute([':id' => $noteId]);
-            $newNote = $stmt->fetch(PDO::FETCH_ASSOC);
-            $newNote['properties'] = $finalProperties; // Attach the collected properties
+            // 3. Fetch the newly created note using DataManager for a consistent response
+            $newNote = $dataManager->getNoteById($noteId); // Removed second argument
 
             if ($clientTempId !== null) {
                 $tempIdMap[$clientTempId] = $noteId;
             }
             
-            // Ensure $newNote contains the 'id'
-            $newNote['id'] = $noteId; 
-
-            $result = [
-                'type' => 'create',
-                'status' => 'success',
-                'note' => $newNote 
-            ];
+            $result = ['type' => 'create', 'status' => 'success', 'note' => $newNote];
             if ($clientTempId !== null) {
                 $result['client_temp_id'] = $clientTempId;
             }
             return $result;
 
         } catch (Exception $e) {
-            return ['type' => 'create', 'status' => 'error', 'message' => 'Failed to create note: ' . $e->getMessage(), 'client_temp_id' => $clientTempId, 'details_trace' => $e->getTraceAsString()]; // Renamed 'details' to 'details_trace' to avoid clash
+            return ['type' => 'create', 'status' => 'error', 'message' => 'Failed to create note: ' . $e->getMessage(), 'client_temp_id' => $clientTempId];
         }
     }
 }
 
 if (!function_exists('_updateNoteInBatch')) {
-    function _updateNoteInBatch($pdo, $payload, $tempIdMap) {
-        $originalId = $payload['id'] ?? null; // Keep original ID for error reporting if resolution fails
-        $noteId = $originalId;
-
-        if ($noteId === null) {
-            return ['type' => 'update', 'status' => 'error', 'message' => 'Missing id for update operation', 'id' => $originalId];
-        }
+    function _updateNoteInBatch($pdo, $dataManager, $payload, $tempIdMap) {
+        $noteId = $payload['id'] ?? null;
+        if ($noteId === null) return ['type' => 'update', 'status' => 'error', 'message' => 'Missing id for update operation'];
 
-        // Resolve ID if it's a temporary one (e.g., "temp:client-generated-uuid")
-        // Assuming temp IDs are strings and might have a prefix like "temp:"
-        if (is_string($noteId) && strpos($noteId, "temp:") === 0) { 
-            if (isset($tempIdMap[$noteId])) {
-                $noteId = $tempIdMap[$noteId];
-            } else {
-                return ['type' => 'update', 'status' => 'error', 'message' => "Update failed: Temporary ID {$originalId} not resolved.", 'id' => $originalId];
-            }
+        // Resolve temporary IDs
+        if (is_string($noteId) && isset($tempIdMap[$noteId])) {
+            $noteId = $tempIdMap[$noteId];
         } elseif (!is_numeric($noteId)) {
-             return ['type' => 'update', 'status' => 'error', 'message' => "Invalid ID format for update: {$originalId}", 'id' => $originalId];
+             return ['type' => 'update', 'status' => 'error', 'message' => "Invalid or unresolved ID for update: {$payload['id']}", 'id' => $payload['id']];
         }
-        $noteId = (int)$noteId; // Ensure it's an integer after resolution
+        $noteId = (int)$noteId;
 
         try {
-            // Check if note exists
-            $stmtCheck = $pdo->prepare("SELECT * FROM Notes WHERE id = ?");
-            $stmtCheck->execute([$noteId]);
-            $existingNote = $stmtCheck->fetch(PDO::FETCH_ASSOC);
-            
-            if (!$existingNote) {
+            $checkStmt = $pdo->prepare("SELECT id FROM Notes WHERE id = ?");
+            $checkStmt->execute([$noteId]);
+            if (!$checkStmt->fetch()) {
                 return ['type' => 'update', 'status' => 'error', 'message' => 'Note not found for update.', 'id' => $noteId];
             }
 
             $setClauses = [];
             $executeParams = [];
-            $updateContent = false;
+            $contentWasUpdated = false;
 
-            // Dynamically build SET clauses
             if (isset($payload['content'])) {
                 $setClauses[] = "content = ?";
                 $executeParams[] = $payload['content'];
-                $updateContent = true; // Flag that content is being updated for property parsing logic
+                $contentWasUpdated = true;
             }
             if (array_key_exists('parent_note_id', $payload)) {
                 $newParentNoteId = $payload['parent_note_id'];
-                if (is_string($newParentNoteId) && strpos($newParentNoteId, "temp:") === 0) {
-                    if (isset($tempIdMap[$newParentNoteId])) {
-                        $newParentNoteId = $tempIdMap[$newParentNoteId];
-                    } else {
-                        return ['type' => 'update', 'status' => 'error', 'message' => "Update failed: Temporary parent_note_id {$payload['parent_note_id']} not resolved.", 'id' => $noteId];
-                    }
+                if (is_string($newParentNoteId) && isset($tempIdMap[$newParentNoteId])) {
+                    $newParentNoteId = $tempIdMap[$newParentNoteId];
                 }
                 $setClauses[] = "parent_note_id = ?";
                 $executeParams[] = $newParentNoteId === null ? null : (int)$newParentNoteId;
             }
-            if (isset($payload['order_index'])) {
-                $setClauses[] = "order_index = ?";
-                $executeParams[] = (int)$payload['order_index'];
-            }
-            if (isset($payload['collapsed'])) {
-                $setClauses[] = "collapsed = ?";
-                $executeParams[] = (int)$payload['collapsed'];
-            }
-            if (isset($payload['page_id']) && is_numeric($payload['page_id'])) { // Allow page_id update if provided
-                 $setClauses[] = "page_id = ?";
-                 $executeParams[] = (int)$payload['page_id'];
-            }
-
+            // ... add other updatable fields here ...
+            if (isset($payload['order_index'])) { $setClauses[] = "order_index = ?"; $executeParams[] = (int)$payload['order_index']; }
+            if (isset($payload['collapsed'])) { $setClauses[] = "collapsed = ?"; $executeParams[] = (int)$payload['collapsed']; }
+            if (isset($payload['page_id'])) { $setClauses[] = "page_id = ?"; $executeParams[] = (int)$payload['page_id']; }
 
-            if (empty($setClauses) && !isset($payload['properties_explicit'])) {
+            if (empty($setClauses)) {
                 return ['type' => 'update', 'status' => 'warning', 'message' => 'No updatable fields provided for note.', 'id' => $noteId];
             }
 
-            if (!empty($setClauses)) {
-                $setClauses[] = "updated_at = CURRENT_TIMESTAMP";
-                $sql = "UPDATE Notes SET " . implode(", ", $setClauses) . " WHERE id = ?";
-                $executeParams[] = $noteId;
-                
-                $stmt = $pdo->prepare($sql);
-                if (!$stmt->execute($executeParams)) {
-                    return ['type' => 'update', 'status' => 'error', 'message' => 'Failed to update note record.', 'id' => $noteId, 'details' => $stmt->errorInfo()];
-                }
-            }
+            $setClauses[] = "updated_at = CURRENT_TIMESTAMP";
+            $sql = "UPDATE Notes SET " . implode(", ", $setClauses) . " WHERE id = ?";
+            $executeParams[] = $noteId;
             
-            // Properties Handling
-            $finalProperties = []; // To collect properties for the response
-
-            if (isset($payload['properties_explicit']) && is_array($payload['properties_explicit'])) {
-                // Delete existing non-internal properties
-                $stmtDeleteOld = $pdo->prepare("DELETE FROM Properties WHERE note_id = :note_id AND internal = 0");
-                $stmtDeleteOld->execute([':note_id' => $noteId]);
+            $stmt = $pdo->prepare($sql);
+            $stmt->execute($executeParams);
             
-                foreach ($payload['properties_explicit'] as $name => $values) {
-                    if (!is_array($values)) $values = [$values];
-                    foreach ($values as $value) {
-                        $isInternal = determinePropertyInternalStatus($name, $value);
-                        _updateOrAddPropertyAndDispatchTriggers($pdo, 'note', $noteId, $name, (string)$value, $isInternal, false); // No individual commit
-                        if (!isset($finalProperties[$name])) $finalProperties[$name] = [];
-                        $finalProperties[$name][] = ['value' => (string)$value, 'internal' => (int)$isInternal];
-                    }
-                }
-            } elseif ($updateContent) { // Only process content for properties if content was actually updated
-                // And if note is not encrypted (assuming similar logic to existing PUT)
-                $encryptedStmt = $pdo->prepare("SELECT value FROM Properties WHERE note_id = :note_id AND name = 'encrypted' AND internal = 1 LIMIT 1");
-                $encryptedStmt->execute([':note_id' => $noteId]);
-                $encryptedProp = $encryptedStmt->fetch(PDO::FETCH_ASSOC);
-
-                if (!$encryptedProp || $encryptedProp['value'] !== 'true') {
-                    $stmtDeleteOld = $pdo->prepare("DELETE FROM Properties WHERE note_id = :note_id AND internal = 0");
-                    $stmtDeleteOld->execute([':note_id' => $noteId]);
-                    
-                    $parsedProps = processNoteContent($pdo, $payload['content'], 'note', $noteId);
-                    foreach($parsedProps as $name => $value) {
-                        if (!isset($finalProperties[$name])) $finalProperties[$name] = [];
-                        $isInternal = determinePropertyInternalStatus($name, $value); 
-                        $finalProperties[$name][] = ['value' => $value, 'internal' => (int)$isInternal];
-                    }
-                }
+            // Re-index all properties from content if it was provided.
+            if ($contentWasUpdated) {
+                _indexPropertiesFromContent($pdo, 'note', $noteId, $payload['content']);
             }
 
-            _checkAndSetNoteInternalFlag($pdo, $noteId);
-
-            // Fetch updated note and its properties
-            $stmtFetch = $pdo->prepare("SELECT * FROM Notes WHERE id = ?");
-            $stmtFetch->execute([$noteId]);
-            $updatedNote = $stmtFetch->fetch(PDO::FETCH_ASSOC);
-
-            // Fetch all properties for the response, including those not touched by this update
-            $propSql = "SELECT name, value, internal FROM Properties WHERE note_id = :note_id ORDER BY name";
-            $stmtProps = $pdo->prepare($propSql);
-            $stmtProps->bindParam(':note_id', $noteId, PDO::PARAM_INT);
-            $stmtProps->execute();
-            $propertiesResult = $stmtProps->fetchAll(PDO::FETCH_ASSOC);
-
-            $updatedNote['properties'] = [];
-            foreach ($propertiesResult as $prop) {
-                if (!isset($updatedNote['properties'][$prop['name']])) {
-                    $updatedNote['properties'][$prop['name']] = [];
-                }
-                $updatedNote['properties'][$prop['name']][] = [
-                    'value' => $prop['value'],
-                    'internal' => (int)$prop['internal']
-                ];
-            }
-            
-            // Ensure $updatedNote contains the 'id'
-            $updatedNote['id'] = $noteId;
+            // Fetch updated note using DataManager for a consistent response
+            $updatedNote = $dataManager->getNoteById($noteId); // Removed second argument
 
             return ['type' => 'update', 'status' => 'success', 'note' => $updatedNote];
 
         } catch (Exception $e) {
-            return ['type' => 'update', 'status' => 'error', 'message' => 'Failed to update note: ' . $e->getMessage(), 'id' => $noteId, 'details_trace' => $e->getTraceAsString()]; // Renamed 'details' to 'details_trace'
+            return ['type' => 'update', 'status' => 'error', 'message' => 'Failed to update note: ' . $e->getMessage(), 'id' => $noteId];
         }
     }
 }
 
 if (!function_exists('_deleteNoteInBatch')) {
     function _deleteNoteInBatch($pdo, $payload, $tempIdMap) {
-        $originalId = $payload['id'] ?? null;
-        $noteId = $originalId;
+        $noteId = $payload['id'] ?? null;
+        if ($noteId === null) return ['type' => 'delete', 'status' => 'error', 'message' => 'Missing id for delete operation'];
 
-        if ($noteId === null) {
-            return ['type' => 'delete', 'status' => 'error', 'message' => 'Missing id for delete operation', 'id' => $originalId];
-        }
-
-        // Resolve ID if it's a temporary one
-        if (is_string($noteId) && strpos($noteId, "temp:") === 0) {
-            if (isset($tempIdMap[$noteId])) {
-                $noteId = $tempIdMap[$noteId];
-            } else {
-                return ['type' => 'delete', 'status' => 'error', 'message' => "Delete failed: Temporary ID {$originalId} not resolved.", 'id' => $originalId];
-            }
+        // Resolve temporary IDs
+        if (is_string($noteId) && isset($tempIdMap[$noteId])) {
+            $noteId = $tempIdMap[$noteId];
         } elseif (!is_numeric($noteId)) {
-            return ['type' => 'delete', 'status' => 'error', 'message' => "Invalid ID format for delete: {$originalId}", 'id' => $originalId];
+            return ['type' => 'delete', 'status' => 'error', 'message' => "Invalid or unresolved ID for delete: {$payload['id']}", 'id' => $payload['id']];
         }
         $noteId = (int)$noteId;
 
         try {
-            // Check if note exists
-            $stmtCheck = $pdo->prepare("SELECT id FROM Notes WHERE id = ?");
-            $stmtCheck->execute([$noteId]);
-            if (!$stmtCheck->fetch()) {
-                return ['type' => 'delete', 'status' => 'error', 'message' => 'Note not found for delete.', 'id' => $noteId];
-            }
-
-            // Check for child notes (Option A: Stricter)
-            $stmtCheckChildren = $pdo->prepare("SELECT COUNT(*) FROM Notes WHERE parent_note_id = ?");
-            $stmtCheckChildren->execute([$noteId]);
-            if ($stmtCheckChildren->fetchColumn() > 0) {
-                return ['type' => 'delete', 'status' => 'error', 'message' => 'Note has child notes. Cannot delete directly. Delete children first.', 'id' => $noteId];
-            }
-
-            // Delete associated properties
-            $stmtDeleteProps = $pdo->prepare("DELETE FROM Properties WHERE note_id = ?");
-            $stmtDeleteProps->execute([$noteId]); // No need to check rowCount, as note might not have properties
-
-            // Delete the note
+            // CASCADE DELETE is on, so deleting a note will delete its properties.
             $stmtDeleteNote = $pdo->prepare("DELETE FROM Notes WHERE id = ?");
-            if ($stmtDeleteNote->execute([$noteId])) {
-                if ($stmtDeleteNote->rowCount() > 0) {
-                    return ['type' => 'delete', 'status' => 'success', 'deleted_note_id' => $noteId];
-                } else {
-                    // Should have been caught by the existence check, but as a safeguard:
-                    return ['type' => 'delete', 'status' => 'error', 'message' => 'Note not found during delete execution (unexpected).', 'id' => $noteId];
-                }
+            $stmtDeleteNote->execute([$noteId]);
+
+            if ($stmtDeleteNote->rowCount() > 0) {
+                return ['type' => 'delete', 'status' => 'success', 'deleted_note_id' => $noteId];
             } else {
-                return ['type' => 'delete', 'status' => 'error', 'message' => 'Failed to execute note deletion.', 'id' => $noteId, 'details_db' => $stmtDeleteNote->errorInfo()]; // Renamed 'details'
+                return ['type' => 'delete', 'status' => 'error', 'message' => 'Note not found for delete.', 'id' => $noteId];
             }
 
         } catch (Exception $e) {
-            return ['type' => 'delete', 'status' => 'error', 'message' => 'Failed to delete note: ' . $e->getMessage(), 'id' => $noteId, 'details_trace' => $e->getTraceAsString()]; // Renamed 'details'
+            // Catch foreign key constraint violation if a child note exists
+            if (strpos($e->getMessage(), 'FOREIGN KEY constraint failed') !== false) {
+                 return ['type' => 'delete', 'status' => 'error', 'message' => 'Cannot delete note because it has child notes. Delete children first.', 'id' => $noteId];
+            }
+            return ['type' => 'delete', 'status' => 'error', 'message' => 'Failed to delete note: ' . $e->getMessage(), 'id' => $noteId];
         }
     }
 }
 
-
 if (!function_exists('_handleBatchOperations')) {
-    function _handleBatchOperations($pdo, $operations) { // Note: $operations is already $input['operations'] from the calling context
-        
-        // Early validation of the overall batch structure and individual operation structures
-        $validationErrors = [];
-        foreach ($operations as $index => $operation) {
-            $operationHasError = false;
-            if (!isset($operation['type']) || !is_string($operation['type'])) {
-                $validationErrors[] = ['index' => $index, 'error' => 'Missing or invalid type field.'];
-                $operationHasError = true;
-            }
-            if (!isset($operation['payload']) || !is_array($operation['payload'])) {
-                $validationErrors[] = ['index' => $index, 'error' => 'Missing or invalid payload field.'];
-                $operationHasError = true;
-            }
-
-            // If the basic structure of the operation is invalid, skip to the next one.
-            if ($operationHasError) {
-                continue;
-            }
-
-
-            $type = $operation['type'];
-            $payload = $operation['payload'];
-
-            if (!in_array($type, ['create', 'update', 'delete'])) {
-                $validationErrors[] = ['index' => $index, 'type' => $type, 'error' => 'Invalid operation type.'];
-            }
-
-            // Validate presence of essential fields in payload based on type
-            switch ($type) {
-                case 'create':
-                    if (!isset($payload['page_id'])) {
-                        $validationErrors[] = ['index' => $index, 'type' => 'create', 'error' => 'Missing page_id in payload.'];
-                    }
-                    // More detailed validation for page_id (e.g., is_numeric) is handled in _createNoteInBatch
-                    break;
-                case 'update':
-                    if (!isset($payload['id'])) {
-                        $validationErrors[] = ['index' => $index, 'type' => 'update', 'error' => 'Missing id in payload.'];
-                    }
-                    break;
-                case 'delete':
-                    if (!isset($payload['id'])) {
-                        $validationErrors[] = ['index' => $index, 'type' => 'delete', 'error' => 'Missing id in payload.'];
-                    }
-                    break;
-            }
-        }
-
-        if (!empty($validationErrors)) {
-            ApiResponse::error('Batch request validation failed.', 400, ['details' => ['validation_errors' => $validationErrors]]);
-            exit; // Use exit as ApiResponse::error should handle script termination.
+    function _handleBatchOperations($pdo, $dataManager, $operations) {
+        if (!is_array($operations)) {
+            ApiResponse::error('Batch request validation failed: "operations" must be an array.', 400);
+            return;
         }
 
-        // Proceed with processing if validation passes
-        $deleteOps = [];
-        $createOps = [];
-        $updateOps = [];
-        $orderedResults = array_fill(0, count($operations), null);
+        $results = [];
+        $tempIdMap = [];
         
-        $tempIdMap = []; 
-        $anyOperationFailed = false;
-        $failedOperationsDetails = [];
-
-        // Categorize operations while preserving original index
-        foreach ($operations as $index => $operation) {
-            // Type has been validated by the initial loop, but check again for safety or if logic changes
-            $type = $operation['type'] ?? 'unknown'; 
+        $pdo->beginTransaction();
+        try {
+            // Process operations in a safe order: Delete -> Create -> Update
+            $deleteOps = array_filter($operations, fn($op) => $op['type'] === 'delete');
+            $createOps = array_filter($operations, fn($op) => $op['type'] === 'create');
+            $updateOps = array_filter($operations, fn($op) => $op['type'] === 'update');
+
+            foreach ($deleteOps as $op) $results[] = _deleteNoteInBatch($pdo, $op['payload'], $tempIdMap);
+            foreach ($createOps as $op) $results[] = _createNoteInBatch($pdo, $dataManager, $op['payload'], $tempIdMap);
+            foreach ($updateOps as $op) $results[] = _updateNoteInBatch($pdo, $dataManager, $op['payload'], $tempIdMap);
             
-            $opItem = ['original_index' => $index, 'data' => $operation];
-
-            switch ($type) {
-                case 'delete':
-                    $deleteOps[] = $opItem;
-                    break;
-                case 'create':
-                    $createOps[] = $opItem;
-                    break;
-                case 'update':
-                    $updateOps[] = $opItem;
-                    break;
-                default:
-                    // This case should ideally not be reached if initial validation is comprehensive
-                    $anyOperationFailed = true;
-                    $opResult = ['type' => $type, 'status' => 'error', 'message' => 'Invalid operation type during categorization.'];
-                    $orderedResults[$index] = $opResult;
-                    $failedOperationsDetails[] = [
-                        'index' => $index,
-                        'type' => $type,
-                        'payload_identifier' => $operation['payload']['id'] ?? $operation['payload']['client_temp_id'] ?? null,
-                        'error_message' => $opResult['message']
-                    ];
-                    break;
-            }
-        }
-        
-        // Remove try-catch and transaction around the entire batch.
-        // Each operation will implicitly commit if successful, or fail independently.
-        // try {
-        //     $pdo->beginTransaction();
-
-            // 1. Process Deletions
-            foreach ($deleteOps as $opItem) {
-                $originalIndex = $opItem['original_index'];
-                $payload = $opItem['data']['payload']; // Payload was validated to exist
-                $operationType = $opItem['data']['type']; // Type was validated
-
-                $opResult = _deleteNoteInBatch($pdo, $payload, $tempIdMap);
-                $orderedResults[$originalIndex] = $opResult;
-                if (isset($opResult['status']) && $opResult['status'] === 'error') {
-                    $anyOperationFailed = true;
-                    $failedOperationsDetails[] = [
-                        'index' => $originalIndex,
-                        'type' => $operationType,
-                        'payload_identifier' => ['id' => $payload['id'] ?? null], // 'id' is expected for delete
-                        'error_message' => $opResult['message'] ?? 'Unknown error'
-                    ];
-                }
-            }
-
-            // 2. Process Creations
-            // Potentially add: if (!$anyOperationFailed || $continueOnErrorStrategy)
-            foreach ($createOps as $opItem) {
-                $originalIndex = $opItem['original_index'];
-                $payload = $opItem['data']['payload'];
-                $operationType = $opItem['data']['type'];
-
-                $opResult = _createNoteInBatch($pdo, $payload, $tempIdMap);
-                $orderedResults[$originalIndex] = $opResult;
-                if (isset($opResult['status']) && $opResult['status'] === 'error') {
-                    $anyOperationFailed = true;
-                    $failedOperationsDetails[] = [
-                        'index' => $originalIndex,
-                        'type' => $operationType,
-                        'payload_identifier' => ['client_temp_id' => $payload['client_temp_id'] ?? null, 'page_id' => $payload['page_id'] ?? null],
-                        'error_message' => $opResult['message'] ?? 'Unknown error'
-                    ];
-                }
-            }
-
-            // 3. Process Updates
-            // Potentially add: if (!$anyOperationFailed || $continueOnErrorStrategy)
-            foreach ($updateOps as $opItem) {
-                $originalIndex = $opItem['original_index'];
-                $payload = $opItem['data']['payload'];
-                $operationType = $opItem['data']['type'];
-
-                $opResult = _updateNoteInBatch($pdo, $payload, $tempIdMap);
-                $orderedResults[$originalIndex] = $opResult;
-                if (isset($opResult['status']) && $opResult['status'] === 'error') {
-                    $anyOperationFailed = true;
-                    $failedOperationsDetails[] = [
-                        'index' => $originalIndex,
-                        'type' => $operationType,
-                        'payload_identifier' => ['id' => $payload['id'] ?? null], // 'id' is expected for update
-                        'error_message' => $opResult['message'] ?? 'Unknown error'
-                    ];
-                }
-            }
+            $pdo->commit();
 
-            // The batch operation will now return success even if individual operations fail.
-            // The success/failure of individual operations is in 'results'.
             ApiResponse::success([
                 'message' => 'Batch operations completed. Check individual results for status.',
-                'results' => $orderedResults
+                'results' => $results
             ]);
-            exit; // Ensure script terminates after sending response
-
-        // } catch (Exception $e) {
-        //     // This catch block is now for truly unexpected errors outside of individual operation failures
-        //     if ($pdo->inTransaction()) {
-        //         $pdo->rollBack();
-        //     }
-        //     error_log("Batch operation critical error: " . $e->getMessage() . " Trace: " . $e->getTraceAsString());
-            
-        //     ApiResponse::error('An internal server error occurred during batch processing.', 500, [
-        //         'details' => ['general_error' => $e->getMessage()]
-        //     ]);
-        //     exit;
-        // }
+
+        } catch (Exception $e) {
+            if ($pdo->inTransaction()) $pdo->rollBack();
+            error_log("Batch operation critical error: " . $e->getMessage());
+            ApiResponse::error('An internal server error occurred during batch processing.', 500, ['details' => $e->getMessage()]);
+        }
     }
 }
 
 if ($method === 'GET') {
-    $includeInternal = filter_input(INPUT_GET, 'include_internal', FILTER_VALIDATE_BOOLEAN);
-    $dataManager = new DataManager($pdo);
-
+    // --- THIS IS THE FIX ---
+    // Cast the result of filter_input to a boolean.
+    // If 'include_internal' is not set, filter_input returns null, which (bool)null casts to false.
+    // This prevents the TypeError in the DataManager.
+    $includeInternal = (bool)filter_input(INPUT_GET, 'include_internal', FILTER_VALIDATE_BOOLEAN);
+    
     try {
         if (isset($_GET['id'])) {
-            // Get single note using DataManager
             $noteId = (int)$_GET['id'];
             $note = $dataManager->getNoteById($noteId, $includeInternal);
-            
             if ($note) {
-                // Standardize property structure
-                if (isset($note['properties'])) {
-                    $standardizedProps = [];
-                    foreach ($note['properties'] as $name => $values) {
-                        if (!is_array($values)) {
-                            $values = [$values];
-                        }
-                        $standardizedProps[$name] = array_map(function($value) {
-                            return is_array($value) ? $value : ['value' => $value, 'internal' => 0];
-                        }, $values);
-                    }
-                    $note['properties'] = $standardizedProps;
-                }
                 ApiResponse::success($note);
             } else {
-                ApiResponse::error('Note not found or is internal', 404);
+                ApiResponse::error('Note not found', 404);
             }
         } elseif (isset($_GET['page_id'])) {
-            // Get page with notes using DataManager
             $pageId = (int)$_GET['page_id'];
-            
-            // First verify the page exists
-            $pageCheckStmt = $pdo->prepare("SELECT id FROM Pages WHERE id = ?");
-            $pageCheckStmt->execute([$pageId]);
-            if (!$pageCheckStmt->fetch()) {
-                ApiResponse::error('Page not found', 404);
-            }
-            
-            $pageData = $dataManager->getPageWithNotes($pageId, $includeInternal);
-
-            if ($pageData) {
-                // Standardize property structure for all notes
-                foreach ($pageData['notes'] as &$note) {
-                    if (isset($note['properties'])) {
-                        $standardizedProps = [];
-                        foreach ($note['properties'] as $name => $values) {
-                            if (!is_array($values)) {
-                                $values = [$values];
-                            }
-                            $standardizedProps[$name] = array_map(function($value) {
-                                return is_array($value) ? $value : ['value' => $value, 'internal' => 0];
-                            }, $values);
-                        }
-                        $note['properties'] = $standardizedProps;
-                    }
-                }
-                ApiResponse::success($pageData['notes']);
-            } else {
-                ApiResponse::error('Page not found', 404);
-            }
+            $notes = $dataManager->getNotesByPageId($pageId, $includeInternal);
+            ApiResponse::success($notes);
         } else {
-            // Get all notes with pagination
-            $page = max(1, filter_input(INPUT_GET, 'page', FILTER_VALIDATE_INT) ?? 1);
-            $perPage = max(1, min(100, filter_input(INPUT_GET, 'per_page', FILTER_VALIDATE_INT) ?? 20));
-            $offset = ($page - 1) * $perPage;
-
-            // Get total count
-            $countSql = "SELECT COUNT(*) FROM Notes";
-            if (!$includeInternal) {
-                $countSql .= " WHERE internal = 0";
-            }
-            $totalCount = $pdo->query($countSql)->fetchColumn();
-
-            // Get paginated notes
-            // MODIFIED SQL query to include has_attachments
-            $sql = "SELECT Notes.*, EXISTS(SELECT 1 FROM Attachments WHERE Attachments.note_id = Notes.id) as has_attachments FROM Notes";
-            if (!$includeInternal) {
-                // Ensure the WHERE clause is appended correctly
-                $sql .= " WHERE Notes.internal = 0"; // Also specify Notes.internal for clarity
-            }
-            // Append ORDER BY and LIMIT/OFFSET
-            $sql .= " ORDER BY Notes.created_at DESC LIMIT ? OFFSET ?";
-            
-            $stmt = $pdo->prepare($sql);
-            $stmt->execute([$perPage, $offset]);
-            $notes = $stmt->fetchAll(PDO::FETCH_ASSOC);
-
-            // Get properties for all notes in this page
-            if (!empty($notes)) {
-                $noteIds = array_column($notes, 'id');
-                $placeholders = str_repeat('?,', count($noteIds) - 1) . '?';
-                $propSql = "SELECT note_id, name, value, internal FROM Properties WHERE note_id IN ($placeholders) ORDER BY note_id, name";
-                $propStmt = $pdo->prepare($propSql);
-                $propStmt->execute($noteIds);
-                $properties = $propStmt->fetchAll(PDO::FETCH_ASSOC);
-
-                // Group properties by note_id
-                $noteProperties = [];
-                foreach ($properties as $prop) {
-                    $noteId = $prop['note_id'];
-                    if (!isset($noteProperties[$noteId])) {
-                        $noteProperties[$noteId] = [];
-                    }
-                    if (!isset($noteProperties[$noteId][$prop['name']])) {
-                        $noteProperties[$noteId][$prop['name']] = [];
-                    }
-                    $noteProperties[$noteId][$prop['name']][] = [
-                        'value' => $prop['value'],
-                        'internal' => (int)$prop['internal']
-                    ];
-                }
-
-                // Attach properties to notes
-                foreach ($notes as &$note) {
-                    $note['properties'] = $noteProperties[$note['id']] ?? [];
-                }
-            }
-
-            // Calculate pagination metadata
-            $totalPages = ceil($totalCount / $perPage);
-            
-            ApiResponse::success([
-                'data' => $notes,
-                'pagination' => [
-                    'current_page' => $page,
-                    'per_page' => $perPage,
-                    'total_count' => (int)$totalCount,
-                    'total_pages' => $totalPages,
-                    'has_next_page' => $page < $totalPages,
-                    'has_previous_page' => $page > 1
-                ]
-            ]);
+             ApiResponse::error('Missing required parameter: id or page_id', 400);
         }
     } catch (Exception $e) {
-        error_log("API Error in notes.php: " . $e->getMessage());
-        ApiResponse::error('An error occurred while fetching data: ' . $e->getMessage(), 500);
+        error_log("API Error in notes.php (GET): " . $e->getMessage());
+        ApiResponse::error('An error occurred while fetching data.', 500);
     }
 } elseif ($method === 'POST') {
-    // Check if this is a batch operation
     if (isset($input['action']) && $input['action'] === 'batch') {
-        if (isset($input['operations']) && is_array($input['operations'])) {
-            _handleBatchOperations($pdo, $input['operations']);
-            // _handleBatchOperations will call exit() or ApiResponse::success() which should exit.
-            // If it doesn't, ensure no further processing for single POST happens.
-            return; 
-        } else {
-            ApiResponse::error('Batch operations require an "operations" array.', 400);
-            return;
-        }
-    } else {
-        // Existing POST logic for single note creation
-        if (!isset($input['page_id']) || !is_numeric($input['page_id'])) {
-            ApiResponse::error('A valid page_id is required.', 400);
-        }
-
-        $pageId = (int)$input['page_id'];
-    $content = isset($input['content']) ? $input['content'] : '';
-    $parentNoteId = null;
-    
-    // Handle parent_note_id for creating child notes directly
-    if (isset($input['parent_note_id'])) {
-        if ($input['parent_note_id'] === null || $input['parent_note_id'] === '') {
-            $parentNoteId = null;
-        } else {
-            $parentNoteId = (int)$input['parent_note_id'];
-        }
+        _handleBatchOperations($pdo, $dataManager, $input['operations'] ?? []);
+        return;
     }
+    ApiResponse::error('This endpoint now primarily uses batch operations. Please use the batch action.', 400);
 
-    try {
-        $pdo->beginTransaction();
-
-        // 1. Create the note (with optional parent_note_id and order_index)
-        $sql = "INSERT INTO Notes (page_id, content, parent_note_id";
-        $params = [
-            ':page_id' => $pageId,
-            ':content' => $content,
-            ':parent_note_id' => $parentNoteId
-        ];
-
-        if (isset($input['order_index']) && is_numeric($input['order_index'])) {
-            $sql .= ", order_index";
-            $params[':order_index'] = (int)$input['order_index'];
-            $sql .= ") VALUES (:page_id, :content, :parent_note_id, :order_index)";
-        } else {
-            $sql .= ") VALUES (:page_id, :content, :parent_note_id)";
-        }
-        
-        $stmt = $pdo->prepare($sql);
-        $stmt->execute($params);
-        $noteId = $pdo->lastInsertId();
-
-        // 2. Parse and save properties from the content
-        $properties = []; // Initialize properties
-        if (trim($content) !== '') {
-            $properties = processNoteContent($pdo, $content, 'note', $noteId);
-        }
-
-        // Check and set internal flag for the note
-        _checkAndSetNoteInternalFlag($pdo, $noteId);
-
-        $pdo->commit();
-
-        // 3. Fetch the newly created note to return it
-        $stmt = $pdo->prepare("SELECT * FROM Notes WHERE id = :id");
-        $stmt->execute([':id' => $noteId]);
-        $newNote = $stmt->fetch(PDO::FETCH_ASSOC);
-
-        // Attach the parsed properties to the response
-        $newNote['properties'] = $properties;
-
-        ApiResponse::success($newNote, 201); // 201 Created
-
-    } catch (Exception $e) {
-        if ($pdo->inTransaction()) {
-            $pdo->rollBack();
-        }
-        error_log("Failed to create note: " . $e->getMessage());
-        ApiResponse::error('Failed to create note.', 500, ['details' => $e->getMessage()]);
-    }
-  } // End of else for single POST operation
 } elseif ($method === 'PUT') {
-    // For phpdesktop compatibility, also check for ID in request body when using method override
-    $noteId = null;
-    if (isset($_GET['id'])) {
-        $noteId = (int)$_GET['id'];
-    } elseif (isset($input['id'])) {
-        $noteId = (int)$input['id'];
-    }
-    
-    if (!$noteId) {
-        ApiResponse::error('Note ID is required', 400);
-    }
-    
-    // Content is not always required for PUT (e.g. only changing parent/order)
-    // validateNoteData($input); // Content is only required if it's the only thing sent or for new notes
-
-    try {
-        $pdo->beginTransaction();
-
-        // Check if note exists
-        $stmt = $pdo->prepare("SELECT * FROM Notes WHERE id = ?");
-        $stmt->execute([$noteId]);
-        $existingNote = $stmt->fetch(PDO::FETCH_ASSOC);
-        
-        if (!$existingNote) {
-            $pdo->rollBack();
-            ApiResponse::error('Note not found', 404);
-        }
-
-        // --- BEGIN order_index recalculation logic: Step 1 ---
-        $old_parent_note_id = null;
-        $old_order_index = null;
-        $page_id_for_reordering = $existingNote['page_id']; // page_id should not change
-
-        // Only fetch old parent and order if parent_note_id is part of the input,
-        // or if order_index is changing (which might imply a move between siblings lists if parent_note_id is also changing)
-        // For now, to be safe, we fetch if parent_note_id is potentially changing.
-        // The problem description says "If parent_note_id is present in the $input (meaning it might change)"
-        if (array_key_exists('parent_note_id', $input) || array_key_exists('order_index', $input)) {
-            $old_parent_note_id = $existingNote['parent_note_id'];
-            $old_order_index = $existingNote['order_index'];
-        }
-        // --- END order_index recalculation logic: Step 1 ---
-        
-        // Build the SET part of the SQL query dynamically
-        $setClauses = [];
-        $executeParams = [];
-
-        if (isset($input['content'])) {
-            $setClauses[] = "content = ?";
-            $executeParams[] = $input['content'];
-        }
-        if (array_key_exists('parent_note_id', $input)) { // Use array_key_exists to allow null
-            $setClauses[] = "parent_note_id = ?";
-            $executeParams[] = $input['parent_note_id'] === null ? null : (int)$input['parent_note_id'];
-        }
-        if (isset($input['order_index'])) {
-            $setClauses[] = "order_index = ?";
-            $executeParams[] = (int)$input['order_index'];
-        }
-        if (isset($input['collapsed'])) {
-            $setClauses[] = "collapsed = ?";
-            $executeParams[] = (int)$input['collapsed']; // Should be 0 or 1
-        }
-
-        if (empty($setClauses) && !isset($input['properties_explicit'])) {
-            $pdo->rollBack();
-            ApiResponse::error('No updateable fields provided', 400);
-            return; // Exit early
-        }
-
-        if (!empty($setClauses)) {
-            $setClauses[] = "updated_at = CURRENT_TIMESTAMP";
-        
-            $sql = "UPDATE Notes SET " . implode(", ", $setClauses) . " WHERE id = ?";
-            $executeParams[] = $noteId;
-            
-            $stmt = $pdo->prepare($sql);
-            $stmt->execute($executeParams);
-        }
-
-        // --- BEGIN order_index recalculation logic: Step 2 & 3 & 4 (omitted for brevity) ---
-        // ... logic for reordering ...
-
-        // --- BEGIN properties LOGIC ---
-        // Always delete existing non-internal properties if content or explicit properties are being updated.
-        // This simplifies logic and prevents orphaned properties.
-        if (isset($input['content']) || (isset($input['properties_explicit']) && !empty($input['properties_explicit']))) {
-            $stmtDeleteOld = $pdo->prepare("DELETE FROM Properties WHERE note_id = :note_id AND internal = 0");
-            $stmtDeleteOld->execute([':note_id' => $noteId]);
-        
-            $propertiesToSave = [];
-
-            // If explicit properties are provided, use them.
-            if (isset($input['properties_explicit']) && is_array($input['properties_explicit']) && !empty($input['properties_explicit'])) {
-                foreach ($input['properties_explicit'] as $name => $values) {
-                    if (!is_array($values)) {
-                        $values = [$values];
-                    }
-                    foreach ($values as $value) {
-                        $propertiesToSave[] = ['name' => $name, 'value' => (string)$value];
-                    }
-                }
-            } 
-            // Otherwise, if content is updated and the note is not encrypted, parse properties from content.
-            else if (isset($input['content'])) {
-                $encryptedStmt = $pdo->prepare("SELECT value FROM Properties WHERE note_id = :note_id AND name = 'encrypted' AND internal = 1 LIMIT 1");
-                $encryptedStmt->execute([':note_id' => $noteId]);
-                $encryptedProp = $encryptedStmt->fetch(PDO::FETCH_ASSOC);
-
-                if (!$encryptedProp || $encryptedProp['value'] !== 'true') {
-                    $processor = getPatternProcessor();
-                    $processedData = $processor->processContent($input['content'], 'note', $noteId);
-                    if (!empty($processedData['properties'])) {
-                        $propertiesToSave = $processedData['properties'];
-                    }
-                }
-            }
-
-            // Save the collected properties to the database using the centralized function.
-            if (!empty($propertiesToSave)) {
-                foreach ($propertiesToSave as $prop) {
-                     _updateOrAddPropertyAndDispatchTriggers(
-                        $pdo,
-                        'note',
-                        $noteId,
-                        $prop['name'],
-                        $prop['value']
-                    );
-                }
-            }
-        }
-        // --- END properties LOGIC ---
-
-        // Check and set internal flag for the note
-        _checkAndSetNoteInternalFlag($pdo, $noteId);
-        
-        // Fetch updated note
-        $stmt = $pdo->prepare("SELECT * FROM Notes WHERE id = ?");
-        $stmt->execute([$noteId]);
-        $note = $stmt->fetch(PDO::FETCH_ASSOC);
-        
-        // Get ALL properties for the response, with detailed structure
-        $propSql = "SELECT name, value, internal FROM Properties WHERE note_id = :note_id ORDER BY name";
-        $stmtProps = $pdo->prepare($propSql);
-        $stmtProps->bindParam(':note_id', $note['id'], PDO::PARAM_INT);
-        $stmtProps->execute();
-        $propertiesResult = $stmtProps->fetchAll(PDO::FETCH_ASSOC);
-
-        $note['properties'] = [];
-        foreach ($propertiesResult as $prop) {
-            if (!isset($note['properties'][$prop['name']])) {
-                $note['properties'][$prop['name']] = [];
-            }
-            $note['properties'][$prop['name']][] = [
-                'value' => $prop['value'],
-                'internal' => (int)$prop['internal']
-            ];
-        }
-        
-        $pdo->commit();
-        ApiResponse::success($note);
-    } catch (PDOException $e) {
-        $pdo->rollBack();
-        error_log("Failed to update note: " . $e->getMessage());
-        ApiResponse::error('Failed to update note: ' . $e->getMessage(), 500);
-    }
+    ApiResponse::error('PUT is deprecated. Please use POST with batch operations for updates.', 405);
 } elseif ($method === 'DELETE') {
-    // For phpdesktop compatibility, also check for ID in request body when using method override
-    $noteId = null;
-    if (isset($_GET['id'])) {
-        $noteId = (int)$_GET['id'];
-    } elseif (isset($input['id'])) {
-        $noteId = (int)$input['id'];
-    }
-    
-    if (!$noteId) {
-        ApiResponse::error('Note ID is required', 400);
-    }
-    
-    try {
-        $pdo->beginTransaction();
-        
-        // Check if note exists
-        $stmt = $pdo->prepare("SELECT * FROM Notes WHERE id = ?");
-        $stmt->execute([$noteId]);
-        if (!$stmt->fetch()) {
-            $pdo->rollBack();
-            ApiResponse::error('Note not found', 404);
-        }
-        
-        // Delete properties first (due to foreign key constraint)
-        $stmt = $pdo->prepare("DELETE FROM Properties WHERE note_id = ?"); // Corrected column name
-        $stmt->execute([$noteId]);
-        
-        // Delete the note
-        $stmt = $pdo->prepare("DELETE FROM Notes WHERE id = ?");
-        $stmt->execute([$noteId]);
-        
-        $pdo->commit();
-        ApiResponse::success(['deleted_note_id' => $noteId]);
-    } catch (PDOException $e) {
-        $pdo->rollBack();
-        ApiResponse::error('Failed to delete note: ' . $e->getMessage(), 500);
-    }
+    ApiResponse::error('DELETE is deprecated. Please use POST with batch operations for deletions.', 405);
 } else {
     ApiResponse::error('Method not allowed', 405);
 }
\ No newline at end of file
diff --git a/api/v1/pages.php b/api/v1/pages.php
index e52ee4c..1515996 100644
--- a/api/v1/pages.php
+++ b/api/v1/pages.php
@@ -1,563 +1,184 @@
 <?php
-require_once __DIR__ . '/../db_connect.php';
-require_once __DIR__ . '/../response_utils.php'; // Include the new response utility
-require_once __DIR__ . '/../data_manager.php';   // Include the new DataManager
-require_once __DIR__ . '/../validator_utils.php'; // Include the new Validator
-
-// header('Content-Type: application/json'); // Will be handled by ApiResponse
-$pdo = get_db_connection();
-$dataManager = new DataManager($pdo); // Instantiate DataManager
-$method = $_SERVER['REQUEST_METHOD'];
-$rawInput = file_get_contents('php://input');
-$input = json_decode($rawInput, true);
-
-if (!class_exists('PageManager')) {
-    class PageManager {
-        private $pdo;
-        private $dataManager;
-
-    public function __construct($pdo) {
-        $this->pdo = $pdo;
-        $this->dataManager = new DataManager($pdo);
-    }
-
-    public function isJournalPage($name) {
-        return preg_match('/^\d{4}-\d{2}-\d{2}$/', $name) || strtolower($name) === 'journal';
-    }
-
-    private function addJournalProperty($pageId) {
-        $stmt = $this->pdo->prepare("
-            INSERT INTO Properties (page_id, name, value)
-            VALUES (?, 'type', 'journal')
-        ");
-        $stmt->execute([$pageId]);
-    }
-
-    private function resolvePageAlias($pageData, $followAliases = true) {
-        if (!$followAliases || !$pageData || empty($pageData['alias'])) {
-            return $pageData;
-        }
-        
-        try {
-            $stmt = $this->pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(?)");
-            $stmt->execute([$pageData['alias']]);
-            $aliasedPage = $stmt->fetch();
-            
-            if ($aliasedPage) {
-                return $this->resolvePageAlias($aliasedPage, true);
-            }
-        } catch (PDOException $e) {
-            error_log("Error resolving alias for page {$pageData['id']}: " . $e->getMessage());
-        }
-        
-        return $pageData;
-    }
-
-    public function handleRequest() {
-        $method = $_SERVER['REQUEST_METHOD'];
-        $rawInput = file_get_contents('php://input');
-        $input = json_decode($rawInput, true);
+// api/v1/pages.php
 
-        // Debug logging
-        error_log("[PageManager] Raw input: " . $rawInput);
-        error_log("[PageManager] Parsed input: " . json_encode($input));
-        error_log("[PageManager] JSON decode error: " . json_last_error_msg());
+/**
+ * Endpoint for all Page-related operations.
+ * This file acts as a router, delegating all logic to the DataManager.
+ */
 
-        // Handle POST with _method for REST compatibility
-        if ($method === 'POST' && isset($input['_method'])) {
-            switch (strtoupper($input['_method'])) {
-                case 'PUT':
-                    $this->handlePostUpdate($input);
-                    break;
-                case 'DELETE':
-                    $this->handlePostDelete($input);
-                    break;
-                default:
-                    ApiResponse::error('Invalid _method specified', 400);
+require_once __DIR__ . '/../db_connect.php';
+require_once __DIR__ . '/../data_manager.php';
+require_once __DIR__ . '/../property_parser.php';
+require_once __DIR__ . '/../response_utils.php';
+
+if (!function_exists('_indexPropertiesFromContent')) {
+    function _indexPropertiesFromContent($pdo, $entityType, $entityId, $content) {
+        // For pages, we don't have the 'encrypted' property check as for notes.
+
+        // 1. Get weights for properties with 'replace' behavior from config
+        $replaceableWeights = [];
+        if (defined('PROPERTY_WEIGHTS')) {
+            foreach (PROPERTY_WEIGHTS as $weight => $config) {
+                if (isset($config['update_behavior']) && $config['update_behavior'] === 'replace') {
+                    $replaceableWeights[] = (int)$weight;
+                }
             }
-            return;
-        }
-
-        // Handle standard HTTP methods
-        switch ($method) {
-            case 'GET':
-                $this->handleGetRequest();
-                break;
-            case 'POST':
-                $this->handlePostRequest($input);
-                break;
-            default:
-                ApiResponse::error('Method Not Allowed', 405);
-        }
-    }
-
-    private function handleGetRequest() {
-        $followAliases = !isset($_GET['follow_aliases']) || $_GET['follow_aliases'] !== '0';
-        $include_details = isset($_GET['include_details']) && $_GET['include_details'] === '1';
-        $include_internal = filter_input(INPUT_GET, 'include_internal', FILTER_VALIDATE_BOOLEAN);
-
-        if (isset($_GET['id'])) {
-            $this->handleGetById($followAliases, $include_details, $include_internal);
-        } elseif (isset($_GET['name'])) {
-            $this->handleGetByName($followAliases, $include_details, $include_internal);
-        } else {
-            $this->handleGetAll($followAliases, $include_details, $include_internal);
-        }
-    }
-
-    private function handleGetById($followAliases, $include_details, $include_internal) {
-        $validationRules = ['id' => 'required|isPositiveInteger'];
-        $errors = Validator::validate($_GET, $validationRules);
-        if (!empty($errors)) {
-            ApiResponse::error('Invalid page ID.', 400, $errors);
-            return;
         }
         
-        $pageId = (int)$_GET['id'];
-        $pageData = $include_details ? 
-            $this->dataManager->getPageWithNotes($pageId, $include_internal) :
-            $this->dataManager->getPageDetailsById($pageId, $include_internal);
-
-        if ($pageData) {
-            $pageToResolve = $include_details ? $pageData['page'] : $pageData;
-            
-            if ($followAliases && !empty($pageToResolve['alias'])) {
-                $stmt = $this->pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(?)");
-                $stmt->execute([$pageToResolve['alias']]);
-                $aliasedPageInfo = $stmt->fetch(PDO::FETCH_ASSOC);
-
-                if ($aliasedPageInfo) {
-                    $pageData = $include_details ?
-                        $this->dataManager->getPageWithNotes($aliasedPageInfo['id'], $include_internal) :
-                        $this->dataManager->getPageDetailsById($aliasedPageInfo['id'], $include_internal);
-                }
-            }
-
-            // Ensure consistent response format
-            if ($include_details) {
-                // For detailed view, wrap in data object to match list format
-                ApiResponse::success([
-                    'data' => $pageData,
-                    'pagination' => null // No pagination for single item
+        // 2. Clear all existing 'replaceable' properties for the entity.
+        // Properties with 'append' behavior (like system logs) are preserved.
+        if (!empty($replaceableWeights)) {
+            $placeholders = str_repeat('?,' , count($replaceableWeights) - 1) . '?';
+            $idColumn = $entityType . '_id';
+            $deleteSql = "DELETE FROM Properties WHERE {$idColumn} = ? AND weight IN ($placeholders)";
+            $stmtDelete = $pdo->prepare($deleteSql);
+            $stmtDelete->execute(array_merge([$entityId], $replaceableWeights));
+        }
+
+        // 3. Parse new properties from the provided content.
+        $propertyParser = new PropertyParser($pdo);
+        $parsedProperties = $propertyParser->parsePropertiesFromContent($content);
+
+        // 4. Insert all parsed properties into the database.
+        // This adds new 'replaceable' properties and all 'appendable' properties.
+        if (!empty($parsedProperties)) {
+            $idColumn = $entityType . '_id';
+            $insertSql = "INSERT INTO Properties ({$idColumn}, name, value, weight) VALUES (?, ?, ?, ?)";
+            $stmtInsert = $pdo->prepare($insertSql);
+
+            foreach ($parsedProperties as $prop) {
+                $stmtInsert->execute([
+                    $entityId,
+                    $prop['name'],
+                    (string)$prop['value'],
+                    $prop['weight']
                 ]);
-            } else {
-                // For basic view, return the page directly
-                ApiResponse::success($pageData);
             }
-        } else {
-            ApiResponse::error('Page not found', 404);
         }
     }
+}
 
-    private function handleGetByName($followAliases, $include_details, $include_internal) {
-        $validationRules = ['name' => 'required|isNotEmpty'];
-        $errors = Validator::validate($_GET, $validationRules);
-        if (!empty($errors)) {
-            ApiResponse::error('Invalid page name.', 400, $errors);
-            return;
-        }
-
-        $pageName = Validator::sanitizeString($_GET['name']);
+$method = $_SERVER['REQUEST_METHOD'];
+$input = json_decode(file_get_contents('php://input'), true) ?? [];
 
-        try {
-            $stmt = $this->pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(?)");
-            $stmt->execute([$pageName]);
-            $page = $stmt->fetch(PDO::FETCH_ASSOC);
+if ($method === 'POST' && isset($input['_method'])) {
+    $method = strtoupper($input['_method']);
+}
 
-            if ($page) {
-                $page['properties'] = $this->dataManager->getPageProperties($page['id'], $include_internal);
-                
-                if ($followAliases && !empty($page['alias'])) {
-                    $stmt = $this->pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(?)");
-                    $stmt->execute([$page['alias']]);
-                    $aliasedPageInfo = $stmt->fetch(PDO::FETCH_ASSOC);
-                    if ($aliasedPageInfo) {
-                        $aliasedPageInfo['properties'] = $this->dataManager->getPageProperties($aliasedPageInfo['id'], $include_internal);
-                        $page = $aliasedPageInfo;
-                    }
+$pdo = get_db_connection();
+$dataManager = new DataManager($pdo);
+$propertyParser = new PropertyParser($pdo);
+
+try {
+    switch ($method) {
+        case 'GET':
+            if (isset($_GET['name'])) {
+                $page = $dataManager->getPageByName($_GET['name']);
+                if ($page) {
+                    ApiResponse::success($page);
+                } else {
+                    ApiResponse::error('Page not found', 404);
                 }
-                ApiResponse::success($page);
-            } else {
-                // Page not found, try to create it
-                try {
-                    $this->pdo->beginTransaction();
-
-                    // Insert the new page
-                    $insertStmt = $this->pdo->prepare("INSERT INTO Pages (name, alias, updated_at) VALUES (?, NULL, CURRENT_TIMESTAMP)");
-                    $insertStmt->execute([$pageName]);
-                    $pageId = $this->pdo->lastInsertId();
-
-                    // If it's a journal page, add the journal property
-                    if ($this->isJournalPage($pageName)) {
-                        $this->addJournalProperty($pageId);
-                    }
-
-                    // Fetch the newly created page
-                    $selectStmt = $this->pdo->prepare("SELECT * FROM Pages WHERE id = ?");
-                    $selectStmt->execute([$pageId]);
-                    $newPage = $selectStmt->fetch(PDO::FETCH_ASSOC);
-                    
-                    if ($newPage) {
-                        $newPage['properties'] = $this->dataManager->getPageProperties($newPage['id'], $include_internal);
-                    }
-
-                    $this->pdo->commit();
-                    ApiResponse::success($newPage, 201); // 201 Created
-                } catch (PDOException $e) {
-                    if ($this->pdo->inTransaction()) {
-                        $this->pdo->rollBack();
-                    }
-                    // Check for unique constraint violation, which might happen in a race condition
-                    // If so, try to fetch the page again as it might have been created by another request.
-                    if ($e->getCode() == 23000 || str_contains(strtolower($e->getMessage()), 'unique constraint failed')) {
-                        error_log("Unique constraint violation during page creation attempt for: " . $pageName . ". Attempting to re-fetch.");
-                        $retryStmt = $this->pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(?)");
-                        $retryStmt->execute([$pageName]);
-                        $existingPage = $retryStmt->fetch(PDO::FETCH_ASSOC);
-                        if ($existingPage) {
-                            $existingPage['properties'] = $this->dataManager->getPageProperties($existingPage['id'], $include_internal);
-                             if ($this->isJournalPage($pageName)) { // Ensure journal property if it was a journal page
-                                $stmt_check_prop = $this->pdo->prepare("
-                                    SELECT 1 FROM Properties 
-                                    WHERE page_id = ? 
-                                    AND name = 'type' 
-                                    AND value = 'journal'
-                                ");
-                                $stmt_check_prop->execute([$existingPage['id']]);
-                                if (!$stmt_check_prop->fetch()) {
-                                    $this->addJournalProperty($existingPage['id']);
-                                    // Re-fetch properties if a new one was added
-                                    $existingPage['properties'] = $this->dataManager->getPageProperties($existingPage['id'], $include_internal);
-                                }
-                            }
-                            ApiResponse::success($existingPage);
-                            return;
-                        }
-                    }
-                    ApiResponse::error('Failed to create page: ' . $e->getMessage(), 500, ['details' => $e->getMessage()]);
+            } elseif (isset($_GET['id'])) {
+                $page = $dataManager->getPageById((int)$_GET['id']);
+                if ($page) {
+                    ApiResponse::success($page);
+                } else {
+                    ApiResponse::error('Page not found', 404);
                 }
+            } elseif (isset($_GET['date'])) {
+                $pages = $dataManager->getPagesByDate($_GET['date']);
+                ApiResponse::success($pages);
+            } else {
+                $page = $_GET['page'] ?? 1;
+                $per_page = $_GET['per_page'] ?? 20;
+                $options = [
+                    'exclude_journal' => isset($_GET['exclude_journal'])
+                ];
+                $result = $dataManager->getPages((int)$page, (int)$per_page, $options);
+                
+                // This now returns the correct, non-double-wrapped structure
+                ApiResponse::success($result['data'], 200, ['pagination' => $result['pagination']]);
             }
-        } catch (PDOException $e) {
-            ApiResponse::error('Database error.', 500, ['details' => $e->getMessage()]);
-        }
-    }
+            break;
 
-    private function handleGetAll($followAliases, $include_details, $include_internal) {
-        $excludeJournal = isset($_GET['exclude_journal']) && $_GET['exclude_journal'] === '1';
-        
-        // Pagination parameters
-        $page = max(1, isset($_GET['page']) ? (int)$_GET['page'] : 1);
-        $perPage = max(1, min(100, isset($_GET['per_page']) ? (int)$_GET['per_page'] : 20));
-        $offset = ($page - 1) * $perPage;
-
-        // Get total count for pagination
-        $countSql = $excludeJournal ?
-            "SELECT COUNT(*) FROM Pages WHERE NOT (name GLOB '[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]' OR LOWER(name) = 'journal')" :
-            "SELECT COUNT(*) FROM Pages";
-        
-        $totalCount = $this->pdo->query($countSql)->fetchColumn();
-        
-        // Get paginated results
-        $sql = $excludeJournal ?
-            "SELECT id, name, alias, updated_at FROM Pages WHERE NOT (name GLOB '[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]' OR LOWER(name) = 'journal') ORDER BY updated_at DESC, name ASC LIMIT ? OFFSET ?" :
-            "SELECT id, name, alias, updated_at FROM Pages ORDER BY updated_at DESC, name ASC LIMIT ? OFFSET ?";
-        
-        $stmt = $this->pdo->prepare($sql);
-        $stmt->execute([$perPage, $offset]);
-        $pages = $stmt->fetchAll(PDO::FETCH_ASSOC);
+        case 'POST': // Create
+            $name = $input['name'] ?? null;
+            $content = $input['content'] ?? null;
 
-        if ($followAliases) {
-            $resolvedPages = [];
-            $seenIds = [];
-            foreach ($pages as $page) {
-                $resolvedPage = $this->resolvePageAlias($page, true);
-                if ($resolvedPage && !in_array($resolvedPage['id'], $seenIds)) {
-                    $resolvedPages[] = $resolvedPage;
-                    $seenIds[] = $resolvedPage['id'];
-                } elseif (!$resolvedPage && !in_array($page['id'], $seenIds)) {
-                    $resolvedPages[] = $page;
-                    $seenIds[] = $page['id'];
-                }
+            if (!$name) {
+                ApiResponse::error('Page name is required.', 400);
             }
-            $pages = $resolvedPages;
-        }
-
-        if ($include_details) {
-            $detailedPages = [];
-            foreach ($pages as $page) {
-                $pageDetail = $this->dataManager->getPageWithNotes($page['id'], $include_internal);
-                if ($pageDetail) {
-                    $detailedPages[] = $pageDetail;
-                }
+            if ($dataManager->getPageByName($name)) {
+                ApiResponse::error('Page with this name already exists.', 409);
             }
-            $pages = $detailedPages;
-        }
-        
-        // Prepare pagination metadata
-        $totalPages = ceil($totalCount / $perPage);
-        $pagination = [
-            'current_page' => $page,
-            'per_page' => $perPage,
-            'total_pages' => $totalPages,
-            'total_items' => $totalCount,
-            'has_next_page' => $page < $totalPages,
-            'has_prev_page' => $page > 1
-        ];
-        
-        ApiResponse::success([
-            'data' => $pages,
-            'pagination' => $pagination
-        ]);
-    }
 
-    private function handlePostRequest($input) {
-        // Debug logging
-        error_log("[PageManager] POST request input: " . json_encode($input));
-        
-        $validationRules = [
-            'name' => 'required|isNotEmpty',
-            'alias' => 'optional'
-        ];
-        $errors = Validator::validate($input, $validationRules);
-        if (!empty($errors)) {
-            error_log("[PageManager] Validation errors: " . json_encode($errors));
-            ApiResponse::error('Invalid input for creating page.', 400, [
-                'validation_errors' => $errors,
-                'received_input' => $input,
-                'input_type' => gettype($input)
-            ]);
-            return;
-        }
-
-        $name = Validator::sanitizeString($input['name']);
-        $alias = isset($input['alias']) ? Validator::sanitizeString($input['alias']) : null;
-        
-        try {
-            $this->pdo->beginTransaction();
+            $pdo->beginTransaction();
+            $stmt = $pdo->prepare("INSERT INTO Pages (name, content) VALUES (:name, :content)");
+            $stmt->execute([':name' => $name, ':content' => $content]);
+            $pageId = $pdo->lastInsertId();
             
-            $stmt_check = $this->pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(?)");
-            $stmt_check->execute([$name]);
-            $existing_page = $stmt_check->fetch();
-
-            if ($existing_page) {
-                if ($this->isJournalPage($name)) {
-                    $stmt_check_prop = $this->pdo->prepare("
-                        SELECT 1 FROM Properties 
-                        WHERE page_id = ? 
-                        AND name = 'type' 
-                        AND value = 'journal'
-                    ");
-                    $stmt_check_prop->execute([$existing_page['id']]);
-                    if (!$stmt_check_prop->fetch()) {
-                        $this->addJournalProperty($existing_page['id']);
-                    }
-                }
-                $this->pdo->commit();
-                ApiResponse::success($existing_page);
-                return;
-            }
-
-            // If it's a journal page and doesn't exist, create it
-            if ($this->isJournalPage($name)) {
-                $stmt = $this->pdo->prepare("INSERT INTO Pages (name, alias, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)");
-                $stmt->execute([$name, $alias]);
-                $page_id = $this->pdo->lastInsertId();
-                $this->addJournalProperty($page_id);
-                
-                $stmt_new = $this->pdo->prepare("SELECT * FROM Pages WHERE id = ?");
-                $stmt_new->execute([$page_id]);
-                $newPage = $stmt_new->fetch();
-                
-                $this->pdo->commit();
-                ApiResponse::success($newPage, 201);
-                return;
+            if ($content) {
+                _indexPropertiesFromContent($pdo, 'page', $pageId, $content);
             }
+            $pdo->commit();
 
-            // For non-journal pages, proceed with normal creation
-            $stmt = $this->pdo->prepare("INSERT INTO Pages (name, alias, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)");
-            $stmt->execute([$name, $alias]);
-            $page_id = $this->pdo->lastInsertId();
-            
-            $stmt_new = $this->pdo->prepare("SELECT * FROM Pages WHERE id = ?");
-            $stmt_new->execute([$page_id]);
-            $newPage = $stmt_new->fetch();
-            
-            $this->pdo->commit();
+            $newPage = $dataManager->getPageById($pageId);
             ApiResponse::success($newPage, 201);
-        } catch (PDOException $e) {
-            $this->pdo->rollBack();
-            ApiResponse::error('Failed to create page: ' . $e->getMessage(), 500);
-        }
-    }
-
-    private function handlePostUpdate($input) {
-        // Get page ID from either URL parameter or request body
-        $pageId = isset($_GET['id']) ? (int)$_GET['id'] : (isset($input['id']) ? (int)$_input['id'] : null);
-        
-        if (!$pageId) {
-            ApiResponse::error('Page ID is required for update', 400);
-            return;
-        }
+            break;
 
-        // Remove action/_method from input before validation
-        unset($input['action'], $input['_method']);
-
-        if (!isset($input['name']) && !array_key_exists('alias', $input)) {
-            ApiResponse::error('Either name or alias must be provided for update.', 400);
-            return;
-        }
-
-        $validationRulesPUT = [
-            'name' => 'optional|isNotEmpty',
-            'alias' => 'optional'
-        ];
-        $errorsPUT = Validator::validate($input, $validationRulesPUT);
-        if (!empty($errorsPUT)) {
-            ApiResponse::error('Invalid input for updating page.', 400, $errorsPUT);
-            return;
-        }
-
-        // Rest of the update logic remains the same as handlePutRequest
-        $fields_to_update = [];
-        $params = [];
-        
-        if (isset($input['name'])) {
-            $name = Validator::sanitizeString($input['name']);
-            $fields_to_update[] = "name = ?";
-            $params[] = $name;
-        }
-        
-        if (array_key_exists('alias', $input)) {
-            $alias = $input['alias'] !== null ? Validator::sanitizeString($input['alias']) : null;
-            $fields_to_update[] = "alias = ?";
-            $params[] = $alias;
-        }
-        
-        if (empty($fields_to_update)) {
-            ApiResponse::error('No valid fields to update provided (name or alias).', 400);
-            return;
-        }
-        
-        try {
-            $this->pdo->beginTransaction();
-            
-            $stmt_check = $this->pdo->prepare("SELECT name FROM Pages WHERE id = ? FOR UPDATE");
-            $stmt_check->execute([$pageId]);
-            $current_page = $stmt_check->fetch();
-            
-            if (!$current_page) {
-                $this->pdo->rollBack();
-                ApiResponse::error('Page not found', 404);
-                return;
-            }
-            
-            if (isset($input['name']) && $input['name'] !== $current_page['name']) {
-                $stmt_unique = $this->pdo->prepare("SELECT id FROM Pages WHERE LOWER(name) = LOWER(?) AND id != ?");
-                $stmt_unique->execute([$name, $pageId]);
-                if ($stmt_unique->fetch()) {
-                    $this->pdo->rollBack();
-                    ApiResponse::error('Page name already exists', 409);
-                    return;
-                }
+        case 'PUT': // Update
+            $pageId = $input['id'] ?? null;
+            if (!$pageId) {
+                ApiResponse::error('Page ID is required for update.', 400);
             }
-            
-            $fields_to_update[] = "updated_at = CURRENT_TIMESTAMP";
-            $sql = "UPDATE Pages SET " . implode(', ', $fields_to_update) . " WHERE id = ?";
-            $params[] = $pageId;
-            
-            $stmt = $this->pdo->prepare($sql);
-            $stmt->execute($params);
-            
-            $stmt_updated = $this->pdo->prepare("SELECT * FROM Pages WHERE id = ?");
-            $stmt_updated->execute([$pageId]);
-            $updated_page = $stmt_updated->fetch();
 
-            if ($updated_page) {
-                $newName = $updated_page['name'];
-                if ($this->isJournalPage($newName)) {
-                    $stmt_check_prop = $this->pdo->prepare("SELECT 1 FROM Properties WHERE page_id = ? AND name = 'type' AND value = 'journal'");
-                    $stmt_check_prop->execute([$pageId]);
-                    if (!$stmt_check_prop->fetch()) {
-                        $this->addJournalProperty($pageId);
-                    }
-                }
+            // Fetch existing page to ensure it exists
+            $page = $dataManager->getPageById($pageId);
+            if (!$page) {
+                ApiResponse::error('Page not found.', 404);
             }
-            
-            $this->pdo->commit();
-            ApiResponse::success($updated_page);
-        } catch (PDOException $e) {
-            $this->pdo->rollBack();
-            ApiResponse::error('Failed to update page: ' . $e->getMessage(), 500);
-        }
-    }
-
-    private function handlePostDelete($input) {
-        // Get page ID from either URL parameter or request body
-        $pageId = isset($_GET['id']) ? (int)$_GET['id'] : (isset($input['id']) ? (int)$_input['id'] : null);
-        
-        if (!$pageId) {
-            ApiResponse::error('Page ID is required for deletion', 400);
-            return;
-        }
 
-        try {
-            $this->pdo->beginTransaction();
+            $newName = $input['name'] ?? $page['name'];
+            $newContent = $input['content'] ?? $page['content'];
             
-            $stmt_check = $this->pdo->prepare("SELECT id FROM Pages WHERE id = ? FOR UPDATE");
-            $stmt_check->execute([$pageId]);
-            if (!$stmt_check->fetch()) {
-                $this->pdo->rollBack();
-                ApiResponse::error('Page not found', 404);
-                return;
+            $pdo->beginTransaction();
+            $stmt = $pdo->prepare("UPDATE Pages SET name = :name, content = :content, updated_at = CURRENT_TIMESTAMP WHERE id = :id");
+            $stmt->execute([':name' => $newName, ':content' => $newContent, ':id' => $pageId]);
+
+            // Re-index properties if content changed
+            if (array_key_exists('content', $input)) {
+                _indexPropertiesFromContent($pdo, 'page', $pageId, $newContent);
             }
+            $pdo->commit();
             
-            $stmt = $this->pdo->prepare("DELETE FROM Pages WHERE id = ?");
-            $stmt->execute([$pageId]);
-            
-            $this->pdo->commit();
-            ApiResponse::success(['deleted_page_id' => $pageId]);
-        } catch (PDOException $e) {
-            $this->pdo->rollBack();
-            ApiResponse::error('Failed to delete page: ' . $e->getMessage(), 500);
-        }
-    }
+            $updatedPage = $dataManager->getPageById($pageId);
+            ApiResponse::success($updatedPage);
+            break;
 
-    private function createJournalPage($pageName, $include_internal) {
-        try {
-            $this->pdo->beginTransaction();
-            
-            $insert_stmt = $this->pdo->prepare("INSERT INTO Pages (name, updated_at) VALUES (?, CURRENT_TIMESTAMP)");
-            $insert_stmt->execute([$pageName]);
-            $pageId = $this->pdo->lastInsertId();
-            
-            $this->addJournalProperty($pageId);
-            
-            $this->pdo->commit();
-            
-            $newPage = $this->dataManager->getPageDetailsById($pageId, $include_internal);
-            ApiResponse::success($newPage);
-        } catch (PDOException $e) {
-            if ($this->pdo->inTransaction()) {
-                $this->pdo->rollBack();
+        case 'DELETE':
+            $pageId = $input['id'] ?? null;
+            if (!$pageId) {
+                ApiResponse::error('Page ID is required for deletion.', 400);
             }
-            if ($e->getCode() == 23000 || str_contains($e->getMessage(), 'UNIQUE constraint failed')) {
-                $stmt = $this->pdo->prepare("SELECT * FROM Pages WHERE LOWER(name) = LOWER(?)");
-                $stmt->execute([$pageName]);
-                $page = $stmt->fetch(PDO::FETCH_ASSOC);
-                if ($page) {
-                    $page['properties'] = $this->dataManager->getPageProperties($page['id'], $include_internal);
-                    ApiResponse::success($page);
-                } else {
-                    ApiResponse::error('Failed to resolve page creation race condition.', 500, ['details' => $e->getMessage()]);
-                }
+            $stmt = $pdo->prepare("DELETE FROM Pages WHERE id = :id");
+            $stmt->execute([':id' => $pageId]);
+
+            if ($stmt->rowCount() > 0) {
+                ApiResponse::success(['deleted_page_id' => $pageId]);
             } else {
-                ApiResponse::error('Database error.', 500, ['details' => $e->getMessage()]);
+                ApiResponse::error('Page not found.', 404);
             }
-        }
+            break;
+
+        default:
+            ApiResponse::error('Method not supported.', 405);
+            break;
     }
-}
-}
-// Initialize and handle the request
-$pdo = get_db_connection();
-$pageManager = new PageManager($pdo);
-$pageManager->handleRequest();
+} catch (Exception $e) {
+    if ($pdo->inTransaction()) {
+        $pdo->rollBack();
+    }
+    // Let the global exception handler in config.php format the error
+    throw $e;
+}
\ No newline at end of file
diff --git a/api/v1/properties.php b/api/v1/properties.php
index 2e4d898..402cf72 100644
--- a/api/v1/properties.php
+++ b/api/v1/properties.php
@@ -1,39 +1,13 @@
 <?php
 require_once __DIR__ . '/../../config.php';
 require_once __DIR__ . '/../db_connect.php';
-// require_once __DIR__ . '/../property_triggers.php'; // Old trigger system replaced
-require_once __DIR__ . '/../property_trigger_service.php'; // New trigger service
-require_once __DIR__ . '/../property_auto_internal.php';
-require_once __DIR__ . '/../response_utils.php'; // Include the new response utility
-require_once __DIR__ . '/../data_manager.php';   // Include the new DataManager
-require_once __DIR__ . '/../validator_utils.php'; // Include the new Validator
+// The 'Writer' logic is now handled by PropertyParser and called from note/page update endpoints.
+// require_once __DIR__ . '/../property_parser.php'; 
+require_once __DIR__ . '/../response_utils.php';
+require_once __DIR__ . '/../data_manager.php';
+require_once __DIR__ . '/../validator_utils.php';
 
-// header('Content-Type: application/json'); // Will be handled by ApiResponse
-
-// This specific validation can be replaced by Validator class or kept if it has special logic (like tag normalization)
-// For now, let's assume Validator can handle 'name' and 'value' presence, but tag normalization is specific.
-// We might call Validator first, then this if basic checks pass.
-if (!function_exists('validate_property_data')) {
-    function validate_property_data($data) {
-        if (!isset($data['name']) || !isset($data['value'])) {
-            return false;
-        }
-        
-        // Handle tag::tag format
-        if (strpos($data['name'], 'tag::') === 0) {
-            $tagName = substr($data['name'], 5);
-            if (empty($tagName)) {
-                return false;
-            }
-            // Normalize tag value to match the tag name
-            $data['value'] = $tagName;
-        }
-        
-        return $data;
-    }
-}
-
-// Add this helper function after validate_property_data
+// Helper function to check for entity existence.
 if (!function_exists('checkEntityExists')) {
     function checkEntityExists($pdo, $entityType, $entityId) {
         if ($entityType === 'note') {
@@ -46,83 +20,16 @@ if (!function_exists('checkEntityExists')) {
     }
 }
 
-/**
- * Core function to add/update a property, determine its internal status, and dispatch triggers.
- * This function assumes $pdo is available and a transaction might be externally managed if multiple operations are batched.
- * If no transaction is externally managed, it should handle its own.
- *
- * @param PDO $pdo The PDO database connection object.
- * @param string $entityType 'note' or 'page'.
- * @param int $entityId The ID of the note or page.
- * @param string $name The name of the property.
- * @param mixed $value The value of the property.
- * @param int|null $explicitInternal Explicitly sets the internal status (0 or 1). If null, it's determined automatically.
- * @return array Associative array with 'name', 'value', 'internal' of the saved property.
- * @throws Exception If validation fails or DB operation fails.
- */
-if (!function_exists('_updateOrAddPropertyAndDispatchTriggers')) {
-    function _updateOrAddPropertyAndDispatchTriggers($pdo, $entityType, $entityId, $name, $value, $explicitInternal = null) {
-        // Validate and normalize property data
-        $propertyData = validate_property_data(['name' => $name, 'value' => $value]);
-    if (!$propertyData) {
-        throw new Exception('Invalid property data');
-    }
-    
-    $validatedName = $propertyData['name'];
-    $validatedValue = $propertyData['value'];
-
-    // Deactivate existing properties
-    if ($entityType === 'page') {
-        $deactivateStmt = $pdo->prepare("UPDATE Properties SET active = 0 WHERE page_id = ? AND name = ?");
-    } else { // 'note'
-        $deactivateStmt = $pdo->prepare("UPDATE Properties SET active = 0 WHERE note_id = ? AND name = ?");
-    }
-    $deactivateStmt->execute([$entityId, $validatedName]);
-    
-    // Check property definitions to determine internal status
-    // $explicitInternal will typically come from property definition applications
-    $finalInternal = determinePropertyInternalStatus($pdo, $validatedName, $explicitInternal);
-    
-    if ($entityType === 'page') {
-        $stmt = $pdo->prepare("
-            REPLACE INTO Properties (page_id, note_id, name, value, internal, active)
-            VALUES (?, NULL, ?, ?, ?, 1)
-        ");
-        $stmt->execute([$entityId, $validatedName, $validatedValue, $finalInternal]);
-    } else { // 'note'
-        // Try to update existing property first
-        $updateStmt = $pdo->prepare("
-            UPDATE Properties 
-            SET value = ?, internal = ?, active = 1, updated_at = CURRENT_TIMESTAMP 
-            WHERE note_id = ? AND name = ?
-        ");
-        $updateStmt->execute([$validatedValue, $finalInternal, $entityId, $validatedName]);
-        
-        // If no rows were affected, insert a new one
-        if ($updateStmt->rowCount() === 0) {
-            $insertStmt = $pdo->prepare("
-                INSERT INTO Properties (note_id, page_id, name, value, internal, active)
-                VALUES (?, NULL, ?, ?, ?, 1)
-            ");
-            $insertStmt->execute([$entityId, $validatedName, $validatedValue, $finalInternal]);
-        }
-    }
-    
-    // Dispatch triggers using the service
-    $triggerService = new PropertyTriggerService($pdo);
-    $triggerService->dispatch($entityType, $entityId, $validatedName, $validatedValue);
-    
-    return ['name' => $validatedName, 'value' => $validatedValue, 'internal' => $finalInternal];
-    }
-}
-
+// This script's public-facing part now only handles GET requests.
+// All write operations are driven by content updates in the notes/pages endpoints.
 if (basename(__FILE__) === basename($_SERVER['SCRIPT_FILENAME'])) {
-    // GET /api/properties.php?entity_type=note&entity_id=123
+    
+    // GET /api/v1/properties.php?entity_type=note&entity_id=123
     if ($_SERVER['REQUEST_METHOD'] === 'GET') {
         $validationRules = [
             'entity_type' => 'required|isValidEntityType',
             'entity_id' => 'required|isPositiveInteger'
-            // include_internal is boolean, filter_input is fine
+            // 'include_hidden' is the new parameter, replacing 'include_internal'
         ];
         $errors = Validator::validate($_GET, $validationRules);
         if (!empty($errors)) {
@@ -130,14 +37,14 @@ if (basename(__FILE__) === basename($_SERVER['SCRIPT_FILENAME'])) {
             exit;
         }
 
-        $entityType = $_GET['entity_type']; // Validated
-        $entityId = (int)$_GET['entity_id']; // Validated
-        $includeInternal = filter_input(INPUT_GET, 'include_internal', FILTER_VALIDATE_BOOLEAN);
+        $entityType = $_GET['entity_type'];
+        $entityId = (int)$_GET['entity_id'];
+        // Use 'include_hidden' to control visibility of properties based on config.
+        $includeHidden = filter_input(INPUT_GET, 'include_hidden', FILTER_VALIDATE_BOOLEAN);
 
         try {
             $pdo = get_db_connection();
             
-            // Check if entity exists
             if (!checkEntityExists($pdo, $entityType, $entityId)) {
                 ApiResponse::error($entityType === 'note' ? 'Note not found' : 'Page not found', 404);
                 exit;
@@ -147,265 +54,23 @@ if (basename(__FILE__) === basename($_SERVER['SCRIPT_FILENAME'])) {
             $properties = null;
 
             if ($entityType === 'note') {
-                $properties = $dataManager->getNoteProperties($entityId, $includeInternal);
+                $properties = $dataManager->getNoteProperties($entityId, $includeHidden);
             } elseif ($entityType === 'page') {
-                $properties = $dataManager->getPageProperties($entityId, $includeInternal);
-            }
-
-            // Standardize property format
-            $standardizedProperties = [];
-            foreach ($properties as $name => $values) {
-                if (!is_array($values)) {
-                    $values = [$values];
-                }
-                $standardizedProperties[$name] = array_map(function($value) {
-                    return is_array($value) ? $value : ['value' => $value, 'internal' => 0];
-                }, $values);
-            }
-            
-            ApiResponse::success($standardizedProperties);
-            
-        } catch (Exception $e) {
-            ApiResponse::error('Server error: ' . $e->getMessage(), 500);
-        }
-    }
-
-    // POST /api/properties.php
-    if ($_SERVER['REQUEST_METHOD'] === 'POST') {
-        $input = json_decode(file_get_contents('php://input'), true);
-        if (!$input) {
-            ApiResponse::error('Invalid JSON', 400);
-            exit;
-        }
-        
-        // Check if this is a delete action
-        if (isset($input['action'])) {
-            if ($input['action'] === 'delete') {
-                $validationRules = [
-                    'entity_type' => 'required|isValidEntityType',
-                    'entity_id' => 'required|isPositiveInteger',
-                    'name' => 'required|isNotEmpty'
-                ];
-                $errors = Validator::validate($input, $validationRules);
-                if (!empty($errors)) {
-                    ApiResponse::error('Invalid input for deleting property.', 400, $errors);
-                    exit;
-                }
-                
-                $entityType = $input['entity_type']; // Validated
-                $entityId = (int)$input['entity_id']; // Validated
-                $name = $input['name']; // Validated
-                
-                try {
-                    $pdo = get_db_connection();
-                    
-                    // Check if entity exists
-                    if (!checkEntityExists($pdo, $entityType, $entityId)) {
-                        ApiResponse::error($entityType === 'note' ? 'Note not found' : 'Page not found', 404);
-                        exit;
-                    }
-
-                    if ($entityType === 'page') {
-                        $stmt = $pdo->prepare("DELETE FROM Properties WHERE page_id = ? AND note_id IS NULL AND name = ?");
-                    } else { // 'note'
-                        $stmt = $pdo->prepare("DELETE FROM Properties WHERE note_id = ? AND page_id IS NULL AND name = ?");
-                    }
-                    $stmt->execute([$entityId, $name]);
-                    
-                    ApiResponse::success(null, 200);
-                    
-                } catch (Exception $e) {
-                    ApiResponse::error('Server error: ' . $e->getMessage(), 500);
-                }
-                exit;
-            } elseif ($input['action'] === 'set_internal_status') {
-                $validationRules = [
-                    'entity_type' => 'required|isValidEntityType',
-                    'entity_id' => 'required|isPositiveInteger',
-                    'name' => 'required|isNotEmpty',
-                    'internal' => 'required|isBooleanLike'
-                ];
-                $errors = Validator::validate($input, $validationRules);
-                if (!empty($errors)) {
-                    ApiResponse::error('Invalid input for setting internal status.', 400, $errors);
-                    exit;
-                }
-
-                $entityType = $input['entity_type']; // Validated
-                $entityId = (int)$input['entity_id']; // Validated
-                $name = $input['name']; // Validated
-                $internalFlag = (int)$input['internal']; // Validated
-
-                if ($internalFlag !== 0 && $internalFlag !== 1) {
-                    ApiResponse::error('Invalid internal flag value. Must be 0 or 1.', 400);
-                    exit;
-                }
-
-                try {
-                    $pdo = get_db_connection();
-                    
-                    // Check if entity exists
-                    if (!checkEntityExists($pdo, $entityType, $entityId)) {
-                        ApiResponse::error($entityType === 'note' ? 'Note not found' : 'Page not found', 404);
-                        exit;
-                    }
-
-                    $idColumn = ($entityType === 'page') ? 'page_id' : 'note_id';
-
-                    // Check if property exists
-                    $stmtCheck = $pdo->prepare("SELECT id FROM Properties WHERE {$idColumn} = ? AND name = ?");
-                    $stmtCheck->execute([$entityId, $name]);
-                    if (!$stmtCheck->fetch()) {
-                        ApiResponse::error('Property not found. Cannot set internal status for a non-existent property.', 404);
-                        exit;
-                    }
-
-                    // Update internal status
-                    $stmt = $pdo->prepare("UPDATE Properties SET internal = ? WHERE {$idColumn} = ? AND name = ?");
-                    $success = $stmt->execute([$internalFlag, $entityId, $name]);
-
-                    if ($success) {
-                        // Get property value for trigger dispatch
-                        $stmtGetValue = $pdo->prepare("SELECT value FROM Properties WHERE {$idColumn} = ? AND name = ?");
-                        $stmtGetValue->execute([$entityId, $name]);
-                        $propertyRow = $stmtGetValue->fetch(PDO::FETCH_ASSOC);
-
-                        if ($propertyRow) {
-                            $triggerService = new PropertyTriggerService($pdo);
-                            $triggerService->dispatch($entityType, $entityId, $name, $propertyRow['value']);
-                        } else {
-                            error_log("Could not retrieve property value after updating internal status for {$name} on {$entityType} {$entityId}");
-                        }
-
-                        ApiResponse::success(['message' => 'Property internal status updated.']);
-                    } else {
-                        ApiResponse::error('Failed to update property internal status', 500);
-                    }
-                } catch (Exception $e) {
-                    ApiResponse::error('Server error: ' . $e->getMessage(), 500);
-                }
-                exit;
-            }
-        }
-        
-        // Handle regular property creation/update
-        $validationRules = [
-            'entity_type' => 'required|isValidEntityType',
-            'entity_id' => 'required|isPositiveInteger',
-            'name' => 'required|isNotEmpty',
-            'value' => 'required',
-            'internal' => 'optional|isBooleanLike'
-        ];
-        $errors = Validator::validate($input, $validationRules);
-        if (!empty($errors)) {
-            ApiResponse::error('Invalid input for creating/updating property.', 400, $errors);
-            exit;
-        }
-
-        $entityType = $input['entity_type']; // Validated
-        $entityId = (int)$input['entity_id']; // Validated
-        $name = $input['name']; // Validated
-        $value = $input['value']; // Validated (presence)
-        $explicitInternal = isset($input['internal']) ? (int)$input['internal'] : null;
-
-        // The specific validate_property_data function can still be used for its tag normalization logic
-        $normalizedPropertyData = validate_property_data(['name' => $name, 'value' => $value]);
-        if (!$normalizedPropertyData) {
-            ApiResponse::error('Invalid property format (e.g., tag:: without tag name).', 400);
-            exit;
-        }
-        $name = $normalizedPropertyData['name'];
-        $value = $normalizedPropertyData['value'];
-
-        try {
-            $pdo = get_db_connection();
-            
-            // Check if entity exists
-            if (!checkEntityExists($pdo, $entityType, $entityId)) {
-                ApiResponse::error($entityType === 'note' ? 'Note not found' : 'Page not found', 404);
-                exit;
+                $properties = $dataManager->getPageProperties($entityId, $includeHidden);
             }
 
-            $pdo->beginTransaction();
+            // The DataManager now returns the properties in the correct final format
+            // as specified by the API. No further standardization is needed here.
             
-            $savedProperty = _updateOrAddPropertyAndDispatchTriggers(
-                $pdo,
-                $entityType,
-                $entityId,
-                $name,
-                $value,
-                $explicitInternal 
-            );
-
-            if ($entityType === 'note') {
-                // Fetch note content
-                $stmtNote = $pdo->prepare("SELECT content FROM Notes WHERE id = ?");
-                $stmtNote->execute([$entityId]);
-                $note = $stmtNote->fetch(PDO::FETCH_ASSOC);
-
-                if ($note) {
-                    $currentContent = $note['content'] ?: ''; // Handle null content
-                    
-                    // Determine property format from the saved property data
-                    $propertyName = $savedProperty['name'];
-                    $propertyValue = $savedProperty['value'];
-                    $isInternal = (bool)$savedProperty['internal'];
-                    
-                    // Construct the new property string. Always prepend with a newline for consistency.
-                    $propertyString = "\n{" . $propertyName . ($isInternal ? ':::' : '::') . $propertyValue . "}";
-                    
-                    // Escape property name for use in regex.
-                    $escapedName = preg_quote($propertyName, '/');
-                    // Regex to find an existing property string, matching either ::: or :: separators.
-                    // The 's' modifier allows '.' to match newlines, in case property values contain them.
-                    $pattern = "/\n?\{" . $escapedName . "(?:::|::).*?\}/s";
-                    
-                    $count = 0;
-                    // Try to replace the first occurrence of the property.
-                    $newContent = preg_replace($pattern, $propertyString, $currentContent, 1, $count);
-                    
-                    // If the property was not found and replaced, append the new property string.
-                    if ($count === 0) {
-                        // Use rtrim to avoid piling up newlines if content already ends with one.
-                        $newContent = rtrim($currentContent) . $propertyString;
-                    }
-                    
-                    // Only execute DB update if the content has actually changed to avoid unnecessary writes.
-                    if ($newContent !== $currentContent) {
-                        $updateNoteStmt = $pdo->prepare("UPDATE Notes SET content = ? WHERE id = ?");
-                        $updateNoteStmt->execute([$newContent, $entityId]);
-                    }
-                } else {
-                    // This case should ideally not happen if checkEntityExists passed earlier
-                    // but as a safeguard, we can log it.
-                    error_log("Note with ID {$entityId} not found when trying to append property to content.");
-                    // Optionally, throw an exception to rollback if this is critical
-                    // throw new Exception("Note not found, cannot append property to content.");
-                }
-            }
-            
-            $pdo->commit();
-            
-            // Standardize the response format
-            $response = [
-                'property' => [
-                    'name' => $savedProperty['name'],
-                    'value' => $savedProperty['value'],
-                    'internal' => (int)$savedProperty['internal']
-                ]
-            ];
-            
-            ApiResponse::success($response);
+            ApiResponse::success($properties);
             
         } catch (Exception $e) {
-            if ($pdo->inTransaction()) {
-                $pdo->rollBack();
-            }
             ApiResponse::error('Server error: ' . $e->getMessage(), 500);
         }
         exit;
     }
 
-    // Method not allowed (if not GET or POST)
-    ApiResponse::error('Method not allowed', 405);
+    // POST, PUT, DELETE methods are not supported on this endpoint.
+    // Write operations are now indirect, triggered by updating Note/Page content.
+    ApiResponse::error('Method not allowed. This is a read-only endpoint.', 405);
 }
\ No newline at end of file
diff --git a/api/v1/query_notes.php b/api/v1/query_notes.php
index 4b3f12a..c95effd 100644
--- a/api/v1/query_notes.php
+++ b/api/v1/query_notes.php
@@ -1,62 +1,26 @@
 <?php
 /**
  * Query Notes API - Enhanced to support property-based queries
- * 
- * This API allows executing safe, predefined SQL queries to find notes by various criteria.
- * 
- * Allowed Query Patterns:
- * 1. Direct Notes table queries:
- *    SELECT id FROM Notes WHERE [conditions]
- *    
- * 2. Notes with Properties JOIN:
- *    SELECT [DISTINCT] N.id FROM Notes N JOIN Properties P ON N.id = P.note_id WHERE [conditions]
- *    
- * 3. Notes with Properties subquery:
- *    SELECT id FROM Notes WHERE id IN (SELECT note_id FROM Properties WHERE [conditions])
- *    
- * Example Usage:
- * - Find notes with a specific property: 
- *   SELECT DISTINCT N.id FROM Notes N JOIN Properties P ON N.id = P.note_id WHERE P.name = 'status' AND P.value = 'TODO'
- *   
- * - Find notes with any property starting with 'tag::':
- *   SELECT id FROM Notes WHERE id IN (SELECT note_id FROM Properties WHERE name LIKE 'tag::%')
- *   
- * - Find notes on a specific page with properties:
- *   SELECT DISTINCT N.id FROM Notes N JOIN Properties P ON N.id = P.note_id WHERE N.page_id = 1 AND P.name = 'priority'
- *   
- * Security: Only SELECT queries are allowed, limited to Notes, Properties, and Pages tables.
+ * This API allows executing safe, predefined SQL queries to find notes.
  */
 require_once __DIR__ . '/../../config.php';
 require_once __DIR__ . '/../db_connect.php';
-require_once __DIR__ . '/../response_utils.php'; // Include the new response utility
-
-// header('Content-Type: application/json'); // Will be handled by ApiResponse
+require_once __DIR__ . '/../response_utils.php';
+require_once __DIR__ . '/../data_manager.php';
 
 $pdo = get_db_connection();
 $input = json_decode(file_get_contents('php://input'), true);
 
-// Validate required and optional parameters
 if (!isset($input['sql_query'])) {
     ApiResponse::error('Missing sql_query parameter.', 400);
-    exit;
 }
 
-// Set default pagination values
-$page = isset($input['page']) ? max(1, intval($input['page'])) : 1;
-$perPage = isset($input['per_page']) ? max(1, min(100, intval($input['per_page']))) : 20;
-$includeProperties = isset($input['include_properties']) ? (bool)$input['include_properties'] : false;
-
-$sqlQuery = trim($input['sql_query']);
-
 // --- SQL Validation ---
-
-// Security Check 1: Basic Structure
-// Allow multiple query patterns for Notes and Properties
+$sqlQuery = trim($input['sql_query']);
 $allowedPatterns = [
-    '/^SELECT\s+id\s+FROM\s+Notes\s+WHERE\s+/i',  // Original pattern
-    '/^SELECT\s+DISTINCT\s+N\.id\s+FROM\s+Notes\s+N\s+JOIN\s+Properties\s+P\s+ON\s+N\.id\s*=\s*P\.note_id\s+WHERE\s+/i', // JOIN with Properties
-    '/^SELECT\s+N\.id\s+FROM\s+Notes\s+N\s+JOIN\s+Properties\s+P\s+ON\s+N\.id\s*=\s*P\.note_id\s+WHERE\s+/i', // JOIN without DISTINCT
-    '/^SELECT\s+id\s+FROM\s+Notes\s+WHERE\s+id\s+IN\s*\(\s*SELECT\s+note_id\s+FROM\s+Properties\s+WHERE\s+/i' // Subquery pattern
+    '/^SELECT\s+id\s+FROM\s+Notes\s+WHERE\s+/i',
+    '/^SELECT\s+(DISTINCT\s+)?N\.id\s+FROM\s+Notes\s+N\s+JOIN\s+Properties\s+P\s+ON\s+N\.id\s*=\s*P\.note_id\s+WHERE\s+/i',
+    '/^SELECT\s+id\s+FROM\s+Notes\s+WHERE\s+id\s+IN\s*\(\s*SELECT\s+note_id\s+FROM\s+Properties\s+WHERE\s+/i'
 ];
 
 $patternMatched = false;
@@ -68,148 +32,86 @@ foreach ($allowedPatterns as $pattern) {
 }
 
 if (!$patternMatched) {
-    ApiResponse::error('Query must be one of the allowed patterns: SELECT id FROM Notes WHERE..., SELECT [DISTINCT] N.id FROM Notes N JOIN Properties P ON N.id = P.note_id WHERE..., or SELECT id FROM Notes WHERE id IN (SELECT note_id FROM Properties WHERE...). Invalid query: ' . substr($sqlQuery, 0, 100), 400);
-    exit;
+    ApiResponse::error('Query must be one of the allowed patterns.', 400);
 }
 
-// Security Check 2: Forbidden Keywords/Characters
-$forbiddenKeywords = [
-    'INSERT', 'UPDATE', 'DELETE', 'DROP', 'TRUNCATE', 'ALTER', 'EXEC', 
-    'CREATE', 'UNION', 'ATTACH', 'DETACH', 'HANDLER', 'CALL', 'LOCK', 'REPLACE'
-    // Leaving out 'SELECT' from this list as it's part of the allowed prefix, but context is important.
-    // 'INTO', 'VALUES' might be part of subqueries or specific functions, but for now, let's be strict.
-];
-// Also check for '--' and '/*' to prevent comments that could hide malicious code
-$forbiddenPatterns = [
-    '/\b(' . implode('|', $forbiddenKeywords) . ')\b/i', // Whole word match for keywords
-    '/--/', // SQL comment
-    '/\/\*/', // SQL block comment start
-    '/\*\//'  // SQL block comment end
-];
-
-// Check for semicolons not at the very end of the query
-if (strpos($sqlQuery, ';') !== false && strpos($sqlQuery, ';') !== strlen($sqlQuery) - 1) {
-    ApiResponse::error('Semicolons are only allowed at the very end of the query.', 400);
-    exit;
-}
-// Remove trailing semicolon if present, for consistency before further checks
-if (substr($sqlQuery, -1) === ';') {
-    $sqlQuery = substr($sqlQuery, 0, -1);
+if (strpos($sqlQuery, ';') !== false) {
+    ApiResponse::error('Query must not contain semicolons.', 400);
 }
 
-foreach ($forbiddenPatterns as $pattern) {
-    if (preg_match($pattern, $sqlQuery)) {
-        ApiResponse::error('Query contains forbidden SQL keywords/characters or comments. Pattern: ' . $pattern, 400);
-        exit;
+$forbiddenKeywords = ['INSERT', 'UPDATE', 'DELETE', 'DROP', 'TRUNCATE', 'ALTER', 'EXEC', 'CREATE', 'ATTACH', 'DETACH'];
+foreach ($forbiddenKeywords as $keyword) {
+    if (preg_match('/\b' . $keyword . '\b/i', $sqlQuery)) {
+        ApiResponse::error('Query contains forbidden SQL keywords.', 400);
     }
 }
 
-// Security Check 3: Table/Column Validation
-// Ensure only allowed tables and columns are referenced
-$allowedTables = ['Notes', 'Properties', 'Pages'];
-$allowedNotesColumns = ['id', 'content', 'page_id', 'parent_note_id', 'created_at', 'updated_at', 'order_index', 'collapsed', 'internal', 'active'];
-$allowedPropertiesColumns = ['note_id', 'page_id', 'name', 'value', 'internal', 'active', 'created_at', 'updated_at'];
-$allowedPagesColumns = ['id', 'name', 'alias', 'active', 'created_at', 'updated_at'];
-
-// Basic table reference validation (prevent access to unauthorized tables)
-// This regex looks for table names that are not in our allowed list
-if (preg_match('/\bFROM\s+(?!(?:Notes|Properties|Pages)\b)\w+/i', $sqlQuery) ||
-    preg_match('/\bJOIN\s+(?!(?:Notes|Properties|Pages)\b)\w+/i', $sqlQuery)) {
-    ApiResponse::error('Query references unauthorized tables. Only Notes, Properties, and Pages are allowed.', 400);
-    exit;
+// Check for allowed columns to prevent data leakage from other columns.
+// This is a simple text-based check and not a full AST parser, but provides a good layer of security.
+$allowedColumnsRegex = '/\b(N|P|Notes|Properties)\.(id|content|page_id|parent_note_id|created_at|updated_at|order_index|collapsed|active|note_id|name|value|weight)\b/i';
+$strippedQuery = preg_replace($allowedColumnsRegex, '', $sqlQuery);
+if (preg_match('/(N|P|Notes|Properties)\.\w+/', $strippedQuery)) {
+     ApiResponse::error('Query references unauthorized columns.', 400);
 }
 
+
 // --- Query Execution ---
 try {
-    // Step 1: Execute the provided query to get total count and paginated note IDs
-    // First, get total count by wrapping the original query
-    $countQuery = "SELECT COUNT(*) FROM (" . $sqlQuery . ") as count_query";
-    $stmtCount = $pdo->prepare($countQuery);
-    $stmtCount->execute();
-    $totalCount = (int)$stmtCount->fetchColumn();
-
-    // Calculate pagination
-    $totalPages = ceil($totalCount / $perPage);
+    $page = max(1, intval($input['page'] ?? 1));
+    $perPage = max(1, min(100, intval($input['per_page'] ?? 20)));
+    $includeProperties = (bool)($input['include_properties'] ?? true);
     $offset = ($page - 1) * $perPage;
 
-    // Modify the original query to include LIMIT and OFFSET
-    // We need to handle different query patterns
-    if (preg_match('/^SELECT\s+DISTINCT\s+N\.id\s+FROM\s+Notes\s+N\s+JOIN/i', $sqlQuery)) {
-        // For JOIN queries, we need to wrap in a subquery to apply pagination
-        $sqlQuery = "SELECT id FROM (" . $sqlQuery . ") as paginated_query LIMIT ? OFFSET ?";
-    } else {
-        // For simple queries, we can just append LIMIT and OFFSET
-        $sqlQuery .= " LIMIT ? OFFSET ?";
-    }
+    // Get total count by wrapping the user's query
+    $countQuery = "SELECT COUNT(*) FROM (" . $sqlQuery . ") as count_query";
+    $totalCount = (int)$pdo->query($countQuery)->fetchColumn();
+    $totalPages = ceil($totalCount / $perPage);
 
-    $stmtGetIds = $pdo->prepare($sqlQuery);
+    // Get the paginated list of note IDs
+    $paginatedQuery = $sqlQuery . " LIMIT ? OFFSET ?";
+    $stmtGetIds = $pdo->prepare($paginatedQuery);
     $stmtGetIds->execute([$perPage, $offset]);
     $noteIds = $stmtGetIds->fetchAll(PDO::FETCH_COLUMN, 0);
 
     if (empty($noteIds)) {
-        ApiResponse::success([
-            'data' => [],
-            'pagination' => [
-                'current_page' => $page,
-                'per_page' => $perPage,
-                'total_count' => $totalCount,
-                'total_pages' => $totalPages
-            ]
-        ]);
+        ApiResponse::success(
+            [], 200, ['pagination' => ['current_page' => $page, 'per_page' => $perPage, 'total_items' => $totalCount, 'total_pages' => $totalPages]]
+        );
         exit;
     }
 
-    // Step 2: Fetch full note data for the retrieved IDs
+    // Fetch full note data for the retrieved IDs
     $placeholders = implode(',', array_fill(0, count($noteIds), '?'));
     $sqlFetchNotes = "SELECT * FROM Notes WHERE id IN ({$placeholders})";
-    
     $stmtFetchNotes = $pdo->prepare($sqlFetchNotes);
     $stmtFetchNotes->execute($noteIds);
     $notes = $stmtFetchNotes->fetchAll(PDO::FETCH_ASSOC);
 
-    // Step 3: If properties are requested, fetch them for all notes
+    // If properties are requested, fetch and format them using the DataManager
     if ($includeProperties && !empty($notes)) {
-        $sqlFetchProperties = "SELECT * FROM Properties WHERE note_id IN ({$placeholders})";
-        $stmtFetchProperties = $pdo->prepare($sqlFetchProperties);
-        $stmtFetchProperties->execute($noteIds);
-        $properties = $stmtFetchProperties->fetchAll(PDO::FETCH_ASSOC);
-
-        // Group properties by note_id
-        $propertiesByNoteId = [];
-        foreach ($properties as $property) {
-            $noteId = $property['note_id'];
-            if (!isset($propertiesByNoteId[$noteId])) {
-                $propertiesByNoteId[$noteId] = [];
-            }
-            $propertiesByNoteId[$noteId][] = $property;
-        }
+        $dataManager = new DataManager($pdo);
+        // Pass 'true' to include properties that are normally hidden in view mode
+        $propertiesByNoteId = $dataManager->getPropertiesForNoteIds($noteIds, true);
 
-        // Attach properties to their respective notes
         foreach ($notes as &$note) {
             $note['properties'] = $propertiesByNoteId[$note['id']] ?? [];
         }
     }
 
-    ApiResponse::success([
-        'data' => $notes,
-        'pagination' => [
-            'current_page' => $page,
-            'per_page' => $perPage,
-            'total_count' => $totalCount,
-            'total_pages' => $totalPages
+    ApiResponse::success(
+        $notes,
+        200,
+        [
+            'pagination' => [
+                'current_page' => $page,
+                'per_page' => $perPage,
+                'total_items' => $totalCount,
+                'total_pages' => $totalPages
+            ]
         ]
-    ]);
+    );
 
 } catch (PDOException $e) {
-    // Log the detailed error to server logs for debugging
-    error_log("Database error in query_notes.php: " . $e->getMessage());
-    error_log("Offending SQL (potentially): " . $sqlQuery);
-
-    // Provide a generic error message to the client
-    ApiResponse::error('A database error occurred.', 500);
-} catch (Exception $e) {
-    error_log("General error in query_notes.php: " . $e->getMessage());
-    ApiResponse::error('An unexpected error occurred.', 500);
-}
-
-?>
+    error_log("Database error in query_notes.php: " . $e->getMessage() . " SQL: " . $sqlQuery);
+    ApiResponse::error('A database error occurred during query execution.', 500);
+}
\ No newline at end of file
diff --git a/api/v1/search.php b/api/v1/search.php
index d596b09..8e1cdd4 100644
--- a/api/v1/search.php
+++ b/api/v1/search.php
@@ -1,260 +1,111 @@
 <?php
 require_once __DIR__ . '/../db_connect.php';
-require_once __DIR__ . '/../response_utils.php'; // Include the new response utility
-require_once __DIR__ . '/../data_manager.php';   // Include the new DataManager
+require_once __DIR__ . '/../response_utils.php';
+require_once __DIR__ . '/../data_manager.php';
 
-// header('Content-Type: application/json'); // Will be handled by ApiResponse
 $pdo = get_db_connection();
-$dataManager = new DataManager($pdo); // Instantiate DataManager
+$dataManager = new DataManager($pdo);
 $method = $_SERVER['REQUEST_METHOD'];
 
-// Helper function to get content snippet with context
 function get_content_snippet($content, $term, $context_length = 100) {
     $term_pos = stripos($content, $term);
-    if ($term_pos === false) {
-        return substr($content, 0, $context_length) . '...';
-    }
-
-    $start = max(0, $term_pos - $context_length / 2);
+    if ($term_pos === false) return substr($content, 0, $context_length) . (strlen($content) > $context_length ? '...' : '');
+    $start = max(0, $term_pos - ($context_length / 2));
     $snippet = substr($content, $start, $context_length);
-    
-    if ($start > 0) {
-        $snippet = '...' . $snippet;
-    }
-    if ($start + $context_length < strlen($content)) {
-        $snippet .= '...';
-    }
-    
+    if ($start > 0) $snippet = '...' . $snippet;
+    if (($start + $context_length) < strlen($content)) $snippet .= '...';
     return $snippet;
 }
 
-// Helper function to sanitize search term for FTS5
 function sanitize_fts_term($term) {
-    // Remove special FTS5 characters and escape quotes
-    $term = str_replace(['"', "'", '(', ')', '[', ']', '{', '}', ':', ';', '!', '@', '#', '$', '%', '^', '&', '*', '+', '=', '|', '\\', '/', '<', '>', '?', '~', '`'], ' ', $term);
-    // Trim and collapse whitespace
-    $term = preg_replace('/\s+/', ' ', trim($term));
-    return $term;
+    $term = preg_replace('/[^\p{L}\p{N}\s\-_*]/u', ' ', $term);
+    return trim(preg_replace('/\s+/', ' ', $term));
 }
 
-// Helper function to get pagination parameters with defaults
 function get_pagination_params() {
-    $page = isset($_GET['page']) ? max(1, intval($_GET['page'])) : 1;
-    $per_page = isset($_GET['per_page']) ? max(1, min(100, intval($_GET['per_page']))) : 20;
+    $page = max(1, intval($_GET['page'] ?? 1));
+    $per_page = max(1, min(100, intval($_GET['per_page'] ?? 20)));
     $offset = ($page - 1) * $per_page;
     return [$page, $per_page, $offset];
 }
 
+function attach_properties_to_results($dataManager, &$results) {
+    $noteIds = array_column($results, 'note_id');
+    if (empty($noteIds)) return;
+
+    $propertiesByNoteId = $dataManager->getPropertiesForNoteIds($noteIds, true);
+    foreach ($results as &$result) {
+        $result['properties'] = $propertiesByNoteId[$result['note_id']] ?? [];
+    }
+}
+
 if ($method === 'GET') {
     try {
-        // Get pagination parameters
         [$page, $per_page, $offset] = get_pagination_params();
+        $total = 0;
+        $results = [];
 
         if (isset($_GET['q'])) {
-            // Full-text search
             $term = sanitize_fts_term($_GET['q']);
             if (empty($term)) {
-                ApiResponse::success(['results' => [], 'pagination' => ['total' => 0, 'page' => $page, 'per_page' => $per_page, 'total_pages' => 0]]);
-                exit;
-            }
-
-            // Check if FTS5 is available
-            $fts_check = $pdo->query("SELECT name FROM sqlite_master WHERE type='table' AND name='Notes_fts'")->fetch();
-            
-            if ($fts_check) {
-                // Get total count for FTS5
-                $count_stmt = $pdo->prepare("
-                    SELECT COUNT(*) as total
-                    FROM Notes N 
-                    JOIN Notes_fts FTS ON N.id = FTS.rowid 
-                    WHERE Notes_fts MATCH ?
-                ");
-                $count_stmt->execute([$term]);
-                $total = $count_stmt->fetch()['total'];
-
-                // Use FTS5 for better performance with pagination
-                $stmt = $pdo->prepare("
-                    SELECT 
-                        N.id as note_id,
-                        N.content,
-                        N.page_id,
-                        P.name as page_name,
-                        snippet(Notes_fts, 0, '<mark>', '</mark>', '...', 64) as content_snippet
-                    FROM Notes N 
-                    JOIN Pages P ON N.page_id = P.id 
-                    JOIN Notes_fts FTS ON N.id = FTS.rowid 
-                    WHERE Notes_fts MATCH ?
-                    ORDER BY rank
-                    LIMIT ? OFFSET ?
-                ");
-                $stmt->execute([$term, $per_page, $offset]);
-            } else {
-                // Get total count for LIKE search
-                $count_stmt = $pdo->prepare("
-                    SELECT COUNT(*) as total
-                    FROM Notes N 
-                    JOIN Pages P ON N.page_id = P.id 
-                    WHERE N.content LIKE ? OR P.name LIKE ?
-                ");
-                $like_term = '%' . str_replace('%', '\\%', $term) . '%';
-                $count_stmt->execute([$like_term, $like_term]);
-                $total = $count_stmt->fetch()['total'];
-
-                // Fallback to LIKE search with pagination
-                $stmt = $pdo->prepare("
-                    SELECT 
-                        N.id as note_id,
-                        N.content,
-                        N.page_id,
-                        P.name as page_name
-                    FROM Notes N 
-                    JOIN Pages P ON N.page_id = P.id 
-                    WHERE N.content LIKE ? OR P.name LIKE ?
-                    LIMIT ? OFFSET ?
-                ");
-                $stmt->execute([$like_term, $like_term, $per_page, $offset]);
+                ApiResponse::error('Search term is required.', 400);
             }
+            $count_stmt = $pdo->prepare("SELECT COUNT(*) FROM Notes_fts WHERE Notes_fts MATCH ?");
+            $count_stmt->execute([$term]);
+            $total = (int)$count_stmt->fetchColumn();
 
+            $stmt = $pdo->prepare("SELECT N.id as note_id, N.content, N.page_id, P.name as page_name, snippet(Notes_fts, 2, '<mark>', '</mark>', '...', 64) as content_snippet FROM Notes N JOIN Pages P ON N.page_id = P.id JOIN Notes_fts FTS ON N.id = FTS.rowid WHERE Notes_fts MATCH ? ORDER BY rank LIMIT ? OFFSET ?");
+            $stmt->execute([$term, $per_page, $offset]);
             $results = $stmt->fetchAll();
-            
-            // If using LIKE search, generate snippets manually
-            if (!$fts_check) {
-                foreach ($results as &$result) {
-                    $result['content_snippet'] = get_content_snippet($result['content'], $term);
-                }
-            }
-
-            $total_pages = ceil($total / $per_page);
-            ApiResponse::success([
-                'results' => $results,
-                'pagination' => [
-                    'total' => $total,
-                    'page' => $page,
-                    'per_page' => $per_page,
-                    'total_pages' => $total_pages
-                ]
-            ]);
 
         } elseif (isset($_GET['backlinks_for_page_name'])) {
-            // Backlink search using 'links_to_page' properties
             $target_page_name = trim($_GET['backlinks_for_page_name']);
-            if (empty($target_page_name)) {
-                ApiResponse::success(['results' => [], 'pagination' => ['total' => 0, 'page' => $page, 'per_page' => $per_page, 'total_pages' => 0]]);
-                exit;
-            }
+            if (empty($target_page_name)) ApiResponse::error('Target page name is required.', 400);
 
-            // Get total count for backlinks
-            $count_stmt = $pdo->prepare("
-                SELECT COUNT(*) as total
-                FROM Properties Prop
-                JOIN Notes N ON Prop.note_id = N.id
-                WHERE Prop.name = 'links_to_page' AND Prop.value = ? AND Prop.note_id IS NOT NULL
-            ");
+            $count_stmt = $pdo->prepare("SELECT COUNT(DISTINCT N.id) FROM Properties Prop JOIN Notes N ON Prop.note_id = N.id WHERE Prop.name = 'links_to_page' AND Prop.value = ?");
             $count_stmt->execute([$target_page_name]);
-            $total = $count_stmt->fetch()['total'];
+            $total = (int)$count_stmt->fetchColumn();
 
-            $stmt = $pdo->prepare("
-                SELECT 
-                    N.id as note_id,
-                    N.content,
-                    N.page_id,
-                    P.name as source_page_name
-                FROM Properties Prop
-                JOIN Notes N ON Prop.note_id = N.id
-                JOIN Pages P ON N.page_id = P.id
-                WHERE Prop.name = 'links_to_page' AND Prop.value = ? AND Prop.note_id IS NOT NULL
-                ORDER BY N.updated_at DESC
-                LIMIT ? OFFSET ?
-            ");
-            
+            $stmt = $pdo->prepare("SELECT N.id as note_id, N.content, N.page_id, P.name as page_name FROM Properties Prop JOIN Notes N ON Prop.note_id = N.id JOIN Pages P ON N.page_id = P.id WHERE Prop.name = 'links_to_page' AND Prop.value = ? GROUP BY N.id ORDER BY N.updated_at DESC LIMIT ? OFFSET ?");
             $stmt->execute([$target_page_name, $per_page, $offset]);
             $results = $stmt->fetchAll();
-
-            foreach ($results as &$result) {
-                $result['content_snippet'] = get_content_snippet($result['content'], '[[' . $target_page_name . ']]');
-            }
-            unset($result);
-
-            $total_pages = ceil($total / $per_page);
-            ApiResponse::success([
-                'results' => $results,
-                'pagination' => [
-                    'total' => $total,
-                    'page' => $page,
-                    'per_page' => $per_page,
-                    'total_pages' => $total_pages
-                ]
-            ]);
+            foreach ($results as &$result) $result['content_snippet'] = get_content_snippet($result['content'], '[[' . $target_page_name . ']]');
 
         } elseif (isset($_GET['tasks'])) {
-            // Task search
-            $status_filter = strtolower($_GET['tasks']);
-            if (!in_array($status_filter, ['todo', 'done'])) {
-                ApiResponse::error('Invalid task status. Use "todo" or "done"', 400);
-                exit;
-            }
+            $status = strtoupper(trim($_GET['tasks']));
+            if (!in_array($status, ['TODO', 'DONE'])) ApiResponse::error('Invalid task status. Use "todo" or "done"', 400);
 
-            $property_value = $status_filter === 'todo' ? 'TODO' : 'DONE';
-            
-            // Get total count for tasks
-            $count_stmt = $pdo->prepare("
-                SELECT COUNT(*) as total
-                FROM Properties Prop
-                JOIN Notes N ON Prop.note_id = N.id
-                WHERE Prop.name = 'status' AND Prop.value = ? AND Prop.note_id IS NOT NULL
-            ");
-            $count_stmt->execute([$property_value]);
-            $total = $count_stmt->fetch()['total'];
-            
-            $stmt = $pdo->prepare("
-                SELECT 
-                    N.id as note_id,
-                    N.content,
-                    N.page_id,
-                    Pg.name as page_name,
-                    Prop.name as property_name,
-                    Prop.value as property_value
-                FROM Properties Prop
-                JOIN Notes N ON Prop.note_id = N.id
-                JOIN Pages Pg ON N.page_id = Pg.id
-                WHERE Prop.name = 'status' AND Prop.value = ? AND Prop.note_id IS NOT NULL
-                ORDER BY N.updated_at DESC
-                LIMIT ? OFFSET ?
-            ");
-            $stmt->execute([$property_value, $per_page, $offset]);
-            $results = $stmt->fetchAll();
-
-            $noteIds = array_column($results, 'note_id');
-            $propertiesByNoteId = [];
-
-            if (!empty($noteIds)) {
-                $includeInternalProperties = true;
-                $propertiesByNoteId = $dataManager->getPropertiesForNoteIds($noteIds, $includeInternalProperties);
-            }
+            $count_stmt = $pdo->prepare("SELECT COUNT(DISTINCT N.id) FROM Properties Prop JOIN Notes N ON Prop.note_id = N.id WHERE Prop.name = 'status' AND Prop.value = ?");
+            $count_stmt->execute([$status]);
+            $total = (int)$count_stmt->fetchColumn();
 
-            foreach ($results as &$result) {
-                $result['content_snippet'] = get_content_snippet($result['content'], $property_value);
-                $result['properties'] = $propertiesByNoteId[$result['note_id']] ?? [];
-            }
-            unset($result);
-
-            $total_pages = ceil($total / $per_page);
-            ApiResponse::success([
-                'results' => $results,
-                'pagination' => [
-                    'total' => $total,
-                    'page' => $page,
-                    'per_page' => $per_page,
-                    'total_pages' => $total_pages
-                ]
-            ]);
+            $stmt = $pdo->prepare("SELECT N.id as note_id, N.content, N.page_id, Pg.name as page_name FROM Properties Prop JOIN Notes N ON Prop.note_id = N.id JOIN Pages Pg ON N.page_id = Pg.id WHERE Prop.name = 'status' AND Prop.value = ? GROUP BY N.id ORDER BY N.updated_at DESC LIMIT ? OFFSET ?");
+            $stmt->execute([$status, $per_page, $offset]);
+            $results = $stmt->fetchAll();
+            foreach ($results as &$result) $result['content_snippet'] = get_content_snippet($result['content'], '{status::' . $status . '}');
 
         } else {
             ApiResponse::error('Missing search parameter. Use q, backlinks_for_page_name, or tasks', 400);
         }
+
+        // Attach properties to all results, regardless of search type
+        attach_properties_to_results($dataManager, $results);
+
+        ApiResponse::success([
+            'results' => $results,
+            'pagination' => [
+                'total_items' => $total,
+                'current_page' => $page,
+                'per_page' => $per_page,
+                'total_pages' => ceil($total / $per_page)
+            ]
+        ]);
+
     } catch (PDOException $e) {
-        ApiResponse::error('Search failed: ' . $e->getMessage(), 500);
+        // FTS5 might throw an error on invalid syntax
+        error_log("Search Error: " . $e->getMessage());
+        ApiResponse::error('Search failed. Please check your search term or contact support.', 500, ['details' => $e->getMessage()]);
     }
 } else {
     ApiResponse::error('Method Not Allowed', 405);
-}
+}
\ No newline at end of file
diff --git a/assets/css/calendar.css b/assets/css/calendar.css
new file mode 100644
index 0000000..3a34cce
--- /dev/null
+++ b/assets/css/calendar.css
@@ -0,0 +1,116 @@
+/* Calendar Widget */
+.calendar-widget {
+    background-color: var(--ls-primary-background-color);
+    border: 1px solid var(--ls-border-color);
+    border-radius: var(--ls-border-radius-medium);
+    padding: var(--ls-space-3);
+    font-size: var(--ls-font-size-s);
+}
+
+.calendar-header {
+    display: flex;
+    justify-content: space-between;
+    align-items: center;
+    margin-bottom: var(--ls-space-3);
+}
+
+.month-year-display {
+    font-weight: bold;
+    font-size: var(--ls-font-size-m);
+    color: var(--ls-primary-text-color);
+}
+
+.calendar-grid {
+    display: grid;
+    gap: var(--ls-space-2);
+}
+
+.calendar-weekdays {
+    grid-template-columns: repeat(7, 1fr);
+    text-align: center;
+    font-weight: bold;
+    color: var(--ls-secondary-text-color);
+    margin-bottom: var(--ls-space-1);
+}
+
+.calendar-days {
+    grid-template-columns: repeat(7, 1fr);
+    text-align: center;
+}
+
+.calendar-day {
+    padding: var(--ls-space-2) var(--ls-space-1);
+    border-radius: var(--ls-border-radius-small);
+    cursor: pointer;
+    transition: background-color 0.2s ease, box-shadow 0.2s ease;
+    color: var(--ls-primary-text-color);
+}
+
+.calendar-day.empty {
+    background-color: transparent;
+    cursor: default;
+}
+
+.calendar-day:not(.empty):hover {
+    background-color: var(--ls-tertiary-background-color);
+}
+
+.calendar-day:active {
+    transform: scale(0.95);
+    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2) inset; /* Subtle press effect */
+}
+
+.calendar-day.today {
+    background-color: var(--ls-calendar-today-bg, var(--ls-accent-10));
+    color: var(--ls-calendar-today-text, #ffffff);
+    font-weight: bold;
+}
+
+.calendar-day.has-content {
+    position: relative;
+    border: 1px solid var(--ls-accent-5);
+}
+
+.calendar-day.has-content::after {
+    content: '';
+    display: block;
+    width: 6px;
+    height: 6px;
+    background-color: var(--ls-accent-8); /* Indicator dot */
+    border-radius: 50%;
+    position: absolute;
+    bottom: 2px;
+    left: 50%;
+    transform: translateX(-50%);
+}
+
+.calendar-day.current-page {
+    box-shadow: var(--ls-calendar-current-page-glow, 0 0 8px hsl(var(--ls-accent-10-hsl) / 0.3));
+    border-color: var(--ls-accent-8);
+}
+
+.calendar-day.today.current-page {
+    background-color: var(--ls-calendar-today-bg, var(--ls-accent-10));
+    color: var(--ls-calendar-today-text, #ffffff);
+    box-shadow: var(--ls-calendar-current-page-glow, 0 0 8px hsl(var(--ls-accent-10-hsl) / 0.3));
+}
+
+.arrow-btn {
+    background: none;
+    border: none;
+    cursor: pointer;
+    color: var(--ls-primary-text-color);
+    padding: var(--ls-space-1);
+    border-radius: var(--ls-border-radius-small);
+    transition: background-color 0.2s ease;
+}
+
+.arrow-btn:hover {
+    background-color: var(--ls-tertiary-background-color);
+}
+
+.arrow-btn svg {
+    stroke: var(--ls-primary-text-color);
+    width: 20px; /* Adjust size as needed */
+    height: 20px; /* Adjust size as needed */
+} 
\ No newline at end of file
diff --git a/assets/js/api_client.js b/assets/js/api_client.js
index 9c7dd64..c8c36de 100644
--- a/assets/js/api_client.js
+++ b/assets/js/api_client.js
@@ -39,27 +39,17 @@ async function apiRequest(endpoint, method = 'GET', body = null) {
     try {
         const response = await fetch(API_BASE_URL + endpoint, options);
         
-        console.log(`[apiRequest] Making ${method} request to: ${API_BASE_URL + endpoint}`);
-        if (body) {
-            console.log('[apiRequest] Request body:', body);
-        }
-        
         if (response.status === 204) {
-            // For 204 No Content, the API spec implies a success with no data to return.
-            // The new spec usually has a JSON body like { status: "success", message: "..." } for these.
-            // However, if a true 204 is returned, this is fine.
-            return undefined; // Or return { status: "success", data: undefined } if consistency is desired
+            return undefined;
         }
 
         const contentType = response.headers.get('content-type');
         if (!contentType || !contentType.includes('application/json')) {
             const text = await response.text();
             console.error('Non-JSON response:', text);
-            // If the response is not OK and not JSON, throw an error with the text.
             if (!response.ok) {
                 throw new Error(`Server error: ${response.status} ${response.statusText}. Response: ${text}`);
             }
-            // If response is OK but not JSON, this is unexpected based on spec.
             throw new Error(`Invalid response format: expected JSON but got ${contentType || 'unknown content type'}. Response: ${text}`);
         }
 
@@ -69,12 +59,10 @@ async function apiRequest(endpoint, method = 'GET', body = null) {
             console.error('PHP Error in response:', data);
             throw new Error('Server error: PHP error in response');
         }
-
-        // Primary error check based on new API spec (status: "error")
-        // This also covers cases where HTTP status might be 200 but operation failed.
+        
         if (data && data.status === 'error') {
             let errorMessage = data.message || 'API request failed (status:error)';
-            if (data.details) { // Include details if available
+            if (data.details) {
                 errorMessage += ` Details: ${JSON.stringify(data.details)}`;
             }
             console.error('API Error (data.status === "error"):', errorMessage);
@@ -82,8 +70,6 @@ async function apiRequest(endpoint, method = 'GET', body = null) {
             throw new Error(errorMessage);
         }
 
-        // Handle HTTP errors (4xx, 5xx) that might not have the {status:"error"} body,
-        // or if they do, the message extraction above would have caught it.
         if (!response.ok) {
             let errorMessage = data?.message || data?.error?.message || data?.error || response.statusText;
             if (typeof errorMessage === 'object') {
@@ -94,21 +80,8 @@ async function apiRequest(endpoint, method = 'GET', body = null) {
             throw new Error(errorMessage);
         }
         
-        // If data.status is "success" or not present (for older endpoints not yet updated),
-        // and response.ok is true, proceed.
-        // The new spec always includes `status: "success"` on success.
-        // It's good practice to check for data.status === "success" if all endpoints conform.
-        // For now, not strictly enforcing data.status === "success" to maintain compatibility
-        // if some old endpoints are called. The main change is handling data.status === "error".
-
-        console.log('[apiRequest] Response successful. Full data object:', JSON.parse(JSON.stringify(data)));
-        
-        // The API spec states responses will be like:
-        // { "status": "success", "data": { ... } }
-        // OR { "status": "success", "message": "...", "data": { ... } } (e.g. Attachment upload)
-        // OR { "status": "success", "message": "..." } (e.g. Attachment delete)
-        // The function should return the content of the "data" field.
-        // If "data" field is not present (like in attachment delete), it will return undefined, which is fine.
+        // Per API Spec, all successful responses have a `data` key.
+        // This function now consistently returns ONLY the content of the `data` key.
         return data.data;
 
     } catch (error) {
@@ -128,21 +101,14 @@ async function apiRequest(endpoint, method = 'GET', body = null) {
 const pagesAPI = {
     /**
      * Get all pages
-     * @param {Object} [options={}] - Query options
-     * @param {boolean} [options.excludeJournal=false] - Whether to exclude journal pages
-     * @param {boolean} [options.followAliases=true] - Whether to follow page aliases
-     * @param {boolean} [options.include_details=false] - Whether to include page properties and notes (new backend feature)
-     * @param {boolean} [options.include_internal=false] - Whether to include internal properties and notes (if include_details is true)
-     * @returns {Promise<Array>} Array of page objects (potentially detailed if include_details is true)
+     * @returns {Promise<{pages: Array, pagination: Object|null}>} Object with pages array and pagination info
      */
-    getPages: async (options = {}) => { // Added async keyword
+    getPages: async (options = {}) => {
         const params = new URLSearchParams();
         if (options.excludeJournal) params.append('exclude_journal', '1');
-        if (options.followAliases === false) params.append('follow_aliases', '0'); // Note: API spec default is 1 (true)
+        if (options.followAliases === false) params.append('follow_aliases', '0');
         if (options.include_details) params.append('include_details', '1');
         if (options.include_internal) params.append('include_internal', '1');
-        
-        // Add pagination and sorting parameters from options
         if (options.page) params.append('page', options.page.toString());
         if (options.per_page) params.append('per_page', options.per_page.toString());
         if (options.sort_by) params.append('sort_by', options.sort_by);
@@ -150,117 +116,39 @@ const pagesAPI = {
         
         const queryString = params.toString();
         try {
-            // apiRequest returns the content of the "data" field from the API response.
-            // For pages.php, this is an object: { data: [...pages...], pagination: {...} }
-            const apiResponsePayload = await apiRequest(`pages.php${queryString ? '?' + queryString : ''}`);
-
-            // Check if apiResponsePayload itself is the expected structure { data: [...], pagination: ... }
-            if (apiResponsePayload && Array.isArray(apiResponsePayload.data) && typeof apiResponsePayload.pagination === 'object' && apiResponsePayload.pagination !== null) {
-                return { pages: apiResponsePayload.data, pagination: apiResponsePayload.pagination };
-            } else if (Array.isArray(apiResponsePayload)) {
-                // This case handles if apiRequest returned a direct array of pages.
-                // This might happen if apiRequest changes or if a different endpoint (not pages.php) is called.
-                // For robustness, we assume no pagination info in this scenario.
-                console.warn('[pagesAPI.getPages] API response was a direct array. Assuming no pagination info.');
-                return { pages: apiResponsePayload, pagination: null };
-            } else {
-                // Fallback for other unexpected structures or if apiResponsePayload is null/undefined
-                console.warn('[pagesAPI.getPages] Response was not in the expected {data: [...], pagination: {...}} format or was empty. Response:', apiResponsePayload);
-                return { pages: [], pagination: null };
+            // apiRequest returns the `data` object, which for this endpoint contains `data` (the array) and `pagination`.
+            const responsePayload = await apiRequest(`pages.php${queryString ? '?' + queryString : ''}`);
+            
+            if (responsePayload && Array.isArray(responsePayload.data) && responsePayload.pagination) {
+                return { pages: responsePayload.data, pagination: responsePayload.pagination };
+            }
+            if (Array.isArray(responsePayload)) { // Fallback for non-paginated
+                 return { pages: responsePayload, pagination: null };
             }
+            
+            console.warn('[pagesAPI.getPages] Unexpected response format:', responsePayload);
+            return { pages: [], pagination: null };
+
         } catch (error) {
             console.error('[pagesAPI.getPages] Error fetching pages:', error);
-            // Ensure a consistent return type in case of error
             return { pages: [], pagination: null };
         }
     },
-
-    /**
-     * Get page by ID
-     * @param {number} id - Page ID
-     * @param {Object} [options={}] - Query options
-     * @param {boolean} [options.followAliases=true] - Whether to follow page aliases.
-     * @param {boolean} [options.include_details=false] - Whether to include page properties and notes.
-     * @param {boolean} [options.include_internal=false] - Whether to include internal properties (if include_details is true).
-     * @returns {Promise<Object>} Page object (potentially detailed if include_details is true).
-     */
-    getPageById: (id, options = {}) => {
-        const params = new URLSearchParams({ id: id.toString() });
-        if (options.followAliases === false) params.append('follow_aliases', '0');
-        if (options.include_details) params.append('include_details', '1');
-        if (options.include_internal) params.append('include_internal', '1'); // Server expects '1' for true
-        
-        return apiRequest(`pages.php?${params.toString()}`);
-    },
-
-    /**
-     * Get page by name
-     * @param {string} name - Page name
-     * @param {Object} [options={}] - Query options
-     * @param {boolean} [options.followAliases=true] - Whether to follow page aliases.
-     * @param {boolean} [options.include_details=false] - Whether to include page properties and notes.
-     * @param {boolean} [options.include_internal=false] - Whether to include internal properties (if include_details is true).
-     * @returns {Promise<Object>} Page object (potentially detailed if include_details is true).
-     */
-    getPageByName: (name, options = {}) => {
-        const params = new URLSearchParams({ name });
-        if (options.followAliases === false) params.append('follow_aliases', '0');
-        if (options.include_details) params.append('include_details', '1');
-        if (options.include_internal) params.append('include_internal', '1'); // Server expects '1' for true
-
-        return apiRequest(`pages.php?${params.toString()}`);
-    },
-
-    /**
-     * Create a new page with a given name.
-     * @param {string} pageName - The name for the new page.
-     * @returns {Promise<Object>} Created page object (typically {id, name, title, ...})
-     * @throws {Error} If pageName is not a non-empty string or if API request fails.
-     */
-    createPage: async (pageName) => {
-        if (typeof pageName !== 'string' || pageName.trim() === '') {
-            // apiRequest would likely reject or the API would return an error,
-            // but explicit client-side check is good practice.
-            return Promise.reject(new Error('Page name must be a non-empty string.'));
+    getPageById: (id) => apiRequest(`pages.php?id=${id}`),
+    getPageByName: (name) => apiRequest(`pages.php?name=${encodeURIComponent(name)}`),
+    createPage: (pageName, content = null) => {
+        const payload = { name: pageName };
+        if (content !== null) {
+            payload.content = content;
         }
-        // apiRequest handles JSON.stringify for the body { name: pageName }
-        // and returns a promise that resolves with the parsed JSON response data (data.data)
-        // or rejects with an error.
-        return apiRequest('pages.php', 'POST', { name: pageName });
+        return apiRequest('pages.php', 'POST', payload);
     },
-
-    /**
-     * Update a page
-     * @param {number} id - Page ID
-     * @param {{name?: string, alias?: string, properties_explicit?: {}}} pageData - Updated page data
-     * @returns {Promise<Object>} Updated page object
-     */
     updatePage: (id, pageData) => {
-        const body = {
-            action: 'update',
-            id: id,
-            ...pageData // Should contain name, alias, or properties_explicit
-        };
-        // Remove undefined keys from pageData to keep payload clean
-        Object.keys(body).forEach(key => {
-            if (body[key] === undefined) {
-                delete body[key];
-            }
-        });
+        const body = { _method: 'PUT', id, ...pageData };
         return apiRequest('pages.php', 'POST', body);
     },
-
-    /**
-     * Delete a page
-     * @param {number} id - Page ID
-     * @returns {Promise<Object>} Delete confirmation
-     */
     deletePage: (id) => {
-        const body = {
-            action: 'delete',
-            id: id
-        };
-        return apiRequest('pages.php', 'POST', body);
+        return apiRequest('pages.php', 'POST', { _method: 'DELETE', id });
     }
 };
 
@@ -269,171 +157,24 @@ const pagesAPI = {
  * @namespace notesAPI
  */
 const notesAPI = {
-    /**
-     * Get full page data including page details, notes, and properties.
-     * @param {number} pageId - Page ID
-     * @param {Object} [options={}] - Query options
-     * @param {boolean} [options.include_internal=false] - Whether to include internal properties and notes.
-     * @returns {Promise<{page: Object, notes: Array<Object>}>} Object containing page details and an array of notes with their properties.
-     * Expected structure: { page: { ...page_details, properties: { ...page_properties } }, notes: [ { ...note_details, properties: { ...note_properties } }, ... ] }
-     */
-    getPageData: (pageId, options = {}) => {
-        const params = new URLSearchParams();
-        params.append('page_id', pageId.toString());
-        if (options.include_internal) {
-            params.append('include_internal', '1');
-        }
-        // Add pagination and sorting parameters for the notes list from options
-        if (options.page) params.append('page', options.page.toString());
-        if (options.per_page) params.append('per_page', options.per_page.toString());
-        if (options.sort_by) params.append('sort_by', options.sort_by); // e.g., 'created_at', 'order_index'
-        if (options.sort_order) params.append('sort_order', options.sort_order); // 'asc' or 'desc'
-        
-        return apiRequest(`notes.php?${params.toString()}`);
-    },
-
-    /**
-     * Get a specific note
-     * @param {number} noteId - Note ID
-     * @param {Object} [options={}] - Query options
-     * @param {boolean} [options.include_internal=false] - Whether to include internal properties.
-     * @returns {Promise<{id: number, content: string, page_id: number, created_at: string, updated_at: string, properties: Object}>}
-     */
-    getNote: (noteId, options = {}) => {
-        const params = new URLSearchParams();
-        params.append('id', noteId.toString());
-        if (options.include_internal) {
-            params.append('include_internal', '1');
-        }
-        return apiRequest(`notes.php?${params.toString()}`);
-    },
-
-    /**
-     * Create a new note
-     * @param {{page_id: number, content: string, parent_note_id?: number|null}} noteData - Note data
-     * @returns {Promise<{id: number, content: string, page_id: number, parent_note_id: number|null, created_at: string, updated_at: string}>}
-     */
-    createNote: (noteData) => apiRequest('notes.php', 'POST', noteData),
-
-    /**
-     * Update a note
-     * @param {number} noteId - Note ID
-     * @param {Object} noteUpdateData - Updated note data.
-     * @param {string} [noteUpdateData.content] - The new content for the note.
-     * @param {number|null} [noteUpdateData.parent_note_id] - The ID of the parent note, or null.
-     * @param {number} [noteUpdateData.order_index] - The display order of the note.
-     * @param {number} [noteUpdateData.collapsed] - 0 for expanded, 1 for collapsed.
-     * @param {Object} [noteUpdateData.properties_explicit] - Explicit properties to set.
-     * @returns {Promise<Object>} The updated note object. The structure matches the getNote response.
-     */
-    updateNote: (noteId, noteUpdateData) => {
-        const body = {
-            _method: 'PUT', // Add this line
-            action: 'update', // This might be redundant if _method is PUT, but backend might use it
-            id: noteId,
-            ...noteUpdateData
-        };
-        // Remove any potential undefined fields that might have been explicitly passed
-        Object.keys(body).forEach(key => {
-            if (body[key] === undefined) {
-                delete body[key];
-            }
-        });
+    getPageData: (pageId) => apiRequest(`notes.php?page_id=${pageId}`),
+    getNote: (noteId) => apiRequest(`notes.php?id=${noteId}`),
+    batchUpdateNotes: (operations) => {
+        const body = { action: 'batch', operations };
         return apiRequest('notes.php', 'POST', body);
     },
-
-    /**
-     * Delete a note
-     * @param {number} noteId - Note ID
-     * @returns {Promise<null>}
-     */
-    deleteNote: (noteId) => {
-        const body = {
-            action: 'delete',
-            id: noteId
-        };
-        return apiRequest('notes.php', 'POST', body);
-    },
-
-        /**
-     * Batch update notes.
-     * @param {Array<Object>} operations - Array of operations {type, payload}.
-     * @returns {Promise<Array<Object>>} A promise that resolves to the array of individual operation results.
-     * @throws {Error} If the batch operation fails or the response structure is unexpected.
-     */
-        batchUpdateNotes: async (operations) => { // Make it async to await apiRequest
-            const body = {
-                action: 'batch',
-                operations: operations
-            };
-            // apiRequest returns the content of the top-level 'data' field from the JSON response.
-            // For batch, this should be an object like { results: [...] }
-            const responseData = await apiRequest('notes.php', 'POST', body);
-    
-            // Now, specifically extract the 'results' array and perform validation here.
-            if (responseData && Array.isArray(responseData.results)) {
-                // Optionally, you could even validate each item in responseData.results here
-                // to ensure it has 'type', 'status', etc., before returning.
-                return responseData.results; // Return ONLY the array of results
-            } else {
-                // If the structure is not what's expected for a successful batch response.
-                console.error('batchUpdateNotes: Invalid response structure. Expected "responseData.results" to be an array.', responseData);
-                throw new Error('Batch update failed: Invalid server response format.');
-            }
-        }
+    // The individual create, update, delete wrappers were removed as they were causing confusion.
+    // All note modifications should go through note-actions.js which correctly uses the batch endpoint.
 };
 
 /**
- * API functions for managing properties
+ * API functions for properties
  * @namespace propertiesAPI
  */
 const propertiesAPI = {
-    /**
-     * Get properties for an entity
-     * @param {string} entityType - Entity type ('note' or 'page')
-     * @param {number} entityId - Entity ID
-     * @param {Object} [options={}] - Query options.
-     * @param {boolean} [options.include_internal=false] - Whether to include internal properties.
-     * @returns {Promise<Object>} Properties object. Structure may vary based on include_internal.
-     */
-    getProperties: (entityType, entityId, options = {}) => {
-        const params = new URLSearchParams({
-            entity_type: entityType,
-            entity_id: entityId.toString()
-        });
-        if (options.include_internal) {
-            params.append('include_internal', '1');
-        }
+    getProperties: (entityType, entityId) => {
+        const params = new URLSearchParams({ entity_type: entityType, entity_id: entityId.toString() });
         return apiRequest(`properties.php?${params.toString()}`);
-    },
-
-    /**
-     * Set a property. If the property already exists, its value is updated.
-     * @param {Object} propertyData - Property data.
-     * @param {string} propertyData.entity_type - Entity type ('note' or 'page').
-     * @param {number} propertyData.entity_id - Entity ID.
-     * @param {string} propertyData.name - Property name.
-     * @param {any} propertyData.value - Property value.
-     * @param {0|1} [propertyData.internal] - Optional. Explicitly set internal status (0 or 1). If undefined, backend determines automatically.
-     * @returns {Promise<Object>} The created or updated property object.
-     */
-    setProperty: (propertyData) => apiRequest('properties.php', 'POST', propertyData),
-
-    /**
-     * Delete a property
-     * @param {string} entityType - Entity type ('note' or 'page')
-     * @param {number} entityId - Entity ID
-     * @param {string} propertyName - Property name
-     * @returns {Promise<null>}
-     */
-    deleteProperty: (entityType, entityId, propertyName) => {
-        const deleteData = {
-            action: 'delete',
-            entity_type: entityType,
-            entity_id: entityId,
-            name: propertyName
-        };
-        return apiRequest('properties.php', 'POST', deleteData);
     }
 };
 
@@ -442,71 +183,10 @@ const propertiesAPI = {
  * @namespace attachmentsAPI
  */
 const attachmentsAPI = {
-    /**
-     * Get all attachments with optional filtering and pagination
-     * @param {Object} [params={}] - Query parameters
-     * @param {number} [params.page=1] - Page number
-     * @param {number} [params.per_page=10] - Items per page
-     * @param {string} [params.sort_by='created_at'] - Field to sort by
-     * @param {string} [params.sort_order='desc'] - Sort order ('asc' or 'desc')
-     * @param {string} [params.filter_by_name] - Filter by name (partial match)
-     * @param {string} [params.filter_by_type] - Filter by type (exact match)
-     * @returns {Promise<{attachments: Array, pagination: Object}>} Object containing attachments array and pagination info
-     */
-    getAllAttachments: (params = {}) => {
-        const queryParams = new URLSearchParams();
-        
-        // Add all provided parameters
-        Object.entries(params).forEach(([key, value]) => {
-            if (value !== undefined && value !== null && value !== '') {
-                queryParams.append(key, value);
-            }
-        });
-        
-        return apiRequest(`attachments.php?${queryParams.toString()}`);
-    },
-
-    /**
-     * Get attachments for a specific note
-     * @param {number} noteId - Note ID
-     * @returns {Promise<Array>} Array of attachment objects
-     */
-    getNoteAttachments: (noteId, options = {}) => {
-        const params = new URLSearchParams();
-        params.append('note_id', noteId.toString());
-
-        // Add pagination, sorting, and filtering parameters from options
-        if (options.page) params.append('page', options.page.toString());
-        if (options.per_page) params.append('per_page', options.per_page.toString());
-        if (options.sort_by) params.append('sort_by', options.sort_by);
-        if (options.sort_order) params.append('sort_order', options.sort_order);
-        if (options.filter_by_name) params.append('filter_by_name', options.filter_by_name);
-        if (options.filter_by_type) params.append('filter_by_type', options.filter_by_type);
-        
-        const queryString = params.toString();
-        return apiRequest(`attachments.php?${queryString}`);
-    },
-
-    /**
-     * Upload a new attachment
-     * @param {FormData} formData - FormData object containing note_id and attachmentFile
-     * @returns {Promise<Object>} Created attachment object
-     */
-    uploadAttachment: (formData) => {
-        return apiRequest('attachments.php', 'POST', formData);
-    },
-
-    /**
-     * Delete an attachment
-     * @param {number} attachmentId - Attachment ID
-     * @returns {Promise<Object>} Delete confirmation
-     */
+    getNoteAttachments: (noteId) => apiRequest(`attachments.php?note_id=${noteId}`),
+    uploadAttachment: (formData) => apiRequest('attachments.php', 'POST', formData),
     deleteAttachment: (attachmentId) => {
-        const body = {
-            action: 'delete',
-            id: attachmentId
-        };
-        return apiRequest('attachments.php', 'POST', body);
+        return apiRequest('attachments.php', 'POST', { _method: 'DELETE', id: attachmentId });
     }
 };
 
@@ -515,60 +195,13 @@ const attachmentsAPI = {
  * @namespace searchAPI
  */
 const searchAPI = {
-    /**
-     * Perform a full-text search
-     * @param {string} query - Search query
-     * @returns {Promise<Array<{note_id: number, content: string, page_id: number, page_name: string, content_snippet: string}>>}
-     */
     search: (query, options = {}) => {
-        const params = new URLSearchParams();
-        params.append('q', query); // query is already URI encoded by URLSearchParams
+        const params = new URLSearchParams({ q: query });
         if (options.page) params.append('page', options.page.toString());
         if (options.per_page) params.append('per_page', options.per_page.toString());
         return apiRequest(`search.php?${params.toString()}`);
     },
-
-    /**
-     * Get backlinks for a page
-     * @param {string} pageName - Page name
-     * @returns {Promise<Array<{note_id: number, content: string, page_id: number, source_page_name: string, content_snippet: string}>>}
-     */
-    getBacklinks: async (pageName, options = {}) => { // Added async
-        const params = new URLSearchParams();
-        params.append('backlinks_for_page_name', pageName); // pageName is already URI encoded
-        if (options.page) params.append('page', options.page.toString());
-        if (options.per_page) params.append('per_page', options.per_page.toString());
-        const responseData = await apiRequest(`search.php?${params.toString()}`); // Added await and stored in responseData
-
-        if (Array.isArray(responseData)) {
-            return responseData;
-        }
-
-        if (responseData && typeof responseData === 'object') {
-            const keysToTry = ['backlinks', 'items', 'results', 'data'];
-            for (const key of keysToTry) {
-                if (responseData.hasOwnProperty(key) && Array.isArray(responseData[key])) {
-                    return responseData[key];
-                }
-            }
-        }
-
-        console.warn('[searchAPI.getBacklinks] Response was not an array and no known data key was found. Response:', responseData);
-        return []; // Return empty array as a fallback
-    },
-
-    /**
-     * Get tasks by status
-     * @param {'todo'|'done'} status - Task status
-     * @returns {Promise<Array<{note_id: number, content: string, page_id: number, page_name: string, content_snippet: string, properties: Object}>>}
-     */
-    getTasks: (status, options = {}) => {
-        const params = new URLSearchParams();
-        params.append('tasks', status);
-        if (options.page) params.append('page', options.page.toString());
-        if (options.per_page) params.append('per_page', options.per_page.toString());
-        return apiRequest(`search.php?${params.toString()}`);
-    }
+    getBacklinks: (pageName) => apiRequest(`search.php?backlinks_for_page_name=${encodeURIComponent(pageName)}`)
 };
 
 /**
@@ -576,40 +209,9 @@ const searchAPI = {
  * @namespace templatesAPI
  */
 const templatesAPI = {
-    /**
-     * Get available templates
-     * @param {string} type - Template type ('note' or 'page')
-     * @returns {Promise<Array<{name: string, content: string}>>} Array of template objects.
-     */
-    getTemplates: (type, options = {}) => {
-        const params = new URLSearchParams();
-        params.append('type', type);
-        if (options.page) params.append('page', options.page.toString());
-        if (options.per_page) params.append('per_page', options.per_page.toString());
-        return apiRequest(`templates.php?${params.toString()}`);
-    },
-
-    /**
-     * Create a new template
-     * @param {{type: string, name: string, content: string}} templateData - Template data
-     * @returns {Promise<Object>} Creation confirmation
-     */
-    createTemplate: (templateData) => apiRequest('templates.php', 'POST', templateData),
-
-    /**
-     * Delete a template
-     * @param {string} type - Template type ('note' or 'page')
-     * @param {string} name - Template name
-     * @returns {Promise<Object>} Deletion confirmation
-     */
-    deleteTemplate: (type, name) => {
-        const body = {
-            action: 'delete',
-            type: type,
-            name: name
-        };
-        return apiRequest('templates.php', 'POST', body);
-    }
+    getTemplates: (type) => apiRequest(`templates.php?type=${type}`),
+    createTemplate: (templateData) => apiRequest('templates.php', 'POST', { _method: 'POST', ...templateData }),
+    deleteTemplate: (type, name) => apiRequest('templates.php', 'POST', { _method: 'DELETE', type, name })
 };
 
 /**
@@ -617,65 +219,12 @@ const templatesAPI = {
  * @namespace queryAPI
  */
 const queryAPI = {
-    /**
-     * Executes a custom SQL query for notes.
-     * @param {string} sqlQuery - The SQL query string.
-     * @param {Object} [options={}] - Optional parameters.
-     * @param {boolean} [options.include_properties=false] - Whether to include properties for each note.
-     * @param {number} [options.page=1] - Page number for query results.
-     * @param {number} [options.per_page=10] - Items per page for query results.
-     * @returns {Promise<Object>} Object containing 'data' (array of notes) and 'pagination' info.
-     *                            The apiRequest will return data.data, which itself is the array of notes.
-     *                            The API spec says: { "status": "success", "data": [...notes...], "pagination": {...} }
-     *                            So, apiRequest(data.data) would return [...notes...].
-     *                            The original fetch call in handleSqlQueries expected result.data and result.success.
-     *                            The new apiRequest handles success/error and returns the payload.
-     *                            If the API returns { status: "success", "data": [], "pagination": {} },
-     *                            apiRequest will return the array `[]`. The pagination info is part of the full `data` object.
-     *                            For this specific case, we might want the whole {data, pagination} structure.
-     *                            However, to keep apiRequest consistent (returning data.data),
-     *                            the caller of queryNotes (handleSqlQueries) will receive just the array of notes.
-     *                            If pagination is needed from query_notes.php, apiRequest would need adjustment,
-     *                            OR queryNotes would need to use fetch directly (undesirable),
-     *                            OR the backend for query_notes.php needs to return { data: { notes: [], pagination: {} } }.
-     *                            Assuming the spec means "data" field contains the array of notes, and pagination is a sibling.
-     *                            The current apiRequest returns data.data. So, if the response is
-     *                            { "status": "success", "data": [note1, note2], "pagination": {...} },
-     *                            then apiRequest returns [note1, note2].
-     *                            The original handleSqlQueries was: `const result = await response.json(); if (result.success && result.data)`
-     *                            This implies result.data was the array. So this should be fine.
-     */
-    queryNotes: async (sqlQuery, options = {}) => {
-        const body = {
-            sql_query: sqlQuery,
-            include_properties: options.include_properties || false,
-            page: options.page || 1,
-            per_page: options.per_page || 10
-        };
-        const responseData = await apiRequest('query_notes.php', 'POST', body);
-
-        // Handle cases where the API returns an object wrapping the array
-        if (Array.isArray(responseData)) {
-            return responseData;
-        }
-
-        if (responseData && typeof responseData === 'object') {
-            // Check for common keys that might hold the array
-            const keysToTry = ['notes', 'data', 'results'];
-            for (const key of keysToTry) {
-                if (responseData.hasOwnProperty(key) && Array.isArray(responseData[key])) {
-                    return responseData[key];
-                }
-            }
-        }
-
-        // Fallback for unexpected structures
-        console.warn('[queryAPI.queryNotes] Response was not an array and no known data key was found. Response:', responseData);
-        return [];
+    queryNotes: (sqlQuery, options = {}) => {
+        const body = { sql_query: sqlQuery, page: options.page || 1, per_page: options.per_page || 10 };
+        return apiRequest('query_notes.php', 'POST', body);
     }
 };
 
-// Export all API namespaces using ES6 export syntax
 export {
     pagesAPI,
     notesAPI,
@@ -683,5 +232,6 @@ export {
     attachmentsAPI,
     searchAPI,
     templatesAPI,
-    queryAPI
-};
+    queryAPI,
+    apiRequest
+};
\ No newline at end of file
diff --git a/assets/js/app.js b/assets/js/app.js
index 4bc6207..d9ab03f 100644
--- a/assets/js/app.js
+++ b/assets/js/app.js
@@ -4,959 +4,153 @@
  * @module app
  */
 
-// Core state management
-import {
-    currentPageName,
-    saveStatus,
-    pageDataCache,
-    CACHE_MAX_AGE_MS,
-    MAX_PREFETCH_PAGES,
-    notesForCurrentPage,
-    currentFocusedNoteId,
-    // Setters
-    setCurrentPageId,
-    setCurrentPageName,
-    setSaveStatus,
-    setNotesForCurrentPage,
-    addNoteToCurrentPage,
-    removeNoteFromCurrentPageById,
-    updateNoteInCurrentPage,
-    setCurrentFocusedNoteId,
-    // Cache functions
-    setPageCache,
-    getPageCache,
-    hasPageCache,
-    deletePageCache,
-    clearPageCache
-} from './app/state.js';
+// Core state management - not directly used here but good to see imports
+import { currentPageId } from './app/state.js';
 
 // Page management
-import {
-    loadPage,
-    prefetchRecentPagesData,
-    getInitialPage
-} from './app/page-loader.js';
-
+import { loadPage } from './app/page-loader.js';
 window.loadPage = loadPage; 
 
 // UI and event handling
-import { sidebarState } from './app/sidebar.js';
-import { initGlobalEventListeners } from './app/event-handlers.js';
-import { debounce, safeAddEventListener } from './utils.js';
 import { ui } from './ui.js';
+import { safeAddEventListener } from './utils.js';
 
 // Note actions
 import {
     handleAddRootNote,
     handleNoteKeyDown,
     handleTaskCheckboxClick,
-    getNoteDataById,
-    getNoteElementById,
-    debouncedSaveNote // Added import
+    debouncedSaveNote
 } from './app/note-actions.js';
 
-// Import API clients
-import { notesAPI, propertiesAPI, attachmentsAPI, searchAPI, templatesAPI, pagesAPI } from './api_client.js';
-
-// Import app initialization
-import { initializeApp } from './app/app-init.js';
-
-// Import property editor functions
-import { displayPageProperties as displayPagePropertiesFromEditor } from './app/property-editor.js';
-
-// Make some variables globally accessible for drag and drop
-// window.currentPageId, window.notesForCurrentPage, window.currentFocusedNoteId are set in state.js
+// API clients for global exposure if needed
+import { notesAPI, propertiesAPI, attachmentsAPI, searchAPI, pagesAPI, templatesAPI } from './api_client.js';
 window.notesAPI = notesAPI;
-window.propertiesAPI = propertiesAPI; 
-window.templatesAPI = templatesAPI; // Add this line
-
-// Get DOM references from UI module
-const {
-    notesContainer,
-    pageListContainer,
-    addRootNoteBtn,
-    toggleLeftSidebarBtn,
-    toggleRightSidebarBtn,
-    leftSidebar,
-    rightSidebar,
-    globalSearchInput,
-    // backlinksContainer, // Used in page-loader.js
-    currentPageTitleEl,
-    pagePropertiesGear,
-    pagePropertiesModal,
-    pagePropertiesModalClose,
-    pagePropertiesList,
-    addPagePropertyBtn,
-    openPageSearchModalBtn,
-    pageSearchModal,
-    pageSearchModalInput,
-    pageSearchModalResults,
-    pageSearchModalCancel
-} = ui.domRefs;
-
-// Debug logging for DOM elements
-console.log('DOM Elements Status:', {
-    notesContainer: !!notesContainer,
-    pageListContainer: !!pageListContainer,
-    addRootNoteBtn: !!addRootNoteBtn,
-    toggleLeftSidebarBtn: !!toggleLeftSidebarBtn,
-    toggleRightSidebarBtn: !!toggleRightSidebarBtn,
-    leftSidebar: !!leftSidebar,
-    rightSidebar: !!rightSidebar,
-    globalSearchInput: !!globalSearchInput,
-    // backlinksContainer: !!backlinksContainer, 
-    currentPageTitleEl: !!currentPageTitleEl,
-    pagePropertiesGear: !!pagePropertiesGear,
-    pagePropertiesModal: !!pagePropertiesModal,
-    pagePropertiesModalClose: !!pagePropertiesModalClose,
-    pagePropertiesList: !!pagePropertiesList,
-    addPagePropertyBtn: !!addPagePropertyBtn,
-    openPageSearchModalBtn: !!openPageSearchModalBtn,
-    pageSearchModal: !!pageSearchModal,
-    pageSearchModalInput: !!pageSearchModalInput,
-    pageSearchModalResults: !!pageSearchModalResults,
-    pageSearchModalCancel: !!pageSearchModalCancel
-});
-
-// Verify critical DOM elements
-const criticalElements = {
-    notesContainer,
-    pageListContainer
-};
-
-// Check if critical elements exist
-Object.entries(criticalElements).forEach(([name, element]) => {
-    if (!element) {
-        console.error(`Critical element missing: ${name}`);
-    }
-});
-
-
-/**
- * Fetches and displays the page list
- * @param {string} [activePageName] - Name of the page to mark as active
- */
-async function fetchAndDisplayPages(activePageName) {
-    try {
-        const pages = await pagesAPI.getPages();
-        window.ui.updatePageList(pages, activePageName || currentPageName);
-    } catch (error) {
-        console.error('Error fetching pages:', error);
-        if (window.ui.domRefs.pageListContainer) {
-            window.ui.domRefs.pageListContainer.innerHTML = '<li>Error loading pages.</li>';
-        }
-    }
-}
-
-/**
- * Loads or creates today's journal page
- */
-async function loadOrCreateDailyNotePage() {
-    const todayPageName = getInitialPage(); // Use imported getInitialPage
-    await loadPage(todayPageName, true); // Imported from page-loader
-    await fetchAndDisplayPages(todayPageName); // Local function using imported currentPageName
-}
-
-// getNoteDataById and getNoteElementById are now primarily in note-actions.js
-// If other parts of app.js still need them, they can import them from note-actions.js
-// For now, assuming they are not directly called from app.js after refactoring.
+window.propertiesAPI = propertiesAPI;
+window.attachmentsAPI = attachmentsAPI;
+window.searchAPI = searchAPI;
+window.pagesAPI = pagesAPI;
+window.templatesAPI = templatesAPI;
+
+// Property editor functions
+import { 
+    displayPageProperties as displayPagePropertiesFromEditor, 
+    initPropertyEditor
+} from './app/property-editor.js';
+
+// App initialization
+import { initializeApp } from './app/app-init.js';
 
-// Event Handlers
+// --- Global Function Exposure ---
+window.displayPageProperties = displayPagePropertiesFromEditor;
 
-// Sidebar toggle (Remove old direct listeners if sidebarState.init handles it)
-// if (toggleLeftSidebarBtn && leftSidebar) { ... } // This is now handled by sidebarState.init()
-// if (toggleRightSidebarBtn && rightSidebar) { ... } // This is now handled by sidebarState.init()
+// --- Event Handlers Setup ---
+const { notesContainer, addRootNoteBtn } = ui.domRefs;
 
-// Page list clicks
-if (criticalElements.pageListContainer) {
-    safeAddEventListener(criticalElements.pageListContainer, 'click', (e) => {
-        if (e.target.matches('a[data-page-name]')) {
-            e.preventDefault();
-            loadPage(e.target.dataset.pageName);
-        }
-    }, 'pageListContainer');
+if (!notesContainer) {
+    console.error('Critical DOM element missing: notesContainer. App cannot function.');
 }
 
-// Global search
-const debouncedSearch = debounce(async (query) => {
-    const searchResults = document.getElementById('search-results');
-    
-    if (!query.trim()) {
-        searchResults.classList.remove('has-results');
-        searchResults.innerHTML = '';
-        return;
-    }
-    
-    try {
-        const response = await searchAPI.search(query);
-        if (response && Array.isArray(response.results)) {
-            displaySearchResults(response.results);
-        } else {
-            console.warn('Search API returned unexpected format:', response);
-            displaySearchResults([]);
-        }
-    } catch (error) {
-        console.error('Search error:', error);
-        searchResults.innerHTML = '<div class="search-result-item">Error performing search</div>';
-        searchResults.classList.add('has-results');
-    }
-}, 300);
-
-if (globalSearchInput) {
-    safeAddEventListener(globalSearchInput, 'input', (e) => {
-        debouncedSearch(e.target.value);
-    }, 'globalSearchInput');
-}
-
-// Add root note
+// Add root note button
 safeAddEventListener(addRootNoteBtn, 'click', handleAddRootNote, 'addRootNoteBtn');
 
-// Note keyboard navigation and editing
-if (notesContainer) { // Ensure notesContainer is available before adding listeners
+// **FIXED**: This is where note-level event listeners should be attached.
+if (notesContainer) {
+    // Keydown for structural changes (Enter, Tab, Backspace) and navigation (Arrows)
     notesContainer.addEventListener('keydown', handleNoteKeyDown);
 
-    // Note interactions (task markers)
+    // Click handler for task checkboxes
     notesContainer.addEventListener('click', (e) => {
         if (e.target.matches('.task-checkbox')) {
             handleTaskCheckboxClick(e);
         }
-        // Other click interactions on notesContainer could be handled here or in other modules
     });
 
-    // Input event for debounced save (moved from direct anonymous function)
-    // This needs to be handled carefully: handleNoteKeyDown might already trigger saves.
-    // This was originally:
-    // safeAddEventListener(notesContainer, 'input', (e) => {
-    //     if (e.target.matches('.note-content.edit-mode')) {
-    //         const noteItem = e.target.closest('.note-item');
-    //         if (noteItem) {
-    //             const contentDiv = e.target;
-    //             const rawTextValue = ui.getRawTextWithNewlines(contentDiv);
-    //             contentDiv.dataset.rawContent = ui.normalizeNewlines(rawTextValue);
-    //             debouncedSaveNote(noteItem); // debouncedSaveNote would be imported from note-actions
-    //         }
-    //     }
-    // }, 'notesContainer');
-    // For now, this specific input listener is effectively part of handleNoteKeyDown or direct saves.
-    // If separate debouncing on general input is still desired, it needs to import debouncedSaveNote.
-
-    // Add the new input event listener here
-    safeAddEventListener(notesContainer, 'input', (e) => {
+    // Input handler for debounced saving of content
+    notesContainer.addEventListener('input', (e) => {
         if (e.target.matches('.note-content.edit-mode')) {
             const noteItem = e.target.closest('.note-item');
             if (noteItem) {
                 const contentDiv = e.target;
-                // Ensure ui object and its methods are correctly referenced.
-                // Assuming 'ui' is imported and available in this scope.
                 const rawTextValue = ui.getRawTextWithNewlines(contentDiv);
-                const normalizedContent = ui.normalizeNewlines(rawTextValue);
-                contentDiv.dataset.rawContent = normalizedContent;
+                contentDiv.dataset.rawContent = ui.normalizeNewlines(rawTextValue);
                 debouncedSaveNote(noteItem);
             }
         }
-    }, 'notesContainerInput'); // Added a unique name for safeAddEventListener
-}
-
-
-// Update displayPageProperties function - now uses the one from property-editor.js
-function displayPageProperties(properties) {
-    displayPagePropertiesFromEditor(properties);
-}
-
-/**
- * Renames a property key
- * @param {string} oldKey - Original property key
- * @param {string} newKey - New property key
- */
-async function renamePropertyKey(oldKey, newKey) {
-    const pageIdToUse = currentPageId; // From imported state
-    if (!pageIdToUse) return;
-
-    try {
-        // Get current properties
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        const value = properties[oldKey];
-        
-        if (value === undefined) {
-            console.warn(`Property ${oldKey} not found for renaming`);
-            return;
-        }
-
-        // Delete old property and create new one
-        await propertiesAPI.deleteProperty('page', pageIdToUse, oldKey);
-        await propertiesAPI.setProperty({
-            entity_type: 'page',
-            entity_id: pageIdToUse,
-            name: newKey,
-            value: value
-        });
-
-        // Refresh display
-        const updatedProperties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(updatedProperties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error renaming property key:', error);
-        alert('Failed to rename property');
-        // Refresh to restore original state
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(properties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
-    }
-}
-
-// Expose functions needed by ui.js for page properties modal
-window.displayPageProperties = displayPageProperties;
-window.addPageProperty = addPageProperty;
-
-/**
- * Renames a property key for array properties
- * @param {string} oldKey - Original property key
- * @param {string} newKey - New property key  
- * @param {number} arrayIndex - Index of the array value being edited
- */
-async function renameArrayPropertyKey(oldKey, newKey, arrayIndex) {
-    const pageIdToUse = currentPageId; // From imported state
-    if (!pageIdToUse) return;
-
-    try {
-        // Get current properties
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        const values = properties[oldKey];
-        
-        if (!Array.isArray(values)) {
-            console.warn(`Property ${oldKey} is not an array for renaming`);
-            return;
-        }
-
-        // For array properties, we need to move all values to the new key
-        await propertiesAPI.deleteProperty('page', pageIdToUse, oldKey);
-        
-        // Add all values under the new key
-        for (const value of values) {
-            await propertiesAPI.setProperty({
-                entity_type: 'page',
-                entity_id: pageIdToUse,
-                name: newKey,
-                value: value
-            });
-        }
-
-        // Refresh display
-        const updatedProperties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(updatedProperties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error renaming array property key:', error);
-        alert('Failed to rename property');
-        // Refresh to restore original state
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(properties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
-    }
+    });
 }
 
-/**
- * Updates a specific value in an array property
- * @param {string} key - Property key
- * @param {number} arrayIndex - Index of the value to update
- * @param {string} newValue - New value
- */
-async function updateArrayPropertyValue(key, arrayIndex, newValue) {
-    const pageIdToUse = currentPageId; // From imported state
-    if (!pageIdToUse) return;
-
-    try {
-        // Get current properties
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        const values = properties[key];
-        
-        if (!Array.isArray(values) || arrayIndex >= values.length) {
-            console.warn(`Invalid array property update: ${key}[${arrayIndex}]`);
-            return;
+// --- Drag and Drop for File Uploads ---
+if (notesContainer) {
+    notesContainer.addEventListener('dragover', (e) => {
+        e.preventDefault();
+        const noteWrapper = e.target.closest('.note-content-wrapper');
+        if (noteWrapper) {
+            noteWrapper.classList.add('dragover');
         }
+    });
 
-        // Delete all values for this key
-        await propertiesAPI.deleteProperty('page', pageIdToUse, key);
-        
-        // Re-add all values with the updated one
-        for (let i = 0; i < values.length; i++) {
-            const value = i === arrayIndex ? newValue : values[i];
-            await propertiesAPI.setProperty({
-                entity_type: 'page',
-                entity_id: pageIdToUse,
-                name: key,
-                value: value
-            });
+    notesContainer.addEventListener('dragleave', (e) => {
+        const noteWrapper = e.target.closest('.note-content-wrapper');
+        if (noteWrapper) {
+            noteWrapper.classList.remove('dragover');
         }
+    });
 
-        // Refresh display
-        const updatedProperties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(updatedProperties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error updating array property value:', error);
-        alert('Failed to update property value');
-        // Refresh to restore original state
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(properties);
+    notesContainer.addEventListener('drop', async (e) => {
+        e.preventDefault();
+        const noteWrapper = e.target.closest('.note-content-wrapper');
+        if (!noteWrapper) return;
         
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
-    }
-}
+        noteWrapper.classList.remove('dragover');
+        const noteItem = noteWrapper.closest('.note-item');
+        const noteId = noteItem?.dataset.noteId;
 
-/**
- * Deletes a specific value from an array property
- * @param {string} key - Property key
- * @param {number} arrayIndex - Index of the value to delete
- */
-async function deleteArrayPropertyValue(key, arrayIndex) {
-    const pageIdToUse = currentPageId; // From imported state
-    if (!pageIdToUse) return;
-
-    try {
-        // Get current properties
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        const values = properties[key];
-        
-        if (!Array.isArray(values) || arrayIndex >= values.length) {
-            console.warn(`Invalid array property deletion: ${key}[${arrayIndex}]`);
+        if (!noteId || noteId.startsWith('temp-')) {
+            alert('Please save the note before adding attachments.');
             return;
         }
 
-        // Delete all values for this key
-        await propertiesAPI.deleteProperty('page', pageIdToUse, key);
-        
-        // Re-add all values except the one being deleted
-        const remainingValues = values.filter((_, i) => i !== arrayIndex);
-        for (const value of remainingValues) {
-            await propertiesAPI.setProperty({
-                entity_type: 'page',
-                entity_id: pageIdToUse,
-                name: key,
-                value: value
-            });
-        }
-
-        // Refresh display
-        const updatedProperties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(updatedProperties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error deleting array property value:', error);
-        alert('Failed to delete property value');
-        // Refresh to restore original state
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(properties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
-    }
-}
-
-/**
- * Displays search results in the sidebar
- * @param {Array} results - Search results from the API
- */
-function displaySearchResults(results) {
-    const searchResults = document.getElementById('search-results');
-    
-    if (!results || results.length === 0) {
-        searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
-        searchResults.classList.add('has-results');
-        return;
-    }
-
-    const html = results.map(result => `
-        <div class="search-result-item" data-page-name="${result.page_name}" data-note-id="${result.note_id}">
-            <div class="search-result-title">${result.page_name}</div>
-            <div class="search-result-snippet">${highlightSearchTerms(result.content_snippet, globalSearchInput.value)}</div>
-        </div>
-    `).join('');
+        const files = Array.from(e.dataTransfer.files);
+        if (files.length === 0) return;
 
-    searchResults.innerHTML = html;
-    searchResults.classList.add('has-results');
-
-    // Add click handlers for search results
-    searchResults.addEventListener('click', (e) => {
-        const resultItem = e.target.closest('.search-result-item');
-        if (resultItem) {
-            const pageName = resultItem.dataset.pageName;
-            const noteId = resultItem.dataset.noteId;
-            
-            // Clear search and hide results
-            globalSearchInput.value = '';
-            searchResults.classList.remove('has-results');
-            searchResults.innerHTML = '';
-            
-            // Navigate to the page
-            loadPage(pageName).then(() => {
-                // If there's a specific note ID, try to focus on it
-                if (noteId) {
-                    const noteElement = document.querySelector(`[data-note-id="${noteId}"]`);
-                    if (noteElement) {
-                        noteElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
-                        const contentDiv = noteElement.querySelector('.note-content');
-                        if (contentDiv) {
-                            setTimeout(() => contentDiv.focus(), 100);
-                        }
-                    }
-                }
-            });
-        }
-    });
-}
-
-/**
- * Highlights search terms in text
- * @param {string} text - Text to highlight
- * @param {string} searchTerm - Term to highlight
- * @returns {string} HTML with highlighted terms
- */
-function highlightSearchTerms(text, searchTerm) {
-    if (!searchTerm || !text) return text;
-    
-    const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
-    return text.replace(regex, '<span class="search-result-highlight">$1</span>');
-}
-
-// Page Search Modal Logic
-let allPagesForSearch = [];
-let selectedSearchResultIndex = -1;
-
-async function openSearchOrCreatePageModal() {
-    if (!pageSearchModal || !pageSearchModalInput || !pageSearchModalResults || !pageSearchModalCancel) {
-        console.error('Page search modal elements not found!');
-        return;
-    }
-    try {
-        allPagesForSearch = await pagesAPI.getPages({ excludeJournal: true });
-    } catch (error) {
-        console.error('Failed to fetch pages for search modal:', error);
-        allPagesForSearch = []; // Continue with empty list if fetch fails
-    }
-    pageSearchModalInput.value = '';
-    renderPageSearchResults('');
-    pageSearchModal.classList.add('active');
-    pageSearchModalInput.focus();
-}
-
-function closeSearchOrCreatePageModal() {
-    pageSearchModal.classList.remove('active');
-    selectedSearchResultIndex = -1; // Reset selection
-}
-
-function renderPageSearchResults(query) {
-    if (!pageSearchModalResults) return;
-    pageSearchModalResults.innerHTML = '';
-    selectedSearchResultIndex = -1; // Reset selection on new render
-
-    const filteredPages = allPagesForSearch.filter(page => 
-        page.name.toLowerCase().includes(query.toLowerCase())
-    );
-
-    filteredPages.forEach(page => {
-        const li = document.createElement('li');
-        li.textContent = page.name;
-        li.dataset.pageName = page.name;
-        li.addEventListener('click', () => selectAndActionPageSearchResult(page.name, false));
-        pageSearchModalResults.appendChild(li);
-    });
-
-    // Add "Create page" option if query is not empty and doesn't exactly match an existing page
-    const exactMatch = allPagesForSearch.some(page => page.name.toLowerCase() === query.toLowerCase());
-    if (query.trim() !== '' && !exactMatch) {
-        const li = document.createElement('li');
-        li.classList.add('create-new-option');
-        li.innerHTML = `Create page: <span>"${query}"</span>`;
-        li.dataset.pageName = query; // The name to create
-        li.dataset.isCreate = 'true';
-        li.addEventListener('click', () => selectAndActionPageSearchResult(query, true));
-        pageSearchModalResults.appendChild(li);
-    }
-    
-    // Auto-select first item if any results
-    if (pageSearchModalResults.children.length > 0) {
-        selectedSearchResultIndex = 0;
-        pageSearchModalResults.children[0].classList.add('selected');
-    }
-}
-
-async function selectAndActionPageSearchResult(pageName, isCreate) {
-    closeSearchOrCreatePageModal();
-    if (isCreate) {
+        ui.updateSaveStatusIndicator('pending');
         try {
-            const newPage = await pagesAPI.createPage(pageName);
-            if (newPage && newPage.id) {
-                // Optimistically update the page list
-                if (window.ui && window.ui.domRefs && window.ui.domRefs.pageListContainer) {
-                    const link = document.createElement('a');
-                    link.href = '#';
-                    link.dataset.pageName = newPage.name;
-                    link.textContent = newPage.name;
-                    
-                    // Remove 'active' class from other links and make new one active
-                    const existingLinks = window.ui.domRefs.pageListContainer.querySelectorAll('a');
-                    existingLinks.forEach(existingLink => existingLink.classList.remove('active'));
-                    link.classList.add('active');
-
-                    window.ui.domRefs.pageListContainer.prepend(link); // Prepend to show it at the top
-
-                    // Keep allPagesForSearch in sync
-                    if (window.allPagesForSearch && Array.isArray(window.allPagesForSearch)) {
-                        // Add if not already present (it shouldn't be, as it's a new page)
-                        if (!window.allPagesForSearch.find(p => p.id === newPage.id)) {
-                            window.allPagesForSearch.push(newPage);
-                        }
-                        // Sort allPagesForSearch if necessary, or just add. For simplicity, just adding.
-                    }
-                } else {
-                    // Fallback if optimistic update isn't possible (should not happen ideally)
-                    await fetchAndDisplayPages(newPage.name);
-                }
-                
-                await loadPage(newPage.name, true, true, newPage);
-            } else {
-                alert(`Failed to create page: ${pageName}`);
+            for (const file of files) {
+                const formData = new FormData();
+                formData.append('attachmentFile', file);
+                formData.append('note_id', noteId);
+                await attachmentsAPI.uploadAttachment(formData);
             }
+            // Refresh attachments for the specific note instead of reloading the whole page
+            const attachmentsContainer = noteItem.querySelector('.note-attachments');
+            if(attachmentsContainer) {
+                 await ui.renderAttachments(attachmentsContainer, noteId, true);
+            }
+            ui.updateSaveStatusIndicator('saved');
         } catch (error) {
-            console.error('Error creating page from search modal:', error);
-            alert(`Error creating page: ${error.message}`);
-        }
-    } else {
-        await loadPage(pageName, true);
-    }
-}
-
-// Event Listeners for Page Search Modal
-if (openPageSearchModalBtn) {
-    safeAddEventListener(openPageSearchModalBtn, 'click', openSearchOrCreatePageModal, 'openPageSearchModalBtn');
-}
-
-if (pageSearchModalCancel) {
-    safeAddEventListener(pageSearchModalCancel, 'click', closeSearchOrCreatePageModal, 'pageSearchModalCancel');
-}
-
-const pageSearchModalCloseXBtn = pageSearchModal ? pageSearchModal.querySelector('.modal-close-x') : null;
-if (pageSearchModalCloseXBtn) {
-    safeAddEventListener(pageSearchModalCloseXBtn, 'click', closeSearchOrCreatePageModal, 'pageSearchModalCloseXBtn');
-}
-
-if (pageSearchModalInput) {
-    pageSearchModalInput.addEventListener('input', (e) => {
-        renderPageSearchResults(e.target.value);
-    });
-
-    pageSearchModalInput.addEventListener('keydown', (e) => {
-        const items = pageSearchModalResults.children;
-        if (items.length === 0) return;
-
-        switch (e.key) {
-            case 'ArrowDown':
-                e.preventDefault();
-                if (selectedSearchResultIndex < items.length - 1) {
-                    items[selectedSearchResultIndex]?.classList.remove('selected');
-                    selectedSearchResultIndex++;
-                    items[selectedSearchResultIndex]?.classList.add('selected');
-                }
-                break;
-            case 'ArrowUp':
-                e.preventDefault();
-                if (selectedSearchResultIndex > 0) {
-                    items[selectedSearchResultIndex]?.classList.remove('selected');
-                    selectedSearchResultIndex--;
-                    items[selectedSearchResultIndex]?.classList.add('selected');
-                }
-                break;
-            case 'Enter':
-                e.preventDefault();
-                if (selectedSearchResultIndex !== -1 && items[selectedSearchResultIndex]) {
-                    const selectedItem = items[selectedSearchResultIndex];
-                    selectAndActionPageSearchResult(selectedItem.dataset.pageName, selectedItem.dataset.isCreate === 'true');
-                } else if (pageSearchModalInput.value.trim() !== '') {
-                    // If no item selected but input has text, treat as create new
-                    selectAndActionPageSearchResult(pageSearchModalInput.value.trim(), true);
-                }
-                break;
-            case 'Escape':
-                closeSearchOrCreatePageModal();
-                break;
+            console.error('Error uploading file(s) via drag and drop:', error);
+            alert('File upload failed: ' + error.message);
+            ui.updateSaveStatusIndicator('error');
         }
     });
 }
 
-// Global Ctrl+Space listener
-document.addEventListener('keydown', (e) => {
-    if (e.ctrlKey && e.code === 'Space') {
-        e.preventDefault();
-        openSearchOrCreatePageModal();
-    }
-});
-
-// Start the application
+// --- Application Startup ---
 document.addEventListener('DOMContentLoaded', async () => {
-    // Ensure UI module is loaded
-    if (typeof ui === 'undefined') {
-        console.error('UI module not loaded. Please check script loading order.');
+    if (typeof ui === 'undefined' || !notesContainer) {
+        console.error('UI module or critical DOM elements not loaded. Application cannot start.');
+        document.body.innerHTML = '<h1>Application failed to start. Please check the console.</h1>';
         return;
     }
     
     try {
         await initializeApp();
+        initPropertyEditor(); // Initialize listeners for the property modal
+        ui.initializeDelegatedNoteEventListeners(notesContainer); // **FIXED**: Call the main event initializer
+        ui.calendarWidget.init(); // Initialize the calendar widget
     } catch (error) {
         console.error('Failed to initialize application:', error);
-        // Show error in UI if needed
-    }
-});
-
-// Add drag-and-drop file handling
-notesContainer.addEventListener('dragover', (e) => {
-    e.preventDefault();
-    const noteItem = e.target.closest('.note-item');
-    if (noteItem) {
-        noteItem.classList.add('drag-over');
+        document.body.innerHTML = `<h1>Application Initialization Failed</h1><p>${error.message}</p><p>Check the console for more details.</p>`;
     }
 });
-
-notesContainer.addEventListener('dragleave', (e) => {
-    const noteItem = e.target.closest('.note-item');
-    if (noteItem) {
-        noteItem.classList.remove('drag-over');
-    }
-});
-
-notesContainer.addEventListener('drop', async (e) => {
-    e.preventDefault();
-    const noteItem = e.target.closest('.note-item');
-    if (!noteItem) return;
-    
-    noteItem.classList.remove('drag-over');
-    const noteId = noteItem.dataset.noteId;
-    if (!noteId || noteId.startsWith('temp-')) return;
-
-    const files = Array.from(e.dataTransfer.files);
-    if (files.length === 0) return;
-
-    const uploadPromises = files.map(async (file) => {
-        const formData = new FormData();
-        formData.append('attachmentFile', file);
-        formData.append('note_id', noteId);
-
-        try {
-            const result = await attachmentsAPI.uploadAttachment(formData);
-            console.log('File uploaded via drag and drop:', result);
-            return result;
-        } catch (error) {
-            console.error('Error uploading file:', error);
-            return null;
-        }
-    });
-
-    try {
-        const results = await Promise.all(uploadPromises);
-        const successfulUploads = results.filter(r => r !== null);
-        
-        if (successfulUploads.length > 0) {
-            // Refresh the note to show new attachments
-            const pageIdToUse = currentPageId; // From imported state
-            if (!pageIdToUse) return; // Should not happen if note exists
-            const freshNotes = await notesAPI.getNotesForPage(pageIdToUse);
-            setNotesForCurrentPage(freshNotes);
-
-            ui.displayNotes(notesForCurrentPage, pageIdToUse);
-
-            const focusedNoteId = currentFocusedNoteId; // From imported state
-            if (focusedNoteId) {
-                const focusedNoteStillExists = notesForCurrentPage.some(n => String(n.id) === String(focusedNoteId));
-                if (focusedNoteStillExists) {
-                    ui.focusOnNote(focusedNoteId);
-                } else {
-                    ui.showAllNotes();
-                }
-            }
-        }
-    } catch (error) {
-        console.error('Error handling file uploads:', error);
-    }
-});
-
-/**
- * Adds a new page property
- * @param {string} key - Property key
- * @param {string} value - Property value
- */
-async function addPageProperty(key, value) {
-    const pageIdToUse = currentPageId; // From imported state
-    if (!pageIdToUse) return;
-
-    try {
-        await propertiesAPI.setProperty({
-            entity_type: 'page',
-            entity_id: pageIdToUse,
-            name: key,
-            value: value
-        });
-
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(properties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error adding page property:', error);
-        alert('Failed to add property');
-    }
-}
-
-/**
- * Updates a page property
- * @param {string} key - Property key
- * @param {string} value - New property value
- */
-async function updatePageProperty(key, value) {
-    const pageIdToUse = currentPageId; // From imported state
-    if (!pageIdToUse) return;
-
-    try {
-        await propertiesAPI.setProperty({
-            entity_type: 'page',
-            entity_id: pageIdToUse,
-            name: key,
-            value: value
-        });
-
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(properties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error updating page property:', error);
-        alert('Failed to update property');
-    }
-}
-
-/**
- * Deletes a page property
- * @param {string} key - Property key to delete
- */
-async function deletePageProperty(key) {
-    const pageIdToUse = currentPageId; // From imported state
-    if (!pageIdToUse) return;
-
-    try {
-        await propertiesAPI.deleteProperty('page', pageIdToUse, key);
-        const properties = await propertiesAPI.getProperties('page', pageIdToUse);
-        displayPageProperties(properties);
-        
-        // Also update inline properties display
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error deleting page property:', error);
-        alert('Failed to delete property');
-    }
-}
-
-/**
- * Updates the visual save status indicator based on the global saveStatus.
- */
-function updateSaveStatusIndicatorVisuals() {
-    const indicator = document.getElementById('save-status-indicator');
-    if (!indicator) {
-        console.warn('Save status indicator element not found.');
-        return;
-    }
-
-    // Global saveStatus (already updated by a setter) is used here for visuals
-    const currentSaveStatus = saveStatus; 
-
-    const splashScreen = document.getElementById('splash-screen');
-    const isSplashVisible = splashScreen && !splashScreen.classList.contains('hidden');
-
-    if (isSplashVisible) {
-        indicator.classList.add('status-hidden');
-        indicator.innerHTML = ''; // Clear content when hidden by splash
-        return;
-    } else {
-        indicator.classList.remove('status-saved', 'status-pending', 'status-error');
-        indicator.classList.add(`status-${currentSaveStatus}`);
-    }
-
-    let iconHtml = '';
-    switch (currentSaveStatus) {
-        case 'saved':
-            iconHtml = '<i data-feather="check-circle"></i>';
-            indicator.title = 'All changes saved';
-            break;
-        case 'pending':
-            iconHtml = `
-                <div class="dot-spinner">
-                    <div class="dot-spinner__dot"></div>
-                    <div class="dot-spinner__dot"></div>
-                    <div class="dot-spinner__dot"></div>
-                </div>`;
-            indicator.title = 'Saving changes...';
-            break;
-        case 'error':
-            iconHtml = '<i data-feather="alert-triangle"></i>';
-            indicator.title = 'Error saving changes. Please try again.';
-            break;
-        default: 
-            console.warn(`Unknown save status: ${currentSaveStatus}. Defaulting visual to 'saved'.`);
-            indicator.classList.remove('status-pending', 'status-error'); 
-            indicator.classList.add(`status-saved`);
-            iconHtml = '<i data-feather="check-circle"></i>';
-            indicator.title = 'All changes saved';
-            break;
-    }
-    indicator.innerHTML = iconHtml;
-
-    if (currentSaveStatus === 'saved' || currentSaveStatus === 'error') {
-        if (typeof feather !== 'undefined' && feather.replace) {
-            feather.replace({
-                width: '18px',
-                height: '18px',
-                'stroke-width': '2' 
-            });
-        } else {
-            console.warn('Feather Icons library not found. Icons for "saved" or "error" status might not render.');
-            if (currentSaveStatus === 'saved') indicator.textContent = ''; 
-            if (currentSaveStatus === 'error') indicator.textContent = '!'; 
-        }
-    }
-}
\ No newline at end of file
diff --git a/assets/js/app/app-init.js b/assets/js/app/app-init.js
index 5068200..df19f27 100644
--- a/assets/js/app/app-init.js
+++ b/assets/js/app/app-init.js
@@ -4,8 +4,7 @@
  */
 
 // State imports
-import { notesForCurrentPage, currentPageName, saveStatus, setSaveStatus } from './state.js';
-import { debounce } from '../utils.js';
+import { setSaveStatus } from './state.js';
 
 // Module initializers and core functions
 import { sidebarState } from './sidebar.js';
@@ -13,66 +12,90 @@ import { loadPage, prefetchRecentPagesData, getInitialPage, fetchAndDisplayPages
 import { initGlobalEventListeners } from './event-handlers.js';
 import { initGlobalSearch, initPageSearchModal } from './search.js';
 import { initSuggestionUI, fetchAllPages } from '../ui/page-link-suggestions.js';
+import { pagesAPI } from '../api_client.js'; // Import pagesAPI
 
 // Import UI module
 import { ui } from '../ui.js';
 
-async function initializeApp() {
+// Expose page creation function globally for modules like calendar-widget
+window.createPageWithContent = async (pageName, initialContent = '') => {
+    try {
+        const newPage = await pagesAPI.createPage(pageName, initialContent);
+        if (newPage && newPage.id) {
+            await loadPage(newPage.name, true);
+            return true;
+        } else {
+            console.error('Failed to create page: Invalid response from API');
+            return false;
+        }
+    } catch (error) {
+        console.error('Error creating page:', error);
+        alert(`Error creating page: ${error.message}`);
+        return false;
+    }
+};
+
+/**
+ * Initializes the entire application.
+ * This function sets up UI components, event listeners, and loads the initial page.
+ */
+export async function initializeApp() {
     const splashScreen = document.getElementById('splash-screen');
     if (splashScreen) splashScreen.classList.remove('hidden'); 
     
     try {
+        // Initialize sidebars
         sidebarState.init(); 
         
-        // Initialize UI components
-        if (typeof ui !== 'undefined') {
-            ui.initPagePropertiesModal();
-            ui.updateSaveStatusIndicator('saved');
-        } else {
-            console.error("UI module not loaded. Please check script loading order.");
-            return;
-        }
+        // Initialize UI components and modals
+        ui.initPagePropertiesModal();
+        ui.updateSaveStatusIndicator('saved');
         
+        // Initialize search functionalities
         initGlobalSearch();
         initPageSearchModal();
+        
+        // Set up global event listeners (e.g., popstate, keyboard shortcuts)
         initGlobalEventListeners();
         
-        // Initialize page link suggestions
+        // Initialize the UI for page link suggestions `[[...]]`
         initSuggestionUI();
-        fetchAllPages(); // Asynchronously fetch page names
+        // Asynchronously fetch all page names for the suggestion cache
+        fetchAllPages(); 
         
+        // Determine the initial page to load from URL or default
         const urlParams = new URLSearchParams(window.location.search);
         const initialPageName = urlParams.get('page') || getInitialPage(); 
         
+        // Load the main page content
         await loadPage(initialPageName, false); 
+        // Fetch and display the list of recent pages in the sidebar
         await fetchAndDisplayPages(initialPageName);
         
+        // Pre-fetch data for other recent pages in the background
         await prefetchRecentPagesData(); 
         
+        // Hide the initial save indicator until a change is made
         const initialSaveIndicator = document.getElementById('save-status-indicator');
         if (initialSaveIndicator) {
             initialSaveIndicator.classList.add('status-hidden'); 
         }
         
+        console.log('App initialized successfully');
+        
+    } catch (error) { 
+        console.error('Failed to initialize application:', error);
+        // Ensure splash screen is hidden on error to show error message
+        if (splashScreen) splashScreen.classList.add('hidden');
+        // Provide feedback to the user in case of a critical initialization failure
+        document.body.innerHTML = `<div style="padding: 20px; text-align: center;"><h1>App Initialization Failed</h1><p>${error.message}</p><p>Check console for details.</p></div>`;
+    } finally {
+        // Ensure the splash screen is always hidden after initialization attempt
         if (splashScreen) {
             if (window.splashAnimations && typeof window.splashAnimations.stop === 'function') {
                 window.splashAnimations.stop();
             }
             splashScreen.classList.add('hidden');
         }
-        console.log('App initialized successfully');
-        
-    } catch (error) { 
-        console.error('Failed to initialize application:', error);
-        if (splashScreen && typeof window.splashAnimations !== 'undefined' && typeof window.splashAnimations.stop === 'function') {
-            window.splashAnimations.stop(); 
-        }
-        if(splashScreen) splashScreen.classList.add('hidden');
-        if (document.body) {
-            document.body.innerHTML = '<div style="padding: 20px; text-align: center;"><h1>App Initialization Failed</h1><p>' + error.message + '</p>Check console for details.</div>';
-        }
     }
-}
-
-// Export the initializeApp function
-export { initializeApp };
+}
\ No newline at end of file
diff --git a/assets/js/app/note-actions.js b/assets/js/app/note-actions.js
index 4393459..e2135e3 100644
--- a/assets/js/app/note-actions.js
+++ b/assets/js/app/note-actions.js
@@ -1,11 +1,7 @@
-// assets_js_app_note-actions.js
-
 /**
  * @file Manages note-related actions such as creation, updates, deletion,
- * indentation, and interaction handling (keyboard, clicks).
- * It orchestrates optimistic UI updates, local state management,
- * and communication with the backend API, primarily using batch operations
- * for structural changes.
+ * indentation, and interaction handling (keyboard, clicks). It orchestrates
+ * optimistic UI updates and communication with the backend API using batch operations.
  */
 
 import {
@@ -15,910 +11,313 @@ import {
     updateNoteInCurrentPage,
     removeNoteFromCurrentPageById,
     setNotesForCurrentPage,
-    // saveStatus, // UI state, managed by ui.js via updateSaveStatusIndicator
 } from './state.js';
 
 import { calculateOrderIndex } from './order-index-service.js';
-import { notesAPI, propertiesAPI } from '../api_client.js';
-import { debounce } from '../utils.js';
-// import { handleNoteDrop } from '../ui/note-elements.js'; // For Sortable.js, if used
+import { notesAPI } from '../api_client.js';
+import { debounce, handleAutocloseBrackets, insertTextAtCursor, encrypt } from '../utils.js';
+import { ui } from '../ui.js';
 
 const notesContainer = document.querySelector('#notes-container');
 
-// --- Property Parsing Utility ---
-/**
- * Parses explicit properties (key::value) from text content.
- * @param {string} textContent - The text content of the note.
- * @returns {object} - An object where keys are property names and values are arrays of strings.
- */
-export function parsePropertiesFromText(textContent) {
-    const properties = {};
-    const regex = /\{([^:}]+)::([^}]+)\}/g; // Matches {key::value}
-    let match;
-    while ((match = regex.exec(textContent)) !== null) {
-        const key = match[1].trim();
-        const value = match[2].trim();
-        if (!properties[key]) {
-            properties[key] = [];
-        }
-        properties[key].push(value);
-    }
-    return properties;
-}
-
-// --- Helper functions for text manipulation ---
-/**
- * Inserts text at the current cursor position and positions cursor.
- * @param {string} text - Text to insert.
- * @param {number} [cursorOffset=0] - Position cursor relative to start of inserted text.
- */
-function insertTextAtCursor(text, cursorOffset = 0) {
-    const selection = window.getSelection();
-    if (!selection || selection.rangeCount === 0) return;
-    const range = selection.getRangeAt(0);
-    const textNode = document.createTextNode(text);
-    range.insertNode(textNode);
-    range.setStart(textNode, cursorOffset);
-    range.setEnd(textNode, cursorOffset);
-    selection.removeAllRanges();
-    selection.addRange(range);
-}
-
-/**
- * Replaces text by deleting characters before cursor and inserting new text.
- * @param {number} deleteCount - Number of characters to delete before cursor.
- * @param {string} newText - Text to insert.
- * @param {number} [cursorOffset=0] - Position cursor relative to start of inserted text.
- */
-function replaceTextAtCursor(deleteCount, newText, cursorOffset = 0) {
-    const selection = window.getSelection();
-    if (!selection || selection.rangeCount === 0) return;
-    const range = selection.getRangeAt(0);
-    if (range.startOffset < deleteCount) { // Ensure we don't delete beyond the start
-        deleteCount = range.startOffset;
-    }
-    range.setStart(range.startContainer, range.startOffset - deleteCount);
-    range.deleteContents();
-    const textNode = document.createTextNode(newText);
-    range.insertNode(textNode);
-    // Ensure cursorOffset is within the bounds of the new textNode
-    const finalCursorOffset = Math.min(cursorOffset, textNode.length);
-    range.setStart(textNode, finalCursorOffset);
-    range.setEnd(textNode, finalCursorOffset);
-    selection.removeAllRanges();
-    selection.addRange(range);
-}
-
 // --- Note Data Accessors ---
-/**
- * Retrieves note data from the current page's state by its ID.
- * @param {string|number} noteId - The ID of the note to retrieve.
- * @returns {Object|null} The note object if found, otherwise null.
- */
 export function getNoteDataById(noteId) {
     if (!noteId) return null;
     return notesForCurrentPage.find(n => String(n.id) === String(noteId));
 }
 
-/**
- * Retrieves the DOM element for a note by its ID.
- * @param {string|number} noteId - The ID of the note element to retrieve.
- * @returns {HTMLElement|null} The note's DOM element if found, otherwise null.
- */
 export function getNoteElementById(noteId) {
     if (!notesContainer || !noteId) return null;
     return notesContainer.querySelector(`.note-item[data-note-id="${noteId}"]`);
 }
 
-/**
- * Helper function to update a newly created note (optimistically added with a temp ID)
- * with its permanent ID and server data, in both local state and DOM.
- * @param {string} clientTempId - The temporary ID used by the client.
- * @param {Object} noteFromServer - The note object received from the server, containing the permanent ID.
- */
 function _finalizeNewNote(clientTempId, noteFromServer) {
     if (!noteFromServer || !noteFromServer.id) {
         console.error("[_finalizeNewNote] Invalid note data from server for temp ID:", clientTempId, noteFromServer);
-        // Optionally, trigger a revert or error state if finalization fails critically
         return;
     }
     const permanentId = noteFromServer.id;
-    console.log(`[_finalizeNewNote] Finalizing note. Temp ID: ${clientTempId}, Permanent ID: ${permanentId}`);
 
-    // Update local state: Find the note by temp ID and update it with server data, ensuring permanent ID.
     const noteIndex = notesForCurrentPage.findIndex(n => String(n.id) === String(clientTempId));
     if (noteIndex > -1) {
-        // Merge server data into the existing optimistic note, making sure 'id' is the permanent one.
-        // Also, ensure client_temp_id is removed or handled if it was part of notesForCurrentPage[noteIndex].
-        const existingOptimisticNote = notesForCurrentPage[noteIndex];
-        notesForCurrentPage[noteIndex] = { 
-            ...existingOptimisticNote, // Keep any client-side optimistic fields not yet on server
-            ...noteFromServer,         // Override with server data
-            id: permanentId            // Explicitly set permanent ID
-        };
-        // If 'client_temp_id' was a property on the state object, remove it after finalization:
-        // delete notesForCurrentPage[noteIndex].client_temp_id;
+        notesForCurrentPage[noteIndex] = { ...notesForCurrentPage[noteIndex], ...noteFromServer, id: permanentId };
     } else {
         console.warn(`[_finalizeNewNote] Could not find note with temp ID ${clientTempId} in local state to finalize.`);
-        // This might indicate an issue, e.g., the note was removed before finalization.
-        // Depending on strategy, you might re-add it here if it's guaranteed to exist.
-        // addNoteToCurrentPage({ ...noteFromServer, id: permanentId }); // If it should be added if missing
     }
 
-    // Update DOM element's dataset.noteId
     const tempNoteEl = getNoteElementById(clientTempId);
     if (tempNoteEl) {
         tempNoteEl.dataset.noteId = permanentId;
-        const contentDiv = tempNoteEl.querySelector('.note-content');
-        if (contentDiv) contentDiv.dataset.noteId = permanentId;
-        const bulletEl = tempNoteEl.querySelector('.note-bullet');
-        if (bulletEl) bulletEl.dataset.noteId = permanentId;
-    } else {
-        console.warn(`[_finalizeNewNote] Could not find DOM element for temp ID ${clientTempId} to update dataset.`);
+        tempNoteEl.querySelector('.note-content')?.setAttribute('data-note-id', permanentId);
+        tempNoteEl.querySelector('.note-bullet')?.setAttribute('data-note-id', permanentId);
     }
 }
 
-
-/**
- * Executes a batch of note operations with optimistic updates and revert logic.
- * Assumes `notesAPI.batchUpdateNotes` returns the array of individual operation results directly,
- * or throws an error if the API call fails or the response structure is invalid.
- *
- * @param {Array<Object>} originalNotesState - A deep clone of the `notesForCurrentPage` state *before* any optimistic changes were made.
- * @param {Array<Object>} operations - Array of operations for the batch API.
- *                                   Each operation: { type: 'create'|'update'|'delete', payload: Object }
- * @param {Function} optimisticDOMUpdater - A function to call to perform optimistic DOM updates.
- *                                          It is called after local state updates.
- * @param {string} userActionName - Name of the user action for logging/error messages (e.g., "Add Root Note").
- * @returns {Promise<boolean>} True if all operations were successful (or no operations), false otherwise.
- */
 async function executeBatchOperations(originalNotesState, operations, optimisticDOMUpdater, userActionName) {
-    if (!operations || operations.length === 0) {
-        console.warn(`[${userActionName} BATCH] No operations to execute.`);
-        // Consider returning true as no operations means no failures.
-        return true;
-    }
+    if (!operations || operations.length === 0) return true;
 
-    window.ui.updateSaveStatusIndicator('pending');
-    // The state backup is now passed in as `originalNotesState`.
-    // Callers (handleAddRootNote, etc.) are responsible for cloning the state BEFORE making optimistic changes.
-    // This function handles DOM updates and API communication/revert.
+    ui.updateSaveStatusIndicator('pending');
     let success = false;
 
     try {
-        // 1. Perform Optimistic DOM Updates (call the provided function)
-        //    This is called AFTER the caller has made optimistic state changes.
-        if (typeof optimisticDOMUpdater === 'function') {
-            optimisticDOMUpdater();
-        } else {
-            console.warn(`[${userActionName} BATCH] No optimisticDOMUpdater function provided.`);
-        }
-
-        // 2. API Call
-        console.log(`[${userActionName} BATCH] Sending operations:`, JSON.stringify(operations, null, 2));
-        // `batchResultsArray` is now expected to be the direct array of operation results,
-        // or an error would have been thrown by `notesAPI.batchUpdateNotes` (in api_client.js).
-        const batchResultsArray = await notesAPI.batchUpdateNotes(operations);
-        console.log(`[${userActionName} BATCH] API results array received:`, batchResultsArray);
-
-        // 3. Process Individual Results
-        //    (Though `notesAPI.batchUpdateNotes` should throw if the overall structure is bad,
-        //     we still check individual operation statuses for robustness)
-        if (!Array.isArray(batchResultsArray)) {
-            // This case should ideally be caught by the modified notesAPI.batchUpdateNotes in api_client.js
-            throw new Error(`[${userActionName} BATCH] notesAPI.batchUpdateNotes did not return an array as expected.`);
-        }
-
+        if (typeof optimisticDOMUpdater === 'function') optimisticDOMUpdater();
+        const batchResponse = await notesAPI.batchUpdateNotes(operations);
         let allSubOperationsSucceeded = true;
-        batchResultsArray.forEach(opResult => {
-            // Validate each operation result object
-            if (!opResult || typeof opResult !== 'object') {
-                console.error(`[${userActionName} BATCH] Invalid operation result item:`, opResult);
-                allSubOperationsSucceeded = false;
-                return; // Skip to next opResult
-            }
-
-            if (opResult.status === 'error') {
-                allSubOperationsSucceeded = false;
-                const idForError = opResult.payload_identifier?.id || opResult.id || opResult.client_temp_id || 'N/A';
-                console.error(`[${userActionName} BATCH] Server reported sub-operation error: Type: ${opResult.type || 'Unknown'}, Identifier: ${idForError}, Message: ${opResult.error_message || opResult.message || 'Unknown sub-operation error'}`);
-            }
-
-            if (!allSubOperationsSucceeded) return; // Stop processing if one failed
-
-            const noteFromServer = opResult.note;       // Expected for 'create' and 'update'
-            const clientTempId = opResult.client_temp_id; // Expected for 'create' if sent by client
-            const deletedNoteId = opResult.deleted_note_id; // Expected for 'delete'
-
-            if (opResult.type === 'create' && clientTempId && noteFromServer) {
-                _finalizeNewNote(clientTempId, noteFromServer);
-            } else if (opResult.type === 'update' && noteFromServer) {
-                updateNoteInCurrentPage(noteFromServer);
-                // Optionally, trigger a targeted DOM update for this specific note if its properties changed
-                // e.g., if (window.ui.updateNoteElement) window.ui.updateNoteElement(noteFromServer.id, noteFromServer);
-            } else if (opResult.type === 'delete' && deletedNoteId) {
-                // Local state removal was optimistic and done by the caller. This is a server confirmation.
-                console.log(`[${userActionName} BATCH] Confirmed deletion of note ID: ${deletedNoteId}`);
-            } else if (opResult.status === 'success') {
-                // A successful operation type not covered above (e.g. a 'read' if batch ever supports it)
-                console.log(`[${userActionName} BATCH] Successfully processed unhandled operation type: ${opResult.type}`);
-            }
-        });
-
-        if (!allSubOperationsSucceeded) {
-            // If any sub-operation failed (as reported by server within a 2xx response),
-            // treat it as an overall failure needing a revert.
-            throw new Error(`One or more sub-operations in '${userActionName}' failed on the server side.`);
+        
+        // **FIXED**: The API client now returns the object containing the results array.
+        // We must iterate over `batchResponse.results`.
+        if (batchResponse && Array.isArray(batchResponse.results)) {
+            batchResponse.results.forEach(opResult => {
+                if (opResult.status === 'error') {
+                    allSubOperationsSucceeded = false;
+                    console.error(`[${userActionName} BATCH] Server reported sub-operation error:`, opResult);
+                } else if (opResult.type === 'create' && opResult.client_temp_id) {
+                    _finalizeNewNote(opResult.client_temp_id, opResult.note);
+                } else if (opResult.type === 'update' && opResult.note) {
+                    updateNoteInCurrentPage(opResult.note);
+                }
+            });
+        } else {
+            allSubOperationsSucceeded = false;
+            console.error(`[${userActionName} BATCH] Invalid response structure from server:`, batchResponse);
         }
 
+        if (!allSubOperationsSucceeded) throw new Error(`One or more sub-operations in '${userActionName}' failed.`);
         success = true;
-        window.ui.updateSaveStatusIndicator('saved');
-
-    } catch (error) { // Catches errors from API call, or errors thrown from processing results
-        const errorMessage = error.message || `Batch operation '${userActionName}' failed.`;
-        console.error(`[${userActionName} BATCH] Overall error: ${errorMessage}`, error.stack ? `\nStack: ${error.stack}` : '');
-        
-        // User feedback
-        alert(`${errorMessage} Reverting local changes.`);
-        window.ui.updateSaveStatusIndicator('error');
-
-        // Revert local state to the state *before* the caller made its optimistic changes
+        ui.updateSaveStatusIndicator('saved');
+    } catch (error) {
+        alert(`${error.message || `Batch operation '${userActionName}' failed.`} Reverting local changes.`);
+        ui.updateSaveStatusIndicator('error');
         setNotesForCurrentPage(originalNotesState);
-
-        // Re-render the entire notes list from the reverted state
-        if (window.ui && typeof window.ui.displayNotes === 'function' && currentPageId) {
-            window.ui.displayNotes(notesForCurrentPage, currentPageId);
-            // TODO: Consider re-focusing the element that triggered the action.
-            // This is complex because the element might no longer exist or might have a different ID/state.
-            // Example: if a new note creation failed, the temporary note element is gone.
-            // If an indent failed, the original note element might need to be focused.
-        } else {
-            console.warn(`[${userActionName} BATCH] Could not re-render notes after batch failure. UI might be inconsistent.`);
-        }
+        ui.displayNotes(notesForCurrentPage, currentPageId);
         success = false;
-    } finally {
-        // Always ensure the current local state (either successfully updated or reverted) is sorted.
-        notesForCurrentPage.sort((a, b) => (a.order_index || 0) - (b.order_index || 0));
     }
     return success;
 }
 
+// --- Note Saving Logic ---
 
-// --- Note Saving Logic (Single Note - for content edits, tasks) ---
-/**
- * Saves a single note's content and properties to the server.
- * Used for debounced saves or immediate saves of content changes.
- * @param {string} noteId - The ID of the note. Must be a permanent ID.
- * @param {string} rawContent - The raw string content of the note.
- * @param {boolean} [isImmediateSave=false] - Flag for logging/differentiating save type.
- * @returns {Promise<Object|null>} The updated note object from the server, or null if save failed.
- */
-async function _saveNoteToServer(noteId, rawContent, isImmediateSave = false) {
-    if (String(noteId).startsWith('temp-')) {
-        console.warn(`[_saveNoteToServer] Attempted to save note with temporary ID: ${noteId}. This should be part of a batch create or update after ID assignment.`);
-        return null;
+async function _saveNoteToServer(noteId, rawContent) {
+    if (String(noteId).startsWith('temp-')) return null;
+    
+    // Prepare the content for saving, including encryption if applicable
+    let contentToSave = rawContent;
+    if (window.decryptionPassword) {
+        contentToSave = encrypt(rawContent, window.decryptionPassword);
     }
-    const saveType = isImmediateSave ? "IMMEDIATE" : "DEBOUNCED";
-    window.ui.updateSaveStatusIndicator('pending');
-    try {
-        const explicitProperties = parsePropertiesFromText(rawContent);
-        let contentToSave = rawContent;
 
-        if (window.currentPageEncryptionKey && window.decryptionPassword) {
-            contentToSave = sjcl.encrypt(window.decryptionPassword, rawContent);
-            if (!explicitProperties.encrypted) explicitProperties.encrypted = [];
-            if (!explicitProperties.encrypted.includes('true')) explicitProperties.encrypted.push('true');
-        }
-        
-        const updatePayload = { 
-            page_id: currentPageId,
-            content: contentToSave,
-            properties_explicit: explicitProperties
-        };
-        
-        const updatedNote = await notesAPI.updateNote(noteId, updatePayload); // Uses single update API
-        
-        // It's unlikely a backend would change an ID on update, but this handles it.
-        if (String(updatedNote.id) !== String(noteId)) {
-             console.warn(`[_saveNoteToServer] Note ID changed by server from ${noteId} to ${updatedNote.id}. This is unusual for an update.`);
-            // If this happens, need to update the ID in notesForCurrentPage and DOM.
-            const noteIndex = notesForCurrentPage.findIndex(n => String(n.id) === String(noteId));
-            if (noteIndex > -1) notesForCurrentPage[noteIndex].id = updatedNote.id;
-            const noteEl = getNoteElementById(noteId); 
-            if (noteEl) {
-                noteEl.dataset.noteId = updatedNote.id;
-                noteEl.querySelector('.note-content')?.setAttribute('data-note-id', updatedNote.id);
-                noteEl.querySelector('.note-bullet')?.setAttribute('data-note-id', updatedNote.id);
-            }
-        }
-        
-        updateNoteInCurrentPage(updatedNote); 
-        if (window.ui && typeof window.ui.updateNoteElement === 'function') {
-            window.ui.updateNoteElement(updatedNote.id, updatedNote);
+    const originalNotesState = JSON.parse(JSON.stringify(notesForCurrentPage));
+
+    const operations = [{
+        type: 'update',
+        payload: {
+            id: noteId,
+            page_id: currentPageId, // Ensure page_id is sent for context if needed by backend
+            content: contentToSave
         }
-        window.ui.updateSaveStatusIndicator('saved');
-        return updatedNote;
-    } catch (error) {
-        console.error(`_saveNoteToServer (${saveType}): Error updating note ${noteId}. Error:`, error);
-        window.ui.updateSaveStatusIndicator('error');
-        // Avoid alert for non-critical background saves; status indicator is primary feedback.
-        return null;
-    }
+    }];
+
+    // Using executeBatchOperations for consistency and error handling
+    const success = await executeBatchOperations(originalNotesState, operations, () => {
+        // Optimistic DOM update for content is handled elsewhere (e.g., when typing stops)
+        // This save operation only ensures the data is sent to the server.
+        // updateNoteInCurrentPage is called by executeBatchOperations on success via opResult.note
+    }, "Save Note Content");
+
+    return success ? getNoteDataById(noteId) : null;
 }
 
-/**
- * Immediately saves the content of a note element.
- * @param {HTMLElement} noteEl - The note's DOM element.
- * @returns {Promise<Object|null>} The updated note object from server or null.
- */
 export async function saveNoteImmediately(noteEl) {
     const noteId = noteEl.dataset.noteId;
-    if (String(noteId).startsWith('temp-')) {
-        console.warn("[saveNoteImmediately] Attempted to save note with temporary ID:", noteId);
-        return null;
-    }
+    if (String(noteId).startsWith('temp-')) return null;
     const contentDiv = noteEl.querySelector('.note-content');
     if (!contentDiv) return null;
-
-    const rawTextValue = window.ui.getRawTextWithNewlines(contentDiv);
-    const rawContent = window.ui.normalizeNewlines(rawTextValue);
-    contentDiv.dataset.rawContent = rawContent; // Ensure dataset is up-to-date
-    return await _saveNoteToServer(noteId, rawContent, true);
+    
+    const rawContent = ui.normalizeNewlines(ui.getRawTextWithNewlines(contentDiv));
+    contentDiv.dataset.rawContent = rawContent;
+    return await _saveNoteToServer(noteId, rawContent);
 }
 
-/**
- * Debounced function to save a note's content.
- * @param {HTMLElement} noteEl - The note's DOM element.
- */
 export const debouncedSaveNote = debounce(async (noteEl) => {
     const noteId = noteEl.dataset.noteId;
     if (String(noteId).startsWith('temp-')) return;
-
     const contentDiv = noteEl.querySelector('.note-content');
     if (!contentDiv) return;
     
-    // For debounced save, rely on dataset.rawContent which should be updated on input/blur
     const currentRawContent = contentDiv.dataset.rawContent || '';
-    const noteData = getNoteDataById(noteId);
-
-    // If note content hasn't changed, skip.
-    if (noteData && noteData.content === currentRawContent) {
-        if (window.ui && typeof window.ui.getSaveStatus === 'function' && window.ui.getSaveStatus() !== 'saved') {
-            window.ui.updateSaveStatusIndicator('saved');
-        }
-        return;
-    }
-    await _saveNoteToServer(noteId, currentRawContent, false);
-}, 1000); // 1-second debounce
-
+    await _saveNoteToServer(noteId, currentRawContent);
+}, 1000);
 
-// --- Event Handlers for Structural Changes (Using Batch API) ---
+// --- Event Handlers for Structural Changes ---
 
-/**
- * Handles adding a new root-level note to the current page.
- */
 export async function handleAddRootNote() {
-    const pageIdToUse = currentPageId;
-    if (!pageIdToUse) {
-        alert('Please select or create a page first.');
-        return;
-    }
-
+    if (!currentPageId) return;
     const clientTempId = `temp-R-${Date.now()}`;
-    const operations = [];
-
-    // --- State backup MUST happen BEFORE any optimistic updates ---
     const originalNotesState = JSON.parse(JSON.stringify(notesForCurrentPage));
-
-    const rootNotes = notesForCurrentPage
-        .filter(n => !n.parent_note_id)
-        .sort((a, b) => (a.order_index || 0) - (b.order_index || 0));
-    const previousSiblingId = rootNotes.length > 0 ? String(rootNotes[rootNotes.length - 1].id) : null;
-    const { targetOrderIndex, siblingUpdates } = calculateOrderIndex(notesForCurrentPage, null, previousSiblingId, null);
-
-    const optimisticNewNote = {
-        id: clientTempId, page_id: pageIdToUse, content: '', parent_note_id: null,
-        order_index: targetOrderIndex, created_at: new Date().toISOString(), updated_at: new Date().toISOString(),
-        properties: {}, client_temp_id: clientTempId // Important for UI mapping
-    };
-    addNoteToCurrentPage(optimisticNewNote); // Optimistic state update
-
-    operations.push({
-        type: 'create',
-        payload: {
-            page_id: pageIdToUse, content: '', parent_note_id: null,
-            order_index: targetOrderIndex, client_temp_id: clientTempId
-        }
-    });
-
-    siblingUpdates.forEach(update => {
-        const noteToUpdate = getNoteDataById(update.id);
-        if (noteToUpdate) updateNoteInCurrentPage({ ...noteToUpdate, order_index: update.newOrderIndex });
-        operations.push({
-            type: 'update',
-            payload: { id: update.id, page_id: pageIdToUse, order_index: update.newOrderIndex }
-        });
+    const rootNotes = notesForCurrentPage.filter(n => !n.parent_note_id);
+    const lastRootNote = rootNotes.sort((a, b) => (a.order_index || 0) - (b.order_index || 0)).pop();
+    const { targetOrderIndex, siblingUpdates } = calculateOrderIndex(notesForCurrentPage, null, lastRootNote?.id || null, null);
+    
+    const optimisticNewNote = { id: clientTempId, page_id: currentPageId, content: '', parent_note_id: null, order_index: targetOrderIndex, properties: {} };
+    addNoteToCurrentPage(optimisticNewNote);
+    
+    const operations = [{ type: 'create', payload: { page_id: currentPageId, content: '', parent_note_id: null, order_index: targetOrderIndex, client_temp_id: clientTempId } }];
+    siblingUpdates.forEach(upd => operations.push({ type: 'update', payload: { id: upd.id, order_index: upd.newOrderIndex } }));
+    
+    // Optimistically update local state for siblings
+    siblingUpdates.forEach(upd => {
+        const note = getNoteDataById(upd.id);
+        if(note) note.order_index = upd.newOrderIndex;
     });
-    // Local state sorting will be handled by executeBatchOperations.finally or after optimisticDOMUpdater
 
     const optimisticDOMUpdater = () => {
-        notesForCurrentPage.sort((a,b) => (a.order_index || 0) - (b.order_index || 0)); // Sort before DOM update
-        // Sibling DOM elements might need reordering here if not handled by addNoteElement implicitly
-        // For now, relying on addNoteElement to place correctly or a refresh after batch.
-        const noteEl = window.ui.addNoteElement(optimisticNewNote, notesContainer, 0); // 0 for root level
+        const noteEl = ui.addNoteElement(optimisticNewNote);
         const contentDiv = noteEl?.querySelector('.note-content');
         if (contentDiv) {
             contentDiv.dataset.rawContent = '';
-            window.ui.switchToEditMode(contentDiv);
+            ui.switchToEditMode(contentDiv);
         }
     };
-
     await executeBatchOperations(originalNotesState, operations, optimisticDOMUpdater, "Add Root Note");
 }
 
-/**
- * Handles the Enter key press in a note, creating a new sibling note.
- * @param {Event} e - The keyboard event.
- * @param {HTMLElement} noteItem - The DOM element of the current note.
- * @param {Object} noteData - The data object for the current note.
- * @param {HTMLElement} contentDiv - The content-editable div of the current note.
- */
 async function handleEnterKey(e, noteItem, noteData, contentDiv) {
-    if (contentDiv.classList.contains('rendered-mode')) {
-        e.preventDefault(); window.ui.switchToEditMode(contentDiv); return;
-    }
-    if (e.shiftKey) { // Handle Shift+Enter for newline
-        // Allow default browser behavior for Shift+Enter (inserts <br> or new div)
-        // Then, ensure rawContent is updated for save
-        const rawTextValue = window.ui.getRawTextWithNewlines(contentDiv);
-        contentDiv.dataset.rawContent = window.ui.normalizeNewlines(rawTextValue);
-        debouncedSaveNote(noteItem); // Save the current note's change with the newline
-        return; // Do not prevent default for Shift+Enter
-    }
-    e.preventDefault(); // Prevent default Enter behavior (usually newline) for non-Shift+Enter
-
-    if (!noteData) { console.error("EnterKey: current noteData missing."); return; }
-    const pageIdToUse = currentPageId;
-    if (!pageIdToUse) { console.error("EnterKey: currentPageId missing."); return; }
+    if (e.shiftKey) return;
+    e.preventDefault();
 
     const clientTempId = `temp-E-${Date.now()}`;
-    const operations = [];
-    const parentIdForNewNote = noteData.parent_note_id;
-    const previousSiblingIdForNewNote = String(noteData.id);
-
-    // --- State backup MUST happen BEFORE any optimistic updates ---
     const originalNotesState = JSON.parse(JSON.stringify(notesForCurrentPage));
 
-    const siblingsOfCurrentNote = notesForCurrentPage.filter(n =>
-        String(n.parent_note_id ?? null) === String(parentIdForNewNote ?? null)
-    ).sort((a, b) => (a.order_index || 0) - (b.order_index || 0));
-    const currentNoteIdx = siblingsOfCurrentNote.findIndex(n => String(n.id) === String(noteData.id));
-    const nextSiblingIdForNewNote = (currentNoteIdx !== -1 && currentNoteIdx < siblingsOfCurrentNote.length - 1)
-        ? String(siblingsOfCurrentNote[currentNoteIdx + 1].id) : null;
+    const siblings = notesForCurrentPage.filter(n => String(n.parent_note_id ?? '') === String(noteData.parent_note_id ?? '')).sort((a, b) => a.order_index - b.order_index);
+    const currentNoteIndexInSiblings = siblings.findIndex(n => String(n.id) === String(noteData.id));
+    const nextSibling = siblings[currentNoteIndexInSiblings + 1];
 
-    const { targetOrderIndex, siblingUpdates } = calculateOrderIndex(
-        notesForCurrentPage, parentIdForNewNote, previousSiblingIdForNewNote, nextSiblingIdForNewNote
-    );
-
-    const optimisticNewNote = {
-        id: clientTempId, page_id: pageIdToUse, content: '', parent_note_id: parentIdForNewNote,
-        order_index: targetOrderIndex, created_at: new Date().toISOString(), updated_at: new Date().toISOString(),
-        properties: {}, client_temp_id: clientTempId
-    };
+    const { targetOrderIndex, siblingUpdates } = calculateOrderIndex(notesForCurrentPage, noteData.parent_note_id, String(noteData.id), nextSibling?.id || null);
+    
+    const optimisticNewNote = { id: clientTempId, page_id: currentPageId, content: '', parent_note_id: noteData.parent_note_id, order_index: targetOrderIndex, properties: {} };
     addNoteToCurrentPage(optimisticNewNote);
 
-    operations.push({
-        type: 'create',
-        payload: {
-            page_id: pageIdToUse, content: '', parent_note_id: parentIdForNewNote,
-            order_index: targetOrderIndex, client_temp_id: clientTempId
-        }
-    });
-
-    siblingUpdates.forEach(update => {
-        const noteToUpdate = getNoteDataById(update.id);
-        if (noteToUpdate) updateNoteInCurrentPage({ ...noteToUpdate, order_index: update.newOrderIndex });
-        operations.push({
-            type: 'update',
-            payload: { id: update.id, page_id: pageIdToUse, order_index: update.newOrderIndex }
-        });
+    const operations = [{ type: 'create', payload: { page_id: currentPageId, content: '', parent_note_id: noteData.parent_note_id, order_index: targetOrderIndex, client_temp_id: clientTempId } }];
+    siblingUpdates.forEach(upd => operations.push({ type: 'update', payload: { id: upd.id, order_index: upd.newOrderIndex } }));
+    
+    // Optimistically update local state for siblings
+    siblingUpdates.forEach(op => {
+        const note = getNoteDataById(op.id);
+        if (note) note.order_index = op.newOrderIndex;
     });
 
     const optimisticDOMUpdater = () => {
-        notesForCurrentPage.sort((a,b) => (a.order_index || 0) - (b.order_index || 0));
-        const currentNestingLevel = window.ui.getNestingLevel(noteItem);
-        // renderNote is for a full note structure, addNoteElement might be more appropriate if it handles insertion
-        const newNoteEl = window.ui.renderNote(optimisticNewNote, currentNestingLevel);
-
-        const parentDomContainer = noteItem.parentElement; // New note is a sibling
-        if (parentDomContainer) {
-            parentDomContainer.insertBefore(newNoteEl, noteItem.nextSibling);
-        } else {
-            console.error("[EnterKey BATCH] Current note item has no parent. Appending to notesContainer.");
-            notesContainer.appendChild(newNoteEl); // Fallback
-        }
-        
+        const newNoteEl = ui.renderNote(optimisticNewNote, ui.getNestingLevel(noteItem));
+        noteItem.after(newNoteEl);
         const newContentDiv = newNoteEl?.querySelector('.note-content');
         if (newContentDiv) {
             newContentDiv.dataset.rawContent = '';
-            window.ui.switchToEditMode(newContentDiv);
+            ui.switchToEditMode(newContentDiv);
         }
     };
-
-    await executeBatchOperations(originalNotesState, operations, optimisticDOMUpdater, "Create Note (Enter)");
+    await executeBatchOperations(originalNotesState, operations, optimisticDOMUpdater, "Create Sibling Note");
 }
 
-/**
- * Handles Tab (indent) and Shift+Tab (outdent) key presses in a note.
- * @param {Event} e - The keyboard event.
- * @param {HTMLElement} noteItem - The DOM element of the current note.
- * @param {Object} noteData - The data object for the current note.
- * @param {HTMLElement} contentDiv - The content-editable div of the current note.
- */
 async function handleTabKey(e, noteItem, noteData, contentDiv) {
     e.preventDefault();
-    if (!noteData) return;
-
-    const currentRawContent = contentDiv.dataset.rawContent || window.ui.getRawTextWithNewlines(contentDiv);
-    const normalizedCurrentContent = window.ui.normalizeNewlines(currentRawContent);
-
-    if (normalizedCurrentContent !== noteData.content) {
-        window.ui.updateSaveStatusIndicator('pending');
-        const savedNote = await _saveNoteToServer(noteData.id, normalizedCurrentContent, true);
-        if (savedNote) {
-            // Update noteData with confirmed values from server
-            noteData.content = savedNote.content;
-            noteData.updated_at = savedNote.updated_at;
-            noteData.properties = savedNote.properties || parsePropertiesFromText(savedNote.content); // Ensure properties are synced
-            contentDiv.dataset.rawContent = savedNote.content; // Update DOM dataset
-            window.ui.updateSaveStatusIndicator('saved');
-        } else {
-            alert("Failed to save current note's changes before indent/outdent. Aborting operation.");
-            window.ui.updateSaveStatusIndicator('error');
-            return;
-        }
-    }
+    await saveNoteImmediately(noteItem); // Ensure content is saved before structural change
 
-    // --- State backup MUST happen BEFORE any optimistic updates for the indent/outdent ---
     const originalNotesState = JSON.parse(JSON.stringify(notesForCurrentPage));
-
-    const operations = [];
-    let newParentIdForMovedNote = noteData.parent_note_id;
-    let newOrderIndexForMovedNote = noteData.order_index;
-    let destinationSiblingUpdates = []; // Updates for siblings in the new parent list
-    let sourceSiblingOperationsPayloads = []; // Payloads for updating siblings in the old parent list
-
-    const originalParentId = noteData.parent_note_id;
-    const originalOrderIndex = noteData.order_index;
-    const originalNoteDataForRevert = { ...getNoteDataById(noteData.id) }; // Backup before changing
+    let operations = [];
+    let newParentId = null;
 
     if (e.shiftKey) { // Outdent
-        if (!originalParentId) return; // Already root
-        const oldParentNoteData = getNoteDataById(originalParentId);
-        if (!oldParentNoteData) { console.error("Outdent: Old parent data missing for ID:", originalParentId); return; }
+        if (!noteData.parent_note_id) return;
+        const oldParentNote = getNoteDataById(noteData.parent_note_id);
+        if (!oldParentNote) return;
+        newParentId = oldParentNote.parent_note_id;
 
-        newParentIdForMovedNote = oldParentNoteData.parent_note_id; // New parent is grandparent
-        const prevSiblingForMoved = String(oldParentNoteData.id); // Moved note comes after its old parent
-
-        const siblingsOfGrandparent = notesForCurrentPage.filter(n =>
-            String(n.parent_note_id ?? null) === String(newParentIdForMovedNote ?? null)
-        ).sort((a, b) => (a.order_index || 0) - (b.order_index || 0));
-        const oldParentIdxInGrandparentList = siblingsOfGrandparent.findIndex(n => String(n.id) === String(oldParentNoteData.id));
-        const nextSiblingForMoved = (oldParentIdxInGrandparentList !== -1 && oldParentIdxInGrandparentList < siblingsOfGrandparent.length - 1)
-            ? String(siblingsOfGrandparent[oldParentIdxInGrandparentList + 1].id) : null;
+        const { targetOrderIndex, siblingUpdates } = calculateOrderIndex(notesForCurrentPage, newParentId, String(oldParentNote.id), null);
+        
+        operations.push({ type: 'update', payload: { id: noteData.id, parent_note_id: newParentId, order_index: targetOrderIndex } });
+        siblingUpdates.forEach(upd => operations.push({ type: 'update', payload: { id: upd.id, order_index: upd.newOrderIndex } }));
 
-        const calcResult = calculateOrderIndex(notesForCurrentPage, newParentIdForMovedNote, prevSiblingForMoved, nextSiblingForMoved);
-        newOrderIndexForMovedNote = calcResult.targetOrderIndex;
-        destinationSiblingUpdates = calcResult.siblingUpdates;
     } else { // Indent
-        const currentLevelSiblings = notesForCurrentPage.filter(n =>
-            String(n.parent_note_id ?? null) === String(originalParentId ?? null)
-        ).sort((a, b) => (a.order_index || 0) - (b.order_index || 0));
-        const currentNoteIdx = currentLevelSiblings.findIndex(n => String(n.id) === String(noteData.id));
-
-        if (currentNoteIdx <= 0) return; // Cannot indent first child or if no previous sibling
-        const potentialNewParent = currentLevelSiblings[currentNoteIdx - 1];
-        if (!potentialNewParent) return;
-
-        newParentIdForMovedNote = String(potentialNewParent.id);
-        const childrenOfNewParent = notesForCurrentPage.filter(n =>
-            String(n.parent_note_id ?? null) === newParentIdForMovedNote
-        ).sort((a, b) => (a.order_index || 0) - (b.order_index || 0));
-        const prevSiblingForMoved = childrenOfNewParent.length > 0
-            ? String(childrenOfNewParent[childrenOfNewParent.length - 1].id) : null;
+        const siblings = notesForCurrentPage.filter(n => String(n.parent_note_id ?? '') === String(noteData.parent_note_id ?? '')).sort((a,b) => a.order_index - b.order_index);
+        const currentNoteIndexInSiblings = siblings.findIndex(n => String(n.id) === String(noteData.id));
+        if (currentNoteIndexInSiblings < 1) return;
+        
+        const newParentNote = siblings[currentNoteIndexInSiblings - 1];
+        newParentId = String(newParentNote.id);
+        const { targetOrderIndex, siblingUpdates } = calculateOrderIndex(notesForCurrentPage, newParentId, null, null);
 
-        const calcResult = calculateOrderIndex(notesForCurrentPage, newParentIdForMovedNote, prevSiblingForMoved, null);
-        newOrderIndexForMovedNote = calcResult.targetOrderIndex;
-        destinationSiblingUpdates = calcResult.siblingUpdates;
+        operations.push({ type: 'update', payload: { id: noteData.id, parent_note_id: newParentId, order_index: targetOrderIndex } });
+        siblingUpdates.forEach(upd => operations.push({ type: 'update', payload: { id: upd.id, order_index: upd.newOrderIndex } }));
     }
-
-    // --- Optimistic Local State Update (Moved Note) ---
-    updateNoteInCurrentPage({ ...noteData, parent_note_id: newParentIdForMovedNote, order_index: newOrderIndexForMovedNote });
-    operations.push({
-        type: 'update',
-        payload: {
-            id: noteData.id, page_id: currentPageId,
-            parent_note_id: newParentIdForMovedNote, order_index: newOrderIndexForMovedNote,
-            content: noteData.content // Content is up-to-date
+    
+    // **FIXED**: Perform optimistic state updates before calling the batch operation
+    const noteToMove = getNoteDataById(noteData.id);
+    if(noteToMove) noteToMove.parent_note_id = newParentId;
+    operations.forEach(op => {
+        if (op.type === 'update') {
+            const note = getNoteDataById(op.payload.id);
+            if(note) note.order_index = op.payload.order_index;
         }
     });
 
-    destinationSiblingUpdates.forEach(update => {
-        const noteToUpdate = getNoteDataById(update.id);
-        if (noteToUpdate) updateNoteInCurrentPage({ ...noteToUpdate, order_index: update.newOrderIndex });
-        operations.push({
-            type: 'update',
-            payload: { id: update.id, page_id: currentPageId, order_index: update.newOrderIndex }
-        });
-    });
-
-    // --- Re-index Source Siblings if parent changed ---
-    if (String(originalParentId ?? null) !== String(newParentIdForMovedNote ?? null)) {
-        const sourceSiblingsToReindex = notesForCurrentPage
-            .filter(n => String(n.parent_note_id ?? null) === String(originalParentId ?? null) && String(n.id) !== String(noteData.id))
-            .sort((a, b) => (a.order_index || 0) - (b.order_index || 0)); // Sort by current order_index
-
-        sourceSiblingsToReindex.forEach((sibling, index) => {
-            if ((sibling.order_index || 0) !== index) { // Check if order_index needs update
-                const noteToUpdate = getNoteDataById(sibling.id);
-                if (noteToUpdate) updateNoteInCurrentPage({ ...noteToUpdate, order_index: index });
-                sourceSiblingOperationsPayloads.push({ id: sibling.id, page_id: currentPageId, order_index: index });
-            }
-        });
-        sourceSiblingOperationsPayloads.forEach(payload => operations.push({ type: 'update', payload }));
-    }
-    
     const optimisticDOMUpdater = () => {
-        notesForCurrentPage.sort((a,b) => (a.order_index || 0) - (b.order_index || 0));
-        const movedNoteElement = getNoteElementById(noteData.id); // Get the element again after state updates
-        if (!movedNoteElement) { console.error("Tab: Moved note element not found in DOM for update."); return; }
-
-        let targetParentDomEl;
-        let newNestingLevel;
-        let insertBeforeEl = null;
-
-        if (e.shiftKey) { // Outdent
-            const oldParentNoteEl = getNoteElementById(originalParentId); // This is the note that WAS the parent
-            targetParentDomEl = oldParentNoteEl ? oldParentNoteEl.parentElement : notesContainer; // New parent container is grandparent's children container
-            newNestingLevel = window.ui.getNestingLevel(targetParentDomEl); // Nesting level of target container
-             // The moved note should come *after* its old parent.
-            insertBeforeEl = oldParentNoteEl ? oldParentNoteEl.nextElementSibling : null;
-
-        } else { // Indent
-            const newParentNoteDomEl = getNoteElementById(newParentIdForMovedNote);
-            if (!newParentNoteDomEl) { console.error("Indent: New parent DOM element not found."); return; }
-            targetParentDomEl = newParentNoteDomEl.querySelector('.note-children');
-            if (!targetParentDomEl) {
-                targetParentDomEl = document.createElement('div');
-                targetParentDomEl.className = 'note-children';
-                newParentNoteDomEl.appendChild(targetParentDomEl);
-                // if (typeof Sortable !== 'undefined' && Sortable.create) { /* Make sortable */ }
-            }
-            newNestingLevel = window.ui.getNestingLevel(newParentNoteDomEl) + 1;
-            // No insertBeforeEl, append to end of new children list
+        // Since this is a structural change, a full re-render is the safest approach.
+        ui.displayNotes(notesForCurrentPage, currentPageId);
+        const newNoteItem = getNoteElementById(noteData.id);
+        if (newNoteItem) {
+            const newContentDiv = newNoteItem.querySelector('.note-content');
+            if (newContentDiv) ui.switchToEditMode(newContentDiv);
         }
-        
-        window.ui.moveNoteElement(movedNoteElement, targetParentDomEl, newNestingLevel, insertBeforeEl);
-        const movedContentDiv = movedNoteElement.querySelector('.note-content');
-        if (movedContentDiv) window.ui.switchToEditMode(movedContentDiv);
     };
 
-    const success = await executeBatchOperations(originalNotesState, operations, optimisticDOMUpdater, e.shiftKey ? "Outdent Note" : "Indent Note");
-    if (!success) {
-        // If batch fails, executeBatchOperations handles global revert.
-        // We might need to restore the specific moved note's original state if it was altered before the backup.
-        // However, originalNotesState in executeBatchOperations should capture the state before any changes in this function.
-        // The prerequisite save of content is the only change before originalNotesState is cloned.
-    }
+    await executeBatchOperations(originalNotesState, operations, optimisticDOMUpdater, e.shiftKey ? "Outdent Note" : "Indent Note");
 }
 
-/**
- * Handles Backspace key press in an empty note, deleting it.
- * @param {Event} e - The keyboard event.
- * @param {HTMLElement} noteItem - The DOM element of the current note.
- * @param {Object} noteData - The data object for the current note.
- * @param {HTMLElement} contentDiv - The content-editable div of the current note.
- */
 async function handleBackspaceKey(e, noteItem, noteData, contentDiv) {
-    if (!noteData || String(noteData.id).startsWith('temp-')) return;
-
-    if (contentDiv.classList.contains('edit-mode') && (contentDiv.dataset.rawContent || contentDiv.textContent).trim() === '') {
-        const children = notesForCurrentPage.filter(n => String(n.parent_note_id) === String(noteData.id));
-        if (children.length > 0) {
-            console.log('Backspace: Note has children, not deleting:', noteData.id); return;
-        }
-        if (notesForCurrentPage.length === 1 && !noteData.parent_note_id) {
-            console.log('Backspace: Cannot delete the only root note:', noteData.id); return;
-        }
-        e.preventDefault();
-
-        let noteToFocusAfterDeleteEl = null;
-        const allVisibleNoteItems = Array.from(notesContainer.querySelectorAll('.note-item:not(.note-hidden)'));
-        const currentDOMIndex = allVisibleNoteItems.findIndex(el => el === noteItem);
-
-        if (currentDOMIndex > 0) { // Try to focus previous sibling
-            noteToFocusAfterDeleteEl = allVisibleNoteItems[currentDOMIndex - 1];
-        } else if (allVisibleNoteItems.length > 1 && currentDOMIndex + 1 < allVisibleNoteItems.length) { // Try next sibling
-            noteToFocusAfterDeleteEl = allVisibleNoteItems[currentDOMIndex + 1];
-        } else if (noteData.parent_note_id) { // Try parent
-            noteToFocusAfterDeleteEl = getNoteElementById(noteData.parent_note_id);
-        } // If still null, no specific focus target after delete (e.g., last note on page deleted)
-
-
-        // --- State backup MUST happen BEFORE any optimistic updates ---
-        const originalNotesState = JSON.parse(JSON.stringify(notesForCurrentPage));
+    if ((contentDiv.dataset.rawContent || contentDiv.textContent).trim() !== '') return;
+    const children = notesForCurrentPage.filter(n => String(n.parent_note_id) === String(noteData.id));
+    if (children.length > 0) return;
 
-        const noteIdToDelete = noteData.id;
-        const parentIdOfDeleted = noteData.parent_note_id;
-
-        // Optimistic Local State Update: Remove first
-        removeNoteFromCurrentPageById(noteIdToDelete);
-
-        // Prepare operations: delete + re-index siblings
-        const operations = [{ type: 'delete', payload: { id: noteIdToDelete } }];
-        const siblingsOfDeleted = notesForCurrentPage // Get siblings from already-updated list
-            .filter(n => String(n.parent_note_id ?? null) === String(parentIdOfDeleted ?? null))
-            .sort((a, b) => (a.order_index || 0) - (b.order_index || 0));
-
-        siblingsOfDeleted.forEach((sibling, index) => {
-            if ((sibling.order_index || 0) !== index) {
-                const noteToUpdate = getNoteDataById(sibling.id);
-                if (noteToUpdate) updateNoteInCurrentPage({ ...noteToUpdate, order_index: index });
-                operations.push({
-                    type: 'update',
-                    payload: { id: sibling.id, page_id: currentPageId, order_index: index }
-                });
-            }
-        });
-
-        const optimisticDOMUpdater = () => {
-            // notesForCurrentPage is already sorted if sibling re-indexing happened.
-            // DOM update for siblings might be needed if visual order changes.
-            window.ui.removeNoteElement(noteIdToDelete);
-        };
+    e.preventDefault();
+    let focusTargetEl = noteItem.previousElementSibling || getNoteElementById(noteData.parent_note_id);
+    
+    const originalNotesState = JSON.parse(JSON.stringify(notesForCurrentPage));
+    const noteIdToDelete = noteData.id;
 
-        const success = await executeBatchOperations(originalNotesState, operations, optimisticDOMUpdater, "Delete Note (Backspace)");
-        if (success && noteToFocusAfterDeleteEl) {
-            const contentDivToFocus = noteToFocusAfterDeleteEl.querySelector('.note-content');
-            if (contentDivToFocus) window.ui.switchToEditMode(contentDivToFocus);
-        } else if (success && notesForCurrentPage.length === 0 && currentPageId) {
-            console.log("All notes deleted. Page is empty.");
-            // Optionally, trigger creation of a new first note:
-            // if (typeof window.handleCreateAndFocusFirstNote === 'function') { // Check if function exists
-            //     await window.handleCreateAndFocusFirstNote(currentPageId);
-            // }
+    removeNoteFromCurrentPageById(noteIdToDelete);
+    const operations = [{ type: 'delete', payload: { id: noteIdToDelete } }];
+    
+    const optimisticDOMUpdater = () => {
+        ui.removeNoteElement(noteIdToDelete);
+        if (focusTargetEl) {
+            const contentToFocus = focusTargetEl.querySelector('.note-content');
+            if(contentToFocus) ui.switchToEditMode(contentToFocus);
         }
-    }
+    };
+    await executeBatchOperations(originalNotesState, operations, optimisticDOMUpdater, "Delete Note (Backspace)");
 }
 
-// --- Standard Keyboard Handlers (Non-structural changes) ---
-/**
- * Handles Arrow Up/Down key presses for navigating between notes.
- * @param {Event} e - The keyboard event.
- * @param {HTMLElement} contentDiv - The content-editable div of the current note.
- */
 function handleArrowKey(e, contentDiv) {
     e.preventDefault();
     const allVisibleNotesContent = Array.from(notesContainer.querySelectorAll('.note-item:not(.note-hidden) .note-content'));
-    const currentVisibleIndex = allVisibleNotesContent.indexOf(contentDiv);
-    let nextVisibleIndex = -1;
+    const currentIndex = allVisibleNotesContent.indexOf(contentDiv);
+    let nextIndex = -1;
 
-    if (e.key === 'ArrowUp' && currentVisibleIndex > 0) {
-        nextVisibleIndex = currentVisibleIndex - 1;
-    } else if (e.key === 'ArrowDown' && currentVisibleIndex < allVisibleNotesContent.length - 1) {
-        nextVisibleIndex = currentVisibleIndex + 1;
-    }
+    if (e.key === 'ArrowUp' && currentIndex > 0) nextIndex = currentIndex - 1;
+    else if (e.key === 'ArrowDown' && currentIndex < allVisibleNotesContent.length - 1) nextIndex = currentIndex + 1;
 
-    if (nextVisibleIndex !== -1) {
-        const nextNoteContent = allVisibleNotesContent[nextVisibleIndex];
-        window.ui.switchToEditMode(nextNoteContent);
-        // Place cursor at end of content in next note
+    if (nextIndex !== -1) {
+        const nextContent = allVisibleNotesContent[nextIndex];
+        ui.switchToEditMode(nextContent);
         const range = document.createRange();
         const sel = window.getSelection();
-        if (nextNoteContent.firstChild) { // Check if there's content to select
-            range.selectNodeContents(nextNoteContent);
-            range.collapse(false); // false to collapse to end
-        } else { // If empty, just set cursor at the start
-            range.setStart(nextNoteContent, 0);
-            range.collapse(true);
-        }
+        range.selectNodeContents(nextContent);
+        range.collapse(false);
         sel.removeAllRanges();
         sel.addRange(range);
     }
 }
 
-/**
- * Handles shortcut expansions (e.g., :tag: -> {tag::}).
- * @param {Event} e - The keyboard event.
- * @param {HTMLElement} contentDiv - The content-editable div.
- * @returns {Promise<boolean>} True if a shortcut was handled, false otherwise.
- */
-async function handleShortcutExpansion(e, contentDiv) {
-    if (e.key !== ' ') return false;
-    const selection = window.getSelection();
-    if (!selection || selection.rangeCount === 0) return false;
-    const range = selection.getRangeAt(0);
-    const cursorPos = range.startOffset;
-    const textNode = range.startContainer;
-    if (!textNode || textNode.nodeType !== Node.TEXT_NODE || cursorPos < 2) return false;
-
-    const textContent = textNode.textContent;
-    const precedingText2Chars = textContent.substring(cursorPos - 2, cursorPos);
-    let shortcutHandled = false;
-    let replacementText = '';
-    let cursorOffsetAfterReplace = 0;
-
-    if (precedingText2Chars === ':t') { replacementText = '{tag::}'; cursorOffsetAfterReplace = 6; }
-    else if (precedingText2Chars === ':d') { const today = new Date().toISOString().slice(0, 10); replacementText = `{date::${today}}`; cursorOffsetAfterReplace = replacementText.length; }
-    else if (precedingText2Chars === ':r') { const now = new Date().toISOString(); replacementText = `{timestamp::${now}}`; cursorOffsetAfterReplace = replacementText.length; }
-    else if (precedingText2Chars === ':k') { replacementText = '{keyword::}'; cursorOffsetAfterReplace = 10; }
-
-    if (replacementText) {
-        e.preventDefault();
-        replaceTextAtCursor(2, replacementText, cursorOffsetAfterReplace);
-        shortcutHandled = true;
-    }
-
-    if (shortcutHandled) {
-        const noteItemForShortcut = contentDiv.closest('.note-item');
-        if (noteItemForShortcut) {
-            const rawTextValue = window.ui.getRawTextWithNewlines(contentDiv);
-            contentDiv.dataset.rawContent = window.ui.normalizeNewlines(rawTextValue);
-            debouncedSaveNote(noteItemForShortcut); // Save after shortcut expansion
-        }
-        return true;
-    }
-    return false;
-}
-
-/**
- * Handles auto-closing of brackets/parentheses/braces.
- * @param {Event} e - The keyboard event.
- * @returns {boolean} True if a bracket was auto-closed, false otherwise.
- */
-function handleAutocloseBrackets(e) {
-    let handled = false;
-    const selection = window.getSelection();
-    if (!selection || !selection.rangeCount) return false;
-    const range = selection.getRangeAt(0);
-    const editor = e.target; // contentEditable div
-
-    const keyActionMap = { '[': '[]', '{': '{}', '(': '()' };
-
-    if (keyActionMap[e.key]) {
-        const textToInsert = keyActionMap[e.key];
-        let cursorOffset = 1;
-
-        // Special handling for '[' to avoid conflict with manual '[[page]]' typing
-        // if (e.key === '[') {
-        //     const textNode = range.startContainer;
-        //     let textBeforeCursor = "";
-        //     if (textNode.nodeType === Node.TEXT_NODE && range.startOffset > 0) {
-        //         textBeforeCursor = textNode.textContent.substring(range.startOffset - 1, range.startOffset);
-        //     }
-        //     if (textBeforeCursor === '[') { // User typed '[[', let page link suggestions handle it
-        //         return false; // Don't auto-close to '[[[]]]'
-        //     }
-        // }
-        // Simpler: always auto-close. If user types [[, they can backspace one ] if needed.
-        // Or, page-link-suggestions.js might handle [[ typing more gracefully.
-
-        e.preventDefault();
-        insertTextAtCursor(textToInsert, cursorOffset);
-        handled = true;
-    }
-
-    if (handled) {
-        // Dispatch an input event so note-renderer's listeners (like for page link suggestions) are triggered
-        editor.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
-    }
-    return handled;
-}
-
-/**
- * Master keydown handler for notes. Delegates to specific handlers based on key.
- * @param {Event} e - The keyboard event.
- */
 export async function handleNoteKeyDown(e) {
     if (!e.target.matches('.note-content')) return;
     const noteItem = e.target.closest('.note-item');
@@ -963,123 +362,91 @@ export async function handleNoteKeyDown(e) {
     }
 }
 
-
-// --- Event Handler: Task Checkbox Click ---
-/**
- * Handles clicks on task checkboxes, updating note content and properties.
- * @param {Event} e - The click event.
- */
 export async function handleTaskCheckboxClick(e) {
     const checkbox = e.target;
     const noteItem = checkbox.closest('.note-item');
     if (!noteItem) return;
     
     const noteId = noteItem.dataset.noteId;
-    if (String(noteId).startsWith('temp-')) {
-        console.warn("Task checkbox clicked on temp note. Action deferred until note is saved.");
-        checkbox.checked = !checkbox.checked; // Revert optimistic UI change
-        return;
-    }
-
-    const contentDiv = noteItem.querySelector('.note-content');
     const noteData = getNoteDataById(noteId);
-
-    if (!noteData || !contentDiv) {
-        console.error('Task Click: Note data or contentDiv not found for ID:', noteId);
-        checkbox.checked = !checkbox.checked; return;
+    if (!noteData || String(noteId).startsWith('temp-')) {
+        checkbox.checked = !checkbox.checked;
+        return;
     }
     
-    // Use dataset.rawContent if available (likely from edit mode), otherwise use noteData.content (from rendered mode)
-    let currentRawContent = contentDiv.dataset.rawContent !== undefined ? contentDiv.dataset.rawContent : noteData.content;
-    
+    let currentRawContent = noteData.content;
     let newRawContent = currentRawContent;
-    let doneAt = null;
     const isChecked = checkbox.checked;
-    const markerType = checkbox.dataset.markerType?.toUpperCase();
-
-    const taskPrefixesWithSpace = ["TODO ", "DOING ", "SOMEDAY ", "DONE ", "WAITING ", "CANCELLED ", "NLR "];
-    const currentPrefix = taskPrefixesWithSpace.find(p => currentRawContent.toUpperCase().startsWith(p));
-    const contentWithoutPrefix = currentPrefix ? currentRawContent.substring(currentPrefix.length) : currentRawContent;
-
-    switch (markerType) {
-        case 'TODO':    newRawContent = (isChecked ? 'DONE ' : 'TODO ')    + contentWithoutPrefix; break;
-        case 'DOING':   newRawContent = (isChecked ? 'DONE ' : 'TODO ')    + contentWithoutPrefix; break;
-        case 'SOMEDAY': newRawContent = (isChecked ? 'DONE ' : 'TODO ')    + contentWithoutPrefix; break;
-        case 'DONE':    newRawContent = (isChecked ? 'DONE ' : 'TODO ')    + contentWithoutPrefix; break;
-        case 'WAITING': newRawContent = (isChecked ? 'DONE ' : 'TODO ')    + contentWithoutPrefix; break;
-        case 'CANCELLED': case 'NLR': checkbox.checked = true; /* Non-interactive, ensure it stays checked */ return;
-        default: console.warn("Unknown task marker type:", markerType); checkbox.checked = !checkbox.checked; return;
+    
+    const taskMarkers = ["TODO ", "DOING ", "SOMEDAY ", "DONE ", "WAITING ", "CANCELLED ", "NLR "];
+    const currentPrefix = taskMarkers.find(p => currentRawContent.toUpperCase().startsWith(p));
+    
+    if (currentPrefix) {
+        const contentWithoutPrefix = currentRawContent.substring(currentPrefix.length);
+        newRawContent = (isChecked ? 'DONE ' : 'TODO ') + contentWithoutPrefix;
+    } else {
+        newRawContent = (isChecked ? 'DONE ' : 'TODO ') + currentRawContent;
     }
 
-    if (newRawContent.toUpperCase().startsWith('DONE ')) {
-        doneAt = new Date().toISOString().slice(0, 19).replace('T', ' '); // YYYY-MM-DD HH:MM:SS format
+    const contentDiv = noteItem.querySelector('.note-content');
+    if (contentDiv) {
+        contentDiv.dataset.rawContent = newRawContent;
+        contentDiv.innerHTML = ui.parseAndRenderContent(newRawContent);
     }
-
-    // Optimistic update of local state and DOM
-    const originalNoteContentForRevert = noteData.content;
-    const originalNotePropertiesForRevert = JSON.parse(JSON.stringify(noteData.properties || {}));
-
-    noteData.content = newRawContent; // Update local state content
-    contentDiv.dataset.rawContent = newRawContent; // Update DOM dataset
-    if (contentDiv.classList.contains('edit-mode')) {
-        contentDiv.textContent = newRawContent;
-    } else {
-        // Re-render only if content actually changed to avoid unnecessary parsing
-        if (newRawContent !== currentRawContent) {
-            contentDiv.innerHTML = window.ui.parseAndRenderContent(newRawContent);
+    noteData.content = newRawContent;
+    
+    try {
+        await _saveNoteToServer(noteId, newRawContent);
+    } catch (error) {
+        checkbox.checked = !checkbox.checked;
+        noteData.content = currentRawContent;
+        if (contentDiv) {
+            contentDiv.dataset.rawContent = currentRawContent;
+            contentDiv.innerHTML = ui.parseAndRenderContent(currentRawContent);
         }
     }
-    // Optimistically update properties (done_at)
-    if (!noteData.properties) noteData.properties = {};
-    if (doneAt) {
-        noteData.properties.done_at = [{ value: doneAt, internal: 0 }];
-    } else {
-        delete noteData.properties.done_at;
-    }
-    updateNoteInCurrentPage(noteData); // Propagate optimistic changes to global state
+}
 
-    try {
-        window.ui.updateSaveStatusIndicator('pending');
-        // 1. Update note content (server's pattern processor should handle status property)
-        const updatedNoteServer = await notesAPI.updateNote(noteId, { 
-            page_id: currentPageId, content: newRawContent 
-        });
-        
-        // Sync local noteData with server response for content, timestamps, and server-processed properties
-        noteData.content = updatedNoteServer.content;
-        noteData.updated_at = updatedNoteServer.updated_at;
-        noteData.properties = updatedNoteServer.properties || parsePropertiesFromText(updatedNoteServer.content); // Trust server's properties
+/**
+ * Handles shortcut expansions (e.g., :tag: -> {tag::}).
+ * @param {Event} e - The keyboard event.
+ * @param {HTMLElement} contentDiv - The content-editable div.
+ * @returns {Promise<boolean>} True if a shortcut was handled, false otherwise.
+ */
+async function handleShortcutExpansion(e, contentDiv) {
+    if (e.key !== ' ') return false;
+    const selection = window.getSelection();
+    if (!selection || selection.rangeCount === 0) return false;
+    const range = selection.getRangeAt(0);
+    const cursorPos = range.startOffset;
+    const textNode = range.startContainer;
+    if (!textNode || textNode.nodeType !== Node.TEXT_NODE || cursorPos < 2) return false;
 
-        // 2. Explicitly manage 'done_at' property if server doesn't auto-handle it based on "DONE "
-        //    (This depends on backend implementation. If backend handles it, this block might be redundant)
-        const serverDoneAt = noteData.properties?.done_at?.[0]?.value;
-        if (doneAt && serverDoneAt !== doneAt) { // If we calculated doneAt and server doesn't have it (or different)
-            await propertiesAPI.setProperty({ entity_type: 'note', entity_id: parseInt(noteId), name: 'done_at', value: doneAt });
-            if(!noteData.properties.done_at) noteData.properties.done_at = [];
-            noteData.properties.done_at = [{value: doneAt, internal: 0}];
-        } else if (!doneAt && serverDoneAt) { // If we calculated no doneAt but server has one
-            await propertiesAPI.deleteProperty('note', parseInt(noteId), 'done_at');
-             delete noteData.properties.done_at;
-        }
-        
-        updateNoteInCurrentPage(noteData); // Final update to global state with all server-confirmed data
-        window.ui.updateSaveStatusIndicator('saved');
+    const textContent = textNode.textContent;
+    const precedingText2Chars = textContent.substring(cursorPos - 2, cursorPos);
+    let shortcutHandled = false;
+    let replacementText = '';
+    let cursorOffsetAfterReplace = 0;
 
-    } catch (error) {
-        console.error(`Task Click: Error updating task for note ${noteId}. Error:`, error);
-        alert(`Failed to update task status. ${error.message}`);
-        
-        // Revert optimistic changes
-        noteData.content = originalNoteContentForRevert;
-        noteData.properties = originalNotePropertiesForRevert;
-        checkbox.checked = !checkbox.checked; 
-        contentDiv.dataset.rawContent = originalNoteContentForRevert; 
-        if (contentDiv.classList.contains('edit-mode')) {
-            contentDiv.textContent = originalNoteContentForRevert;
-        } else {
-            contentDiv.innerHTML = window.ui.parseAndRenderContent(originalNoteContentForRevert);
+    if (precedingText2Chars === ':t') { replacementText = '{tag::}'; cursorOffsetAfterReplace = 6; }
+    else if (precedingText2Chars === ':d') { const today = new Date().toISOString().slice(0, 10); replacementText = `{date::${today}}`; cursorOffsetAfterReplace = replacementText.length; }
+    else if (precedingText2Chars === ':r') { const now = new Date().toISOString(); replacementText = `{timestamp::${now}}`; cursorOffsetAfterReplace = replacementText.length; }
+    else if (precedingText2Chars === ':k') { replacementText = '{keyword::}'; cursorOffsetAfterReplace = 10; }
+
+    if (replacementText) {
+        e.preventDefault();
+        insertTextAtCursor(replacementText, replacementText.length - cursorOffsetAfterReplace);
+        shortcutHandled = true;
+    }
+
+    if (shortcutHandled) {
+        const noteItemForShortcut = contentDiv.closest('.note-item');
+        if (noteItemForShortcut) {
+            const rawTextValue = window.ui.getRawTextWithNewlines(contentDiv);
+            contentDiv.dataset.rawContent = window.ui.normalizeNewlines(rawTextValue);
+            debouncedSaveNote(noteItemForShortcut); // Save after shortcut expansion
         }
-        updateNoteInCurrentPage(noteData); // Revert in global state
-        window.ui.updateSaveStatusIndicator('error');
+        return true;
     }
-}
\ No newline at end of file
+    return false;
+}
diff --git a/assets/js/app/page-loader.js b/assets/js/app/page-loader.js
index cf5a3bc..6da3013 100644
--- a/assets/js/app/page-loader.js
+++ b/assets/js/app/page-loader.js
@@ -6,7 +6,6 @@ import {
     setCurrentPageId,
     setCurrentPageName,
     setNotesForCurrentPage,
-    addNoteToCurrentPage,
     hasPageCache,
     getPageCache,
     setPageCache,
@@ -14,498 +13,192 @@ import {
     currentPageName
 } from './state.js';
 
-const MAX_LINKED_PAGES_TO_PREFETCH = MAX_PREFETCH_PAGES;
+import { decrypt } from '../utils.js';
+import { notesAPI, pagesAPI, searchAPI, queryAPI } from '../api_client.js';
+import { handleAddRootNote } from './note-actions.js';
+import { ui } from '../ui.js';
 
 window.currentPageEncryptionKey = null;
 window.decryptionPassword = null;
 
-// Import API clients
-import { notesAPI, pagesAPI, searchAPI, queryAPI } from '../api_client.js';
-
-// Import note actions
-import { saveNoteImmediately } from './note-actions.js';
-
-// Remove direct destructuring of ui.domRefs
-// const { notesContainer, backlinksContainer } = ui.domRefs;
 const notesContainer = document.querySelector('#notes-container');
 const backlinksContainer = document.querySelector('#backlinks-container');
 
-/**
- * Gets today's date in YYYY-MM-DD format for journal pages
- * @returns {string} Date string in YYYY-MM-DD format
- */
 function getTodaysJournalPageName() {
     const today = new Date();
-    const year = today.getFullYear();
-    const month = String(today.getMonth() + 1).padStart(2, '0');
-    const day = String(today.getDate()).padStart(2, '0');
-    return `${year}-${month}-${day}`;
+    return today.toISOString().split('T')[0];
 }
 
-/**
- * Gets the previous day's date in YYYY-MM-DD format
- * @param {string} currentDateStr - Date string in YYYY-MM-DD format
- * @returns {string} Date string for the previous day in YYYY-MM-DD format
- */
 export function getPreviousDayPageName(currentDateStr) {
-    const [year, month, day] = currentDateStr.split('-').map(Number);
-    const date = new Date(year, month - 1, day); // Month is 0-indexed
+    const date = new Date(currentDateStr);
     date.setDate(date.getDate() - 1);
-    const prevYear = date.getFullYear();
-    const prevMonth = String(date.getMonth() + 1).padStart(2, '0');
-    const prevDay = String(date.getDate()).padStart(2, '0');
-    return `${prevYear}-${prevMonth}-${prevDay}`;
+    return date.toISOString().split('T')[0];
 }
 
-/**
- * Gets the next day's date in YYYY-MM-DD format
- * @param {string} currentDateStr - Date string in YYYY-MM-DD format
- * @returns {string} Date string for the next day in YYYY-MM-DD format
- */
 export function getNextDayPageName(currentDateStr) {
-    const [year, month, day] = currentDateStr.split('-').map(Number);
-    const date = new Date(year, month - 1, day); // Month is 0-indexed
+    const date = new Date(currentDateStr);
     date.setDate(date.getDate() + 1);
-    const nextYear = date.getFullYear();
-    const nextMonth = String(date.getMonth() + 1).padStart(2, '0');
-    const nextDay = String(date.getDate()).padStart(2, '0');
-    return `${nextYear}-${nextMonth}-${nextDay}`;
+    return date.toISOString().split('T')[0];
 }
 
-/**
- * Gets the initial page name to load
- * @returns {string} The name of the initial page (today's journal page by default)
- */
-export function getInitialPage() { // <-- EXPORT ADDED
+export function getInitialPage() {
     return getTodaysJournalPageName();
 }
 
-/**
- * Handles transclusions in notes
- * @param {Array} notes - Array of notes to process (optional, defaults to current page notes read from state)
- */
-export async function handleTransclusions(notesToProcess = notesForCurrentPage) {
+export async function handleTransclusions() {
     const placeholders = document.querySelectorAll('.transclusion-placeholder');
-    if (placeholders.length === 0) {
-        console.log('No transclusion placeholders found.');
-        return;
-    }
-    console.log(`Found ${placeholders.length} transclusion placeholders.`);
-
-    const blockIdsSet = new Set();
-    placeholders.forEach(placeholder => {
-        const blockRef = placeholder.dataset.blockRef;
-        if (blockRef && blockRef.trim() !== '') { 
-            blockIdsSet.add(String(blockRef)); 
-        } else {
-            console.warn('Placeholder found with invalid or missing data-block-ref', placeholder);
-            placeholder.textContent = 'Invalid block reference (missing ref)';
-            placeholder.classList.add('error');
-        }
-    });
-
-    const blockIdsArray = Array.from(blockIdsSet);
-
-    if (blockIdsArray.length === 0) {
-        console.log('No valid block IDs to fetch for transclusions.');
-        return;
-    }
-
-    console.log(`Fetching content for ${blockIdsArray.length} unique block IDs for transclusion.`);
-
-    try {
-        const notesMap = {};
-        for (const blockId of blockIdsArray) {
-            try {
-                const note = await notesAPI.getNote(blockId);
-                if (note) {
-                    notesMap[blockId] = note;
-                } else {
-                    console.warn(`Note not found (or null response) for blockId during individual fetch: ${blockId}`);
-                    // Update placeholders for this blockId
-                    placeholders.forEach(placeholder => {
-                        if (placeholder.dataset.blockRef === blockId) {
-                            placeholder.textContent = 'Block not found';
-                            placeholder.classList.add('error');
-                        }
-                    });
-                    // Ensure this blockId is not in notesMap or is handled in the rendering loop
-                    delete notesMap[blockId]; 
-                }
-            } catch (fetchError) {
-                console.error(`Error fetching individual note for blockId ${blockId}:`, fetchError);
-                // Update placeholders for this blockId
-                placeholders.forEach(placeholder => {
-                    if (placeholder.dataset.blockRef === blockId) {
-                        placeholder.textContent = 'Error loading block';
-                        placeholder.classList.add('error');
-                    }
-                });
-                // Ensure this blockId is not in notesMap or is handled in the rendering loop
-                delete notesMap[blockId]; 
-            }
-        }
-
-        placeholders.forEach(placeholder => {
-            const blockRef = placeholder.dataset.blockRef;
-            if (!blockRef || blockRef.trim() === '') {
-                // This case is already handled when blockIdsSet is populated, 
-                // but as a safeguard, we skip further processing.
-                return;
-            }
+    if (placeholders.length === 0) return;
 
-            // If placeholder already has an error class, it means it was handled in the fetch loop
-            if (placeholder.classList.contains('error')) {
-                return;
-            }
-            
-            const note = notesMap[blockRef];
+    for (const placeholder of placeholders) {
+        const blockId = placeholder.dataset.blockRef;
+        if (!blockId) continue;
+        try {
+            const note = await notesAPI.getNote(blockId);
             if (note && note.content) {
-                window.ui.renderTransclusion(placeholder, note.content, blockRef);
-            } else if (note) { // Note exists but content might be empty/missing
-                console.warn(`Content is empty or missing for blockRef ${blockRef}. Note data:`, note);
-                placeholder.textContent = 'Block content is empty';
-                placeholder.classList.add('error');
-            } else { 
-                // This case should ideally be covered by the error handling within the fetch loop.
-                // However, if a blockId made it here without being in notesMap (e.g., due to deletion),
-                // it implies it wasn't found or an error occurred.
-                console.warn(`Block not found for blockRef ${blockRef} in rendering loop (should have been caught earlier).`);
-                placeholder.textContent = 'Block not found'; // Or 'Error loading block' if more appropriate
-                placeholder.classList.add('error');
-            }
-        });
-    } catch (error) { // This is a general error for the whole transclusion process
-        console.error('Error loading multiple transclusions:', error);
-        placeholders.forEach(placeholder => {
-            // Only update placeholders that haven't already been marked with an error
-            if (placeholder.dataset.blockRef && placeholder.dataset.blockRef.trim() !== '' && !placeholder.classList.contains('error')) {
-                placeholder.textContent = 'Error loading block';
+                ui.renderTransclusion(placeholder, note.content, blockId);
+            } else {
+                placeholder.textContent = 'Block not found.';
                 placeholder.classList.add('error');
             }
-        });
+        } catch (error) {
+            console.error(`Error fetching transclusion for block ID ${blockId}:`, error);
+            placeholder.textContent = 'Error loading block.';
+            placeholder.classList.add('error');
+        }
     }
 }
 
-/**
- * Displays backlinks for the current page
- * @param {Array} backlinksData - Array of backlink objects
- */
 function displayBacklinks(backlinksData) {
-    if (!backlinksContainer) { // backlinksContainer is from ui.domRefs
-        console.warn('Backlinks container not found in DOM to display backlinks.');
-        return;
-    }
-
-    // New check for array type
-    if (!Array.isArray(backlinksData)) {
-        console.error('displayBacklinks: backlinksData is not an array. Received:', backlinksData);
-        backlinksContainer.innerHTML = '<p>Error loading backlinks or no backlinks found.</p>';
-        return;
-    }
-
-    // Existing check, now only for length after confirming it's an array
-    if (backlinksData.length === 0) {
+    if (!backlinksContainer) return;
+    if (!Array.isArray(backlinksData) || backlinksData.length === 0) {
         backlinksContainer.innerHTML = '<p>No backlinks found.</p>';
         return;
     }
-
     const html = backlinksData.map(link => `
         <div class="backlink-item">
-            <a href="#" class="page-link" data-page-name="${link.source_page_name}">
-                ${link.source_page_name}
-            </a>
-            <div class="backlink-snippet">${link.content_snippet}</div>
+            <a href="#" class="page-link" data-page-name="${link.page_name}">${link.page_name}</a>
+            <div class="backlink-snippet">${link.content_snippet || ''}</div>
         </div>
     `).join('');
-
     backlinksContainer.innerHTML = html;
 }
 
-// --- Helper Functions ---
+async function displayChildPages(namespace) {
+    const container = document.getElementById('child-pages-container');
+    if (!container) return;
 
-/**
- * Resolves page data from provided data or cache.
- * @param {string} pageName - Name of the page to load.
- * @param {Object} [providedPageData=null] - Optional pre-fetched page data.
- * @returns {Object|null} Page data object if found and valid, otherwise null.
- */
-function _resolvePageDataSource(pageName, providedPageData = null) {
-    if (providedPageData && providedPageData.name === pageName) {
-        console.log(`Using provided page data for: ${pageName}`);
-        // Ensure this provided data is cached for subsequent loads
-        const cacheEntry = {
-            id: providedPageData.id,
-            name: providedPageData.name,
-            alias: providedPageData.alias,
-            notes: providedPageData.notes || [],
-            properties: providedPageData.properties || {},
-            timestamp: Date.now()
-        };
-        setPageCache(pageName, cacheEntry);
-        console.log(`Provided page data for ${pageName} has been cached/updated in cache.`);
-        return cacheEntry; // Return the processed cache entry
-    }
-    if (hasPageCache(pageName) && (Date.now() - getPageCache(pageName).timestamp < CACHE_MAX_AGE_MS)) {
-        const cachedData = getPageCache(pageName);
-        console.log(`Using cached data for page: ${pageName}`);
-        return cachedData;
-    }
-    return null;
-}
-
-/**
- * Fetches page data (details and notes) from the network.
- * Creates journal pages if they don't exist.
- * Caches the fetched data.
- * @param {string} pageName - Name of the page to fetch.
- * @returns {Promise<Object>} Combined page data object (details and notes).
- * @throws {Error} If page not found/creatable or notes fetching fails.
- */
-async function _fetchPageFromNetwork(pageName) {
-    if (!pageName || pageName.trim() === '') {
-        console.warn('_fetchPageFromNetwork called with empty pageName, defaulting to initial page.');
-        pageName = getInitialPage();
-    }
-
-    let pageDetails;
-    // isNewPage declaration is removed as client-side creation decision is removed.
-    // The backend now handles page creation if it doesn't exist,
-    // and will return 201 if created, or 200 if existing.
-    // If an actual error occurs (not related to page existence), it will be caught.
     try {
-        pageDetails = await pagesAPI.getPageByName(pageName);
-        // Optional: If pagesAPI.getPageByName starts returning the full response object
-        // including status, we could determine if it was newly created:
-        // isNewPage = (pageDetails.status === 201); 
-        // For now, we assume pageDetails is just the page data.
-    } catch (error) {
-        // Catch actual errors (network, server errors other than auto-creation path)
-        console.error(`Error fetching page data for ${pageName} via getPageByName:`, error);
-        throw error; // Re-throw the error to be handled by the caller loadPage
-    }
-
-    if (!pageDetails) {
-        // This check might become less relevant if getPageByName always returns a page 
-        // (created or existing) or throws a critical error that's caught above.
-        // However, keeping it as a safeguard for unexpected scenarios.
-        throw new Error(`Page "${pageName}" could not be fetched or created by the backend.`);
-    }
+        const response = await fetch(`api/v1/child_pages.php?namespace=${encodeURIComponent(namespace)}`);
+        if (!response.ok) {
+            console.warn(`Could not fetch child pages for ${namespace}: ${response.statusText}`);
+            container.innerHTML = '';
+            return;
+        }
 
-    let notesArray;
-    try {
-        notesArray = await notesAPI.getPageData(pageDetails.id, { include_internal: false });
-        if (!Array.isArray(notesArray)) {
-            console.warn(`Expected an array from notesAPI.getPageData for page ${pageDetails.name}, received:`, notesArray);
-            notesArray = [];
+        const result = await response.json();
+        const childPages = result.data || [];
+        
+        if (childPages.length > 0) {
+            container.innerHTML = '<h3>Child Pages</h3>';
+            const list = document.createElement('ul');
+            list.className = 'child-page-list';
+            childPages.forEach(page => {
+                const item = document.createElement('li');
+                const link = document.createElement('a');
+                link.href = '#';
+                
+                const displayName = page.name.includes('/') ? page.name.substring(page.name.lastIndexOf('/') + 1) : page.name;
+                link.textContent = displayName;
+
+                link.className = 'child-page-link';
+                link.dataset.pageName = page.name;
+                link.onclick = (e) => {
+                    e.preventDefault();
+                    loadPage(page.name); 
+                };
+                item.appendChild(link);
+                list.appendChild(item);
+            });
+            container.appendChild(list);
+        } else {
+            container.innerHTML = '';
         }
     } catch (error) {
-        console.error(`Error fetching notes for page ${pageDetails.name} (ID: ${pageDetails.id}):`, error.message);
-        notesArray = [];
+        console.error('Error fetching or displaying child pages:', error);
+        container.innerHTML = '';
     }
+}
 
-    const combinedPageData = {
-        ...pageDetails, // Includes id, name, alias, properties
-        notes: notesArray
-        // isNewPage flag is removed from here.
-        // The _processAndRenderPage function's isNewPage parameter will default to false
-        // or could be adjusted if the API provides creation status.
-        // Critical logic like creating the first note relies on notesForCurrentPage.length === 0,
-        // which remains effective.
-    };
-
-    // Cache the newly fetched data
-    if (combinedPageData.id && combinedPageData.name) {
-        const cacheEntry = {
-            id: combinedPageData.id,
-            name: combinedPageData.name,
-            alias: combinedPageData.alias,
-            notes: combinedPageData.notes,
-            properties: combinedPageData.properties || {},
-            timestamp: Date.now()
-        };
-        setPageCache(combinedPageData.name, cacheEntry);
-        console.log(`Page data for ${combinedPageData.name} fetched from network and cached.`);
+export async function handleSqlQueries() {
+    const placeholders = document.querySelectorAll('.sql-query-placeholder');
+    for (const placeholder of placeholders) {
+        const sqlQuery = placeholder.dataset.sqlQuery;
+        if (!sqlQuery) {
+            placeholder.textContent = 'Error: No SQL query provided.';
+            continue;
+        }
+        try {
+            const result = await queryAPI.queryNotes(sqlQuery);
+            const notesArray = result?.data || [];
+            
+            placeholder.innerHTML = '';
+            if (notesArray.length === 0) {
+                placeholder.textContent = 'Query returned no results.';
+            } else {
+                const resultsContainer = document.createElement('div');
+                resultsContainer.className = 'note-children sql-query-results';
+                const parentNestingLevel = ui.getNestingLevel(placeholder.closest('.note-item')) + 1;
+                notesArray.forEach(noteData => {
+                    resultsContainer.appendChild(ui.renderNote(noteData, parentNestingLevel));
+                });
+                placeholder.appendChild(resultsContainer);
+                if (typeof feather !== 'undefined') feather.replace();
+            }
+        } catch (error) {
+            console.error('Error fetching SQL query results:', error);
+            placeholder.textContent = `Error: ${error.message}`;
+        }
     }
-    return combinedPageData;
+}
+
+async function handleCreateAndFocusFirstNote() {
+    if (!currentPageId) return;
+    await handleAddRootNote();
 }
 
 /**
- * Renders the main content of a page (properties, notes, backlinks, dynamic content).
- * @param {Object} pageData - The page data object (must include notes and properties).
- * @param {Object} pageProperties - Extracted page properties.
- * @param {boolean} focusFirstNote - Whether to focus the first note.
- * @param {boolean} [isNewPage=false] - Whether the page was just created.
+ * Renders the main content of a page after data is fetched and processed.
  */
-async function _renderPageContent(pageData, pageProperties, focusFirstNote, isNewPage = false) { // isNewPage param still here, will default to false
-    // Update UI titles (already done in _processAndRenderPage for history state)
-    // window.ui.updatePageTitle(pageData.name); // Redundant if called in _processAndRenderPage
-    // if (window.ui.calendarWidget) window.ui.calendarWidget.setCurrentPage(pageData.name); // Redundant
+async function _renderPageContent(pageData, pageProperties, focusFirstNote) {
+    ui.renderPageInlineProperties(pageProperties, ui.domRefs.pagePropertiesContainer);
+    ui.displayNotes(notesForCurrentPage, pageData.id);
+    ui.updateActivePageLink(pageData.name);
 
-    if (window.ui.domRefs.pagePropertiesContainer && typeof window.ui.renderPageInlineProperties === 'function') {
-        window.ui.renderPageInlineProperties(pageProperties, window.ui.domRefs.pagePropertiesContainer);
-    }
-    
-    // notesForCurrentPage state is already set by _processAndRenderPage
-    window.ui.displayNotes(notesForCurrentPage, pageData.id);
-    window.ui.updateActivePageLink(pageData.name); // Ensure active link is updated
+    const backlinkData = await searchAPI.getBacklinks(pageData.name);
+    displayBacklinks(backlinkData.results || []);
 
-    const backlinks = await searchAPI.getBacklinks(pageData.name);
-    displayBacklinks(backlinks);
-    await handleTransclusions(); // Uses notesForCurrentPage from state
+    await handleTransclusions();
     await handleSqlQueries();
-
-    if (focusFirstNote && notesContainer) {
-        const firstNoteEl = notesContainer.querySelector('.note-content');
-        if (firstNoteEl) window.ui.switchToEditMode(firstNoteEl); // Focus by switching to edit mode
-    }
     
-    // Handle creation of first note if page is new (and empty) or just empty
-    // The `isNewPage` check here was mostly for logging. The core logic `notesForCurrentPage.length === 0`
-    // correctly determines if a first note should be created.
     if (notesForCurrentPage.length === 0 && pageData.id) {
-        console.log(`[_renderPageContent] Page is empty (isNewPage status from client: ${isNewPage}), creating first note.`);
-        await handleCreateAndFocusFirstNote(pageData.id);
-    }
-}
-
-
-/**
- * Handles the password prompt and decryption flow for encrypted pages.
- * @param {Object} pageData - The page data object.
- * @param {Object} pageProperties - Extracted page properties.
- * @param {boolean} focusFirstNote - Whether to focus the first note.
- */
-async function _promptForDecryptionAndRender(pageData, pageProperties, focusFirstNote) {
-    const encryptionPropValue = Array.isArray(pageProperties.encrypt) ? pageProperties.encrypt[0].value : pageProperties.encrypt;
-    currentPageEncryptionKey = encryptionPropValue;
-
-    if (notesContainer) notesContainer.innerHTML = '';
-    if (window.ui.domRefs.pagePropertiesContainer) window.ui.domRefs.pagePropertiesContainer.innerHTML = '';
-    
-    const passwordPromptContainer = document.createElement('div');
-    passwordPromptContainer.id = 'password-prompt-container';
-    passwordPromptContainer.style.padding = '20px';
-    passwordPromptContainer.innerHTML = `
-        <p>This page is encrypted. Please enter the password to decrypt.</p>
-        <input type="password" id="decryption-password-input" placeholder="Password" style="margin-right: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
-        <button id="decrypt-button" style="padding: 8px 12px; background-color: var(--color-accent, #007bff); color: white; border: none; border-radius: 4px; cursor: pointer;">Decrypt</button>
-        <p id="decryption-error" style="color: red; margin-top: 10px;"></p>
-    `;
-    if (notesContainer) {
-        notesContainer.appendChild(passwordPromptContainer);
-    } else {
-        console.error("Notes container not found for password prompt.");
-        return; // Cannot proceed
+        await handleCreateAndFocusFirstNote();
+    } else if (focusFirstNote && notesContainer) {
+        const firstNoteContent = notesContainer.querySelector('.note-content');
+        if (firstNoteContent) ui.switchToEditMode(firstNoteContent);
     }
 
-    const decryptButton = document.getElementById('decrypt-button');
-    const passwordInput = document.getElementById('decryption-password-input');
-    const errorMessageElement = document.getElementById('decryption-error');
-
-    const handleDecrypt = async () => {
-        const enteredPassword = passwordInput.value;
-        if (!enteredPassword) {
-            errorMessageElement.textContent = 'Please enter a password.';
-            return;
-        }
-        try {
-            const hashedPassword = sjcl.hash.sha256.hash(enteredPassword);
-            const hashedPasswordHex = sjcl.codec.hex.fromBits(hashedPassword);
-
-            if (hashedPasswordHex === currentPageEncryptionKey) {
-                decryptionPassword = enteredPassword;
-                passwordPromptContainer.remove();
-                // Call _renderPageContent to render the (now decryptable) page
-                // pageData.isNewPage is no longer set by _fetchPageFromNetwork, will be undefined or false.
-                // This is fine as _renderPageContent's isNewPage param defaults to false.
-                await _renderPageContent(pageData, pageProperties, focusFirstNote, pageData.isNewPage);
-            } else {
-                errorMessageElement.textContent = 'Incorrect password.';
-                passwordInput.value = '';
-            }
-        } catch (error) {
-            console.error('Decryption error:', error);
-            errorMessageElement.textContent = 'An error occurred during decryption.';
-        }
-    };
-
-    decryptButton.addEventListener('click', handleDecrypt);
-    passwordInput.addEventListener('keypress', (event) => {
-        if (event.key === 'Enter') handleDecrypt();
-    });
+    await prefetchLinkedPagesData();
 }
 
 /**
- * Processes page data and orchestrates rendering, including encryption handling.
- * @param {Object} pageData - The page data object (must include notes and properties).
- * @param {boolean} updateHistory - Whether to update browser history.
- * @param {boolean} focusFirstNote - Whether to focus the first note.
- * @param {boolean} [isNewPage=false] - Whether the page was just created.
+ * Processes page data, handles history, and orchestrates rendering (including decryption).
  */
-async function _processAndRenderPage(pageData, updateHistory, focusFirstNote, isNewPage = false) {
+async function _processAndRenderPage(pageData, updateHistory, focusFirstNote) {
+    console.log("Raw pageData:", pageData);
+    console.log("Page Properties:", pageData.properties);
     setCurrentPageName(pageData.name);
     setCurrentPageId(pageData.id);
-    setNotesForCurrentPage(pageData.notes || []); // Ensure notes state is set before any rendering
-    // The isNewPage parameter for _processAndRenderPage is removed from the call in loadPage,
-    // so it will default to false. This is acceptable as its primary use was logging.
-
-    // Breadcrumb generation
-    const pageTitleContainer = document.querySelector('#page-title');
-    if (pageTitleContainer) {
-        pageTitleContainer.innerHTML = ''; // Clear existing title
-        const pageName = pageData.name;
-
-        if (pageName && pageName.includes('/')) {
-            const parts = pageName.split('/');
-            let currentNamespacePath = '';
-            for (let i = 0; i < parts.length - 1; i++) {
-                const part = parts[i];
-                if (currentNamespacePath !== '') {
-                    currentNamespacePath += '/';
-                }
-                currentNamespacePath += part;
-
-                const link = document.createElement('a');
-                link.href = `?page=${encodeURIComponent(currentNamespacePath)}`;
-                link.textContent = part;
-                link.classList.add('namespace-breadcrumb'); // For styling
-                // Add click handler to load page, preventing full page reload if not already handled by global listeners
-                link.addEventListener('click', function(event) {
-                    event.preventDefault(); // Prevent full page reload
-                    loadPage(currentNamespacePath); // Call your existing loadPage function
-                });
-                pageTitleContainer.appendChild(link);
-
-                const separator = document.createTextNode(' / ');
-                pageTitleContainer.appendChild(separator);
-            }
-            // Add the current page name (non-linked)
-            const pageNameText = document.createTextNode(parts[parts.length - 1]);
-            pageTitleContainer.appendChild(pageNameText);
-        } else if (pageName) {
-            // For top-level pages, display just the page name as text
-            const pageNameText = document.createTextNode(pageName);
-            pageTitleContainer.appendChild(pageNameText);
-        }
-
-        // Add the gear icon for page properties
-        const gearIcon = document.createElement('i');
-        gearIcon.dataset.feather = 'settings';
-        gearIcon.className = 'page-title-gear';
-        gearIcon.id = 'page-properties-gear';
-        gearIcon.title = 'Page Properties';
-        pageTitleContainer.appendChild(gearIcon);
-
-        if (typeof feather !== 'undefined') {
-            feather.replace();
-        }
-
-        // The event listener for the gear icon is handled by initPagePropertiesModal in ui.js,
-        // so the redundant listener has been removed from here.
-    } else {
-        console.warn('#page-title not found in the DOM.');
-    }
+    setNotesForCurrentPage(pageData.notes || []);
 
     if (updateHistory) {
         const newUrl = new URL(window.location);
@@ -513,489 +206,176 @@ async function _processAndRenderPage(pageData, updateHistory, focusFirstNote, is
         history.pushState({ pageName: pageData.name }, '', newUrl.toString());
     }
 
-    window.ui.updatePageTitle(pageData.name);
-    if (window.ui.calendarWidget && typeof window.ui.calendarWidget.setCurrentPage === 'function') {
-        window.ui.calendarWidget.setCurrentPage(pageData.name);
-    }
+    ui.updatePageTitle(pageData.name);
+    displayChildPages(pageData.name);
+    if (ui.calendarWidget && ui.calendarWidget.setCurrentPage) ui.calendarWidget.setCurrentPage(pageData.name);
     
     const pageProperties = pageData.properties || {};
+    console.log("Page Properties:", pageProperties);
 
-    if (pageProperties && pageProperties.encrypt) {
-        await _promptForDecryptionAndRender(pageData, pageProperties, focusFirstNote);
-    } else {
-        currentPageEncryptionKey = null;
-        decryptionPassword = null;
-        await _renderPageContent(pageData, pageProperties, focusFirstNote, isNewPage);
-        // Display child pages if the current page acts as a namespace
-        try {
-            // pagesAPI.getPages returns an object like { pages: [...], pagination: ... }.
-            const { pages: pagesArray } = await pagesAPI.getPages({ excludeJournal: true, per_page: 500, include_details: false });
-            
-            // We now expect pagesArray to be a valid array (even if empty).
-            // The displayChildPages function already handles an empty array correctly.
-            await displayChildPages(pageData.name, pagesArray);
+    // --- DECRYPTION FLOW ---
+    const isEncrypted = pageProperties.encrypted?.some(p => String(p.value).toLowerCase() === 'true');
 
-        } catch (error) {
-            console.error('Error fetching or processing pages for child page display:', error);
-            // Optionally, clear or hide the child pages container in case of error
-            const childPagesContainer = document.getElementById('child-pages-container');
-            if (childPagesContainer) {
-                // Clear it or provide a user-friendly error message
-                childPagesContainer.innerHTML = '<p>Error loading pages for this namespace.</p>';
+    if (isEncrypted) {
+        if (!window.decryptionPassword) {
+            try {
+                window.decryptionPassword = await ui.promptForPassword();
+            } catch (error) {
+                console.warn(error.message);
+                ui.displayNotes([{ id: 'error', content: 'Decryption cancelled. Cannot display page content.' }], pageData.id);
+                return; // Stop rendering
             }
         }
-               
-        // Call prefetch for linked pages here, after main page content is processed and rendered
-        prefetchLinkedPagesData().catch(err => console.error("[PrefetchLinked] Background prefetch failed:", err));
+
+        // Decrypt notes content
+        const decryptedNotes = (pageData.notes || []).map(note => {
+            if (note.content) {
+                const decryptedContent = decrypt(note.content, window.decryptionPassword);
+                if (decryptedContent === null) {
+                    // Decryption failed (e.g., wrong password or corrupted data)
+                    return { ...note, content: '[DECRYPTION FAILED]' };
+                }
+                return { ...note, content: decryptedContent };
+            }
+            return note;
+        });
+        setNotesForCurrentPage(decryptedNotes);
+    } else {
+        // Clear password if the page is not encrypted
+        window.decryptionPassword = null;
     }
+    
+    await _renderPageContent(pageData, pageProperties, focusFirstNote);
 }
 
 /**
- * Displays direct child pages for a given parent page name.
- * @param {string} currentPageName - The name of the current page (potential parent).
- * @param {Array<Object>} pagesArray - Array of page objects. Each object is expected to have a 'name' property.
+ * Fetches page data from the network using a "get-then-create" strategy.
+ * @param {string} pageName - The name of the page to fetch or create.
+ * @returns {Promise<Object>} The full page data object including notes.
  */
-async function displayChildPages(currentPageName, pagesArray) {
-    if (!Array.isArray(pagesArray)) {
-        console.error('displayChildPages: pagesArray is not an array. Received:', pagesArray);
-        // Ensure container is cleared if it exists and invalid data was passed
-        const childPagesContainerOnError = document.getElementById('child-pages-container');
-        if (childPagesContainerOnError) {
-            childPagesContainerOnError.innerHTML = '';
+async function _fetchPageFromNetwork(pageName) {
+    let pageDetails;
+    try {
+        pageDetails = await pagesAPI.getPageByName(pageName);
+    } catch (error) {
+        console.warn(`Page "${pageName}" not found, attempting to create. Original error:`, error.message);
+        try {
+            pageDetails = await pagesAPI.createPage(pageName);
+        } catch (createError) {
+            console.error(`Fatal: Failed to CREATE page "${pageName}" after GET failed:`, createError);
+            throw createError;
         }
-        return;
     }
 
-    const directChildren = pagesArray.filter(page => {
-        if (!page || typeof page.name !== 'string') return false;
-        // Check if the page name starts with currentPageName + "/"
-        if (page.name.startsWith(currentPageName + '/')) {
-            // Get the part of the name after "currentPageName/"
-            const childPart = page.name.substring((currentPageName + '/').length);
-            // Ensure it's a direct child (no further slashes in childPart)
-            return childPart && !childPart.includes('/');
-        }
-        return false;
-    });
-
-    let childPagesContainer = document.getElementById('child-pages-container');
-
-    // If no children, ensure container is empty or removed, then return
-    if (directChildren.length === 0) {
-        if (childPagesContainer) {
-            childPagesContainer.innerHTML = ''; // Clear if exists
-            // Optionally remove it: childPagesContainer.remove();
-        }
-        return;
+    if (!pageDetails || !pageDetails.id) {
+        throw new Error(`Could not resolve page data with a valid ID for "${pageName}".`);
     }
 
-    // If container doesn't exist, create and append it
-    if (!childPagesContainer) {
-        childPagesContainer = document.createElement('div');
-        childPagesContainer.id = 'child-pages-container';
-        // Append it after notes container or similar logical place
-        const mainContent = document.getElementById('main-content'); // Assuming main-content div exists
-        const notesContainerElement = document.getElementById('notes-container'); // notesContainer is a JS var, use ID
-        const addRootNoteBtn = document.getElementById('add-root-note-btn');
-        
-        let referenceNode = addRootNoteBtn || notesContainerElement; // Prefer to insert after add button or notes
+    // --- THIS IS THE FIX ---
+    // Explicitly pass the options object to getPageData to avoid ambiguity.
+    const notesArray = await notesAPI.getPageData(pageDetails.id, { include_internal: false });
+    const combinedPageData = { ...pageDetails, notes: Array.isArray(notesArray) ? notesArray : [] };
 
-        if (mainContent && referenceNode && referenceNode.parentNode === mainContent) {
-             // Insert after the referenceNode
-            mainContent.insertBefore(childPagesContainer, referenceNode.nextSibling);
-        } else if (mainContent) { // Fallback: append to main-content if specific anchor not found
-            mainContent.appendChild(childPagesContainer);
-        } else {
-            console.warn('Could not find #main-content or suitable anchor to append #child-pages-container.');
-            // As a last resort, append to document.body, or handle error appropriately
-            document.body.appendChild(childPagesContainer); 
-        }
-    }
-
-    childPagesContainer.innerHTML = ''; // Clear previous content
-
-    const heading = document.createElement('h3'); // Or h2, h4 as appropriate
-    heading.textContent = 'Pages in this namespace:';
-    childPagesContainer.appendChild(heading);
-
-    const listElement = document.createElement('ul'); // Using a list for better structure
-    listElement.classList.add('child-page-list');
-    directChildren.forEach(childPage => {
-        const listItem = document.createElement('li');
-        const link = document.createElement('a');
-        link.href = `?page=${encodeURIComponent(childPage.name)}`;
-        // Display only the short name (part after the last '/')
-        const shortName = childPage.name.substring(childPage.name.lastIndexOf('/') + 1);
-        link.textContent = shortName;
-        link.classList.add('child-page-link');
-        link.dataset.pageName = childPage.name; // Store full name for handler
-
-        link.addEventListener('click', function(event) {
-            event.preventDefault();
-            loadPage(childPage.name); // Use the full childPage.name
-        });
-        listItem.appendChild(link);
-        listElement.appendChild(listItem);
-    });
-    childPagesContainer.appendChild(listElement);
+    setPageCache(pageName, { ...combinedPageData, timestamp: Date.now() });
+    return combinedPageData;
 }
 
 
 /**
- * Loads a page and its notes
- * @param {string} pageNameParam - Name of the page to load
- * @param {boolean} [focusFirstNote=false] - Whether to focus the first note
- * @param {boolean} [updateHistory=true] - Whether to update browser history
- * @param {Object} [providedPageData=null] - Optional pre-fetched page data
+ * Loads a page and its notes, using cache if available. This is the main public function.
  */
-export async function loadPage(pageNameParam, focusFirstNote = false, updateHistory = true, providedPageData = null) {
-    let pageNameToLoad = pageNameParam || getInitialPage();
-    console.log(`Loading page: ${pageNameToLoad}, focusFirstNote: ${focusFirstNote}, updateHistory: ${updateHistory}, providedPageData: ${providedPageData ? providedPageData.name : null}`);
-
-    if (window.blockPageLoad) {
-        console.warn('Page load blocked, possibly due to unsaved changes or ongoing operation.');
-        return;
-    }
+export async function loadPage(pageName, focusFirstNote = false, updateHistory = true, providedPageData = null) {
+    if (window.blockPageLoad) return;
     window.blockPageLoad = true;
     
-    // Reset global encryption state for the new page
-    currentPageEncryptionKey = null;
-    decryptionPassword = null;
+    pageName = pageName || getInitialPage();
 
     try {
-        let pageData = _resolvePageDataSource(pageNameToLoad, providedPageData);
-        let source = 'cache_or_provided';
+        let pageData = providedPageData;
+        const cachedPage = getPageCache(pageName);
 
+        if (!pageData && cachedPage && (Date.now() - cachedPage.timestamp < CACHE_MAX_AGE_MS)) {
+            pageData = cachedPage;
+        }
+        
         if (!pageData) {
             if (notesContainer) notesContainer.innerHTML = '<p>Loading page...</p>';
-            if (window.ui.domRefs.pagePropertiesContainer) window.ui.domRefs.pagePropertiesContainer.innerHTML = '';
-            
-            pageData = await _fetchPageFromNetwork(pageNameToLoad);
-            source = 'network';
-            console.log(`Page data for ${pageNameToLoad} fetched from ${source}.`);
-        } else {
-            console.log(`Page data for ${pageNameToLoad} resolved from ${source}.`);
+            pageData = await _fetchPageFromNetwork(pageName);
         }
         
-        if (pageData) {
-            // pageData.isNewPage is no longer set by _fetchPageFromNetwork.
-            // The third argument to _processAndRenderPage (isNewPage) will be undefined here,
-            // and will default to false within _processAndRenderPage. This is acceptable.
-            await _processAndRenderPage(pageData, updateHistory, focusFirstNote, pageData.isNewPage);
-        } else {
-            // This case should ideally be caught by errors in _fetchPageFromNetwork
-            throw new Error(`Failed to obtain page data for ${pageNameToLoad} from any source.`);
-        }
-
+        await _processAndRenderPage(pageData, updateHistory, focusFirstNote);
     } catch (error) {
-        console.error(`Error loading page ${pageNameToLoad}:`, error);
-        setCurrentPageName(`Error: ${pageNameToLoad}`);
+        console.error(`Error loading page ${pageName}:`, error);
+        setCurrentPageName(`Error: ${pageName}`);
         setCurrentPageId(null);
-        if (typeof window !== 'undefined' && window.ui) { // Ensure ui is available
-           window.ui.updatePageTitle(currentPageName); // Use state's currentPageName
-        }
-        if (notesContainer) {
-            notesContainer.innerHTML = `<p>Error loading page: ${error.message}</p>`;
-        }
+        ui.updatePageTitle(currentPageName);
+        if (notesContainer) notesContainer.innerHTML = `<p>Error loading page: ${error.message}</p>`;
     } finally {
         window.blockPageLoad = false;
     }
 }
 
-
 /**
- * Handles SQL query placeholders and fetches/renders their results.
+ * Fetches data for pages linked from the current page to improve navigation speed.
  */
-export async function handleSqlQueries() {
-    const placeholders = document.querySelectorAll('.sql-query-placeholder');
-    if (placeholders.length === 0) {
-        // console.log('No SQL query placeholders found.');
-        return;
-    }
-    console.log(`Found ${placeholders.length} SQL query placeholders.`);
-
-    for (const placeholder of placeholders) {
-        const sqlQuery = placeholder.dataset.sqlQuery;
-        if (!sqlQuery) {
-            placeholder.textContent = 'Error: No SQL query provided in data attribute.';
-            placeholder.classList.add('error');
-            continue;
-        }
-
-        try {
-            // Call queryAPI.queryNotes and ensure we get the notes array
-            const response = await queryAPI.queryNotes(sqlQuery);
-            
-            // Ensure we have a valid array of notes
-            const notesArray = Array.isArray(response) ? response : 
-                             (response && Array.isArray(response.data) ? response.data : []);
-            
-            placeholder.innerHTML = ''; 
-            if (notesArray.length === 0) {
-                placeholder.textContent = 'Query returned no results.';
-            } else {
-                const childrenContainer = document.createElement('div');
-                childrenContainer.className = 'note-children sql-query-results';
-
-                notesArray.forEach(noteData => {
-                    const parentNoteItem = placeholder.closest('.note-item');
-                    let nestingLevel = 0;
-                    if (parentNoteItem) {
-                        const currentNesting = parseInt(parentNoteItem.style.getPropertyValue('--nesting-level') || '0');
-                        nestingLevel = currentNesting + 1;
-                    }
-                    if (window.ui && typeof window.ui.renderNote === 'function') {
-                        const noteElement = window.ui.renderNote(noteData, nestingLevel);
-                        childrenContainer.appendChild(noteElement);
-                    } else {
-                        console.error('window.ui.renderNote is not available to render SQL query results.');
-                        placeholder.textContent = 'Error: UI function to render notes is missing.';
-                        placeholder.classList.add('error');
-                        return; 
-                    }
-                });
-                placeholder.appendChild(childrenContainer);
-                if (typeof feather !== 'undefined' && feather.replace) {
-                     feather.replace(); 
-                }
-            }
-            placeholder.classList.add('loaded'); 
-        } catch (error) {
-            console.error('Error fetching SQL query results for query:', sqlQuery, error);
-            placeholder.textContent = `Error loading query results: ${error.message}`;
-            placeholder.classList.add('error');
-            placeholder.classList.add('loaded'); 
-        }
-    }
-}
-
-/**
- * Creates the very first note on an empty page and focuses it.
- */
-async function handleCreateAndFocusFirstNote(pageIdToUse) { 
-    if (!pageIdToUse) {
-        console.warn("Cannot create first note without a pageIdToUse.");
-        return;
-    }
-    try {
-        console.log(`[NOTE CREATION] Creating first note for page ${pageIdToUse}`);
-        const savedNote = await notesAPI.createNote({
-            page_id: pageIdToUse, 
-            content: '',
-            order_index: 0 // Explicitly set order_index to 0 for first note
-        });
-
-        if (savedNote) {
-            console.log(`[NOTE CREATION] Received from server: id=${savedNote.id}, server_assigned_order_index=${savedNote.order_index}, content="${savedNote.content}"`);
-            
-            // Clear any existing notes in the container
-            if (notesContainer) {
-                notesContainer.innerHTML = '';
-            }
-            
-            // Update the global state with just this one note
-            setNotesForCurrentPage([savedNote]);
-            
-            // Render the note
-            const noteEl = window.ui.renderNote(savedNote, 0);
-            if (notesContainer) {
-                notesContainer.appendChild(noteEl);
-            }
-            
-            // Focus the new note
-            const contentDiv = noteEl.querySelector('.note-content');
-            if (contentDiv) {
-                contentDiv.dataset.rawContent = '';
-                window.ui.switchToEditMode(contentDiv);
-                
-                const initialInputHandler = async (e) => {
-                    const currentContent = contentDiv.textContent.trim();
-                    if (currentContent !== '') {
-                        contentDiv.dataset.rawContent = currentContent;
-                        await saveNoteImmediately(noteEl);
-                        contentDiv.removeEventListener('input', initialInputHandler);
-                    }
-                };
-                contentDiv.addEventListener('input', initialInputHandler);
-            }
-            
-            if (typeof feather !== 'undefined' && feather.replace) {
-                feather.replace();
-            }
-        }
-    } catch (error) {
-        console.error('Error creating the first note for the page:', error);
-        if (notesContainer) {
-            notesContainer.innerHTML = '<p>Error creating the first note. Please try reloading.</p>';
-        }
-    }
-}
-
-
 export async function prefetchLinkedPagesData() {
-    if (!currentPageId || !notesForCurrentPage || notesForCurrentPage.length === 0) {
-        console.log("[PrefetchLinked] No current page or notes to scan for links.");
-        return;
-    }
-
-    console.log(`[PrefetchLinked] Starting pre-fetch for links on page: ${currentPageName}`);
+    if (!notesForCurrentPage) return;
     const linkedPageNames = new Set();
-    const pageLinkRegex = /\[\[([^\]]+)\]\]/g; // Regex to find [[Page Name]]
+    const pageLinkRegex = /\[\[([^\]]+)\]\]/g;
 
     notesForCurrentPage.forEach(note => {
         if (note.content) {
-            let match;
-            while ((match = pageLinkRegex.exec(note.content)) !== null) {
-                const pageName = match[1].trim();
-                // Normalize potential alias: [[Actual Name|Display Text]]
-                const parts = pageName.split('|');
-                const actualPageName = parts[0].trim();
-                if (actualPageName) {
-                    linkedPageNames.add(actualPageName);
-                }
-            }
+            [...note.content.matchAll(pageLinkRegex)].forEach(match => {
+                const pageName = match[1].trim().split('|')[0].trim();
+                if (pageName) linkedPageNames.add(pageName);
+            });
         }
     });
 
-    if (linkedPageNames.size === 0) {
-        console.log("[PrefetchLinked] No unique page links found in current page notes.");
-        return;
-    }
-
     let prefetchCounter = 0;
-    for (const pageName of linkedPageNames) {
-        if (prefetchCounter >= MAX_LINKED_PAGES_TO_PREFETCH) {
-            console.log(`[PrefetchLinked] Reached max linked pages to prefetch (${MAX_LINKED_PAGES_TO_PREFETCH}).`);
-            break;
-        }
-
-        if (pageName === currentPageName) continue; // Don't prefetch current page
-
-        if (hasPageCache(pageName) && (Date.now() - getPageCache(pageName).timestamp < CACHE_MAX_AGE_MS)) {
-            console.log(`[PrefetchLinked] Page ${pageName} is already in cache and recent. Skipping.`);
-            continue;
-        }
-
-        console.log(`[PrefetchLinked] Pre-fetching data for linked page: ${pageName}`);
+    for (const name of linkedPageNames) {
+        if (prefetchCounter >= MAX_PREFETCH_PAGES) break;
+        if (name === currentPageName || hasPageCache(name)) continue;
+        
         try {
-            const pageDetails = await pagesAPI.getPageByName(pageName);
-            if (!pageDetails || !pageDetails.id) {
-                console.warn(`[PrefetchLinked] Could not get details for page: ${pageName}. Skipping.`);
-                continue;
-            }
-
-            let notesArray = await notesAPI.getPageData(pageDetails.id, { include_internal: false });
-            if (!Array.isArray(notesArray)) {
-                console.warn(`[PrefetchLinked] Expected an array from notesAPI.getPageData for page ${pageDetails.name}, received:`, notesArray);
-                notesArray = [];
-            }
-
-            setPageCache(pageName, {
-                id: pageDetails.id,
-                name: pageDetails.name,
-                alias: pageDetails.alias,
-                notes: notesArray,
-                properties: pageDetails.properties || {},
-                timestamp: Date.now()
-            });
-            console.log(`[PrefetchLinked] Successfully pre-fetched and cached data for linked page: ${pageName}`);
+            await _fetchPageFromNetwork(name); // This will fetch and cache
             prefetchCounter++;
-
         } catch (error) {
-            console.error(`[PrefetchLinked] Error pre-fetching data for linked page ${pageName}:`, error);
-            if (hasPageCache(pageName)) {
-                 deletePageCache(pageName);
-            }
+            console.warn(`[Prefetch] Failed to prefetch linked page ${name}:`, error.message);
         }
     }
-    console.log("[PrefetchLinked] Pre-fetching for linked pages completed.");
 }
 
 /**
- * Pre-fetches data for recently updated pages to improve perceived performance.
- * Caches page details, notes, and properties.
+ * Pre-fetches data for the most recently updated pages.
  */
 export async function prefetchRecentPagesData() {
-    console.log("Starting pre-fetch for recent pages.");
     try {
-        const { pages: allPages } = await pagesAPI.getPages({
-            include_details: true, 
-            include_internal: false, 
-            followAliases: true,     
-            excludeJournal: false    
-        });
-        
-        allPages.sort((a, b) => {
-            // Assuming the structure is { page: { updated_at: ... } }
-            // If updated_at is directly on the outer object, this needs adjustment
-            const dateA = a.page ? new Date(a.page.updated_at) : 0;
-            const dateB = b.page ? new Date(b.page.updated_at) : 0;
-            return dateB - dateA;
-        });
-
-        const recentPagesToPrefetch = allPages.slice(0, MAX_PREFETCH_PAGES); 
-
-        for (const pageWithNotes of recentPagesToPrefetch) { // Renamed 'page' to 'pageWithNotes' for clarity
-            const actualPage = pageWithNotes.page; // Extract the actual page object
-            if (!actualPage) {
-                console.warn('Page object within wrapper is missing during pre-fetch. Skipping.', pageWithNotes);
-                continue;
-            }
-
-            if (!hasPageCache(actualPage.name) ||
-                (Date.now() - (getPageCache(actualPage.name)?.timestamp || 0) > CACHE_MAX_AGE_MS)) {
-                
-                console.log(`Pre-fetching data for page: ${actualPage.name}`);
-                try {
-                    if (!actualPage.id || !actualPage.name) {
-                        console.warn(`Actual page object for pre-fetch is missing id or name. Skipping.`, actualPage);
-                        continue;
-                    }
-                    
-                    // notes are at pageWithNotes.notes, properties are at actualPage.properties (or pageWithNotes.page.properties)
-                    const notes = pageWithNotes.notes || []; 
-                    const properties = actualPage.properties || {}; 
-
-                    setPageCache(actualPage.name, {
-                        id: actualPage.id,
-                        name: actualPage.name, 
-                        alias: actualPage.alias, 
-                        notes: notes,      
-                        properties: properties, 
-                        timestamp: Date.now()
-                    });
-                    console.log(`Successfully pre-fetched and cached data for page: ${actualPage.name}`);
-                } catch (error) {
-                    console.error(`Error pre-fetching data for page ${actualPage.name}:`, error);
-                    if (hasPageCache(actualPage.name)) {
-                        deletePageCache(actualPage.name);
-                    }
-                }
-            } else {
-                console.log(`Page ${actualPage.name} is already in cache and recent.`);
+        const { pages } = await pagesAPI.getPages({ sort_by: 'updated_at', sort_order: 'desc', per_page: MAX_PREFETCH_PAGES });
+        for (const page of pages) {
+            if (page.name === currentPageName || hasPageCache(page.name)) continue;
+            try {
+                await _fetchPageFromNetwork(page.name);
+            } catch (error) {
+                console.warn(`[Prefetch] Failed to prefetch recent page ${page.name}:`, error.message);
             }
         }
-        console.log("Pre-fetching for recent pages completed.");
     } catch (error) {
-        console.error('Error fetching page list for pre-fetching:', error);
+        console.error('Error in prefetchRecentPagesData:', error);
     }
 }
 
 /**
- * Fetches and displays the page list
- * @param {string} [activePageName] - Name of the page to mark as active
+ * Fetches and displays the page list in the sidebar.
  */
 export async function fetchAndDisplayPages(activePageName) {
-    const pageListContainer = window.ui.domRefs.pageListContainer; 
-    if (!pageListContainer) {
-        console.error("pageListContainer not found in fetchAndDisplayPages");
-        return;
-    }
     try {
-        const { pages } = await pagesAPI.getPages();
-        window.ui.updatePageList(pages, activePageName || currentPageName);
+        const { pages } = await pagesAPI.getPages({ per_page: 20, sort_by: 'updated_at', sort_order: 'desc' });
+        ui.updatePageList(pages, activePageName || currentPageName);
     } catch (error) {
-        console.error('Error fetching pages:', error);
-        pageListContainer.innerHTML = '<li>Error loading pages.</li>';
+        console.error('Error fetching pages for sidebar:', error);
+        if (ui.domRefs.pageListContainer) {
+            ui.domRefs.pageListContainer.innerHTML = '<li>Error loading pages.</li>';
+        }
     }
-}
+}
\ No newline at end of file
diff --git a/assets/js/app/property-editor.js b/assets/js/app/property-editor.js
index 19281a3..5626c10 100644
--- a/assets/js/app/property-editor.js
+++ b/assets/js/app/property-editor.js
@@ -1,558 +1,200 @@
 import { currentPageId } from './state.js';
 import { ui } from '../ui.js';
-import { propertiesAPI } from '../api_client.js';
+import { pagesAPI } from '../api_client.js';
 
-function handleAddPropertyButtonClick() {
-    const pagePropertiesList = ui.domRefs.pagePropertiesList;
-    if (!pagePropertiesList) {
-        console.error('pagePropertiesList element not found for adding property!');
-        return;
-    }
-
-    const noPropertiesMessage = pagePropertiesList.querySelector('p.no-properties-message');
-    if (noPropertiesMessage) {
-        noPropertiesMessage.remove();
-    }
-
-    const propItem = document.createElement('div');
-    propItem.className = 'page-property-item new-property-row';
-    // const uniqueIdSuffix = Date.now(); // Not strictly needed for ID if we grab element directly
-
-    propItem.innerHTML = `
-        <span class="page-property-key" contenteditable="true" data-original-key="" data-is-new="true" placeholder="PropertyName"></span>
-        <span class="page-property-separator">:</span>
-        <input type="text" class="page-property-value" data-property="" value="" data-is-new-value="true" placeholder="PropertyValue" />
-        <button class="page-property-delete" data-property="" data-is-new-delete="true" title="Remove this new property">&times;</button>
-    `;
-    pagePropertiesList.appendChild(propItem);
+let pageContentForModal = '';
 
-    const newKeySpan = propItem.querySelector('.page-property-key');
-    if (newKeySpan) {
-        newKeySpan.focus();
-        const selection = window.getSelection();
-        const range = document.createRange();
-        range.selectNodeContents(newKeySpan); // Selects placeholder text if any, or just sets cursor if empty
-        selection.removeAllRanges();
-        selection.addRange(range);
-    }
-    if (typeof feather !== 'undefined' && feather.replace) {
-        feather.replace(); // Refresh icons for the new delete button
-    }
-}
-
-function setupAddPropertyButtonListener() {
-    const addBtn = ui.domRefs.addPagePropertyBtn;
-    if (addBtn && !addBtn.dataset.listenerAttached) {
-        addBtn.addEventListener('click', handleAddPropertyButtonClick);
-        addBtn.dataset.listenerAttached = 'true';
-    }
-}
-
-/**
- * Displays page properties in the modal.
- * (This is the version from app.js, to be used by the modal)
- * @param {Object} properties - Properties object for the current page.
- */
-export function displayPageProperties(properties) {
-    const pagePropertiesList = ui.domRefs.pagePropertiesList; // Assumes ui.domRefs is available
-    if (!pagePropertiesList) {
-        console.error('pagePropertiesList element not found!');
-        return;
-    }
-    pagePropertiesList.innerHTML = '';
-    
-    const showInternal = window.APP_CONFIG && window.APP_CONFIG.SHOW_INTERNAL_PROPERTIES_IN_EDIT_MODE !== false; // Default to true if undefined
-
-    let propertiesExistToDisplay = false;
-
-    if (properties && Object.keys(properties).length > 0) {
-        Object.entries(properties).forEach(([key, propertyInstancesArray]) => {
-            // propertyInstancesArray is expected to be like [{value: 'v1', internal: 0}, {value: 'v2', internal: 1}]
-            if (Array.isArray(propertyInstancesArray)) {
-                propertyInstancesArray.forEach((instance, index) => {
-                    if (instance.internal && !showInternal) {
-                        return; // Skip this internal property instance
-                    }
-                    propertiesExistToDisplay = true;
-                    const propItem = document.createElement('div');
-                    propItem.className = 'page-property-item';
-                    if (instance.internal) {
-                        propItem.classList.add('page-property-internal');
-                    }
-
-                    propItem.innerHTML = `
-                        <span class="page-property-key" contenteditable="true" data-original-key="${key}" data-is-array="true" data-array-index="${index}">${key}</span>
-                        <span class="page-property-separator">:</span>
-                        <input type="text" class="page-property-value" data-property="${key}" data-array-index="${index}" data-original-value="${instance.value}" value="${instance.value}" />
-                        <button class="page-property-delete" data-property="${key}" data-array-index="${index}" title="Delete this ${key} value"></button>
-                    `;
-                    pagePropertiesList.appendChild(propItem);
-                });
-            } else {
-                // This else block handles cases where propertyInstancesArray is not an array.
-                // Assuming it might be a single instance object {value: ..., internal: ...}
-                // This structure is not what the current API (after DataManager) provides, but handling defensively.
-                const instance = propertyInstancesArray; // Treat it as a single instance
-                if (typeof instance === 'object' && instance !== null && instance.hasOwnProperty('value') && instance.hasOwnProperty('internal')) {
-                    if (instance.internal && !showInternal) {
-                        return; // Skip this internal property instance
-                    }
-                    propertiesExistToDisplay = true;
-                    const propItem = document.createElement('div');
-                    propItem.className = 'page-property-item';
-                    if (instance.internal) {
-                        propItem.classList.add('page-property-internal');
-                    }
-                    propItem.innerHTML = `
-                        <span class="page-property-key" contenteditable="true" data-original-key="${key}">${key}</span>
-                        <span class="page-property-separator">:</span>
-                        <input type="text" class="page-property-value" data-property="${key}" data-original-value="${instance.value}" value="${instance.value}" />
-                        <button class="page-property-delete" data-property="${key}" title="Delete ${key} property"></button>
-                    `;
-                    pagePropertiesList.appendChild(propItem);
-                } else if (typeof instance !== 'object') { // Simple value, assume not internal
-                    propertiesExistToDisplay = true;
-                    const propItem = document.createElement('div');
-                    propItem.className = 'page-property-item'; // No internal class for simple values
-                    propItem.innerHTML = `
-                        <span class="page-property-key" contenteditable="true" data-original-key="${key}">${key}</span>
-                        <span class="page-property-separator">:</span>
-                        <input type="text" class="page-property-value" data-property="${key}" data-original-value="${instance || ''}" value="${instance || ''}" />
-                        <button class="page-property-delete" data-property="${key}" title="Delete ${key} property"></button>
-                    `;
-                    pagePropertiesList.appendChild(propItem);
-                }
-            }
-        });
-    }
-
-    if (!propertiesExistToDisplay) {
-        pagePropertiesList.innerHTML = '<p class="no-properties-message">No properties to display (or all are hidden).</p>';
-    }
-    
-    // Listeners should be set up regardless of whether properties were found, for "Add Property" button etc.
-    setupPagePropertiesModalListeners(); // Original position for this was inside the initial if/else
-
-    const existingListener = pagePropertiesList._propertyEventListener;
-    if (existingListener) {
-        pagePropertiesList.removeEventListener('blur', existingListener, true);
-        pagePropertiesList.removeEventListener('keydown', existingListener);
-        pagePropertiesList.removeEventListener('click', existingListener);
-        pagePropertiesList.removeEventListener('change', existingListener);
-    }
-    const propertyEventListener = async (e) => {
-        // Change on property value
-        if (e.type === 'change' && e.target.matches('.page-property-value')) {
-            const valueInput = e.target;
-            const keyForValue = valueInput.dataset.property;
-            const finalNewValue = valueInput.value.trim(); 
-            const originalValue = valueInput.dataset.originalValue;
-
-            if (valueInput.dataset.isNewValue === 'true') {
-                if (!keyForValue) {
-                    // console.warn("Attempted to save a new property value, but its key is not set.");
-                    // If the key is empty, the blur handler for the key should have removed the row.
-                    // If for some reason it's still here with an empty key, don't save.
-                    const keySpan = valueInput.closest('.page-property-item')?.querySelector('.page-property-key');
-                    if (!keySpan || !keySpan.textContent.trim()) {
-                         valueInput.closest('.page-property-item')?.remove(); // Clean up row if key is truly empty
-                         if (ui.domRefs.pagePropertiesList.children.length === 0 && !ui.domRefs.pagePropertiesList.querySelector('p.no-properties-message')) {
-                            ui.domRefs.pagePropertiesList.innerHTML = '<p class="no-properties-message">No properties set for this page.</p>';
-                         }
-                    }
-                    return; 
-                }
-                await addPageProperty(keyForValue, finalNewValue); 
-                valueInput.dataset.originalValue = finalNewValue; 
-                delete valueInput.dataset.isNewValue;
-
-                const propertyItemRow = valueInput.closest('.page-property-item');
-                const deleteButton = propertyItemRow.querySelector('.page-property-delete');
-                if (deleteButton && deleteButton.dataset.isNewDelete) {
-                    delete deleteButton.dataset.isNewDelete;
-                    deleteButton.title = `Delete ${keyForValue} property`;
-                }
-                const keySpan = propertyItemRow.querySelector('.page-property-key');
-                if (keySpan && keySpan.dataset.isNew){ 
-                    delete keySpan.dataset.isNew;
-                    keySpan.dataset.originalKey = keyForValue; 
-                }
-
-            } else {
-                // Existing logic for updating property value
-                if (finalNewValue !== originalValue) {
-                    const arrayIndexStr = valueInput.dataset.arrayIndex;
-                    if (arrayIndexStr !== undefined) {
-                        await updateArrayPropertyValue(keyForValue, parseInt(arrayIndexStr), finalNewValue);
-                    } else {
-                        await updatePageProperty(keyForValue, finalNewValue);
-                    }
-                    valueInput.dataset.originalValue = finalNewValue;
-                }
-            }
-        } else if (e.type === 'blur' && e.target.matches('.page-property-key')) {
-            // Blur on property key
-            const keySpan = e.target;
-            const propertyItemRow = keySpan.closest('.page-property-item');
-
-            if (keySpan.dataset.isNew === 'true') {
-                const newKeyName = keySpan.textContent.trim();
-
-                if (!newKeyName && propertyItemRow) {
-                    propertyItemRow.remove();
-                    if (ui.domRefs.pagePropertiesList.children.length === 0 && !ui.domRefs.pagePropertiesList.querySelector('p.no-properties-message')) {
-                        ui.domRefs.pagePropertiesList.innerHTML = '<p class="no-properties-message">No properties set for this page.</p>';
-                    }
-                    return; 
-                }
-                
-                keySpan.dataset.originalKey = newKeyName;
-                delete keySpan.dataset.isNew; 
-
-                const valueInput = propertyItemRow.querySelector('.page-property-value');
-                valueInput.dataset.property = newKeyName; 
-
-                const deleteButton = propertyItemRow.querySelector('.page-property-delete');
-                deleteButton.dataset.property = newKeyName;
-                deleteButton.title = `Delete ${newKeyName} property`; 
-                if (deleteButton.dataset.isNewDelete) {
-                    delete deleteButton.dataset.isNewDelete;
-                }
-                
-                if (valueInput.value.trim() !== '' && valueInput.dataset.isNewValue === 'true') {
-                   valueInput.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
-                } else if (valueInput.value.trim() === '' && valueInput.dataset.isNewValue === 'true') {
-                    // Also dispatch change for empty new values to ensure they are processed (e.g. saved as empty or potentially validated)
-                    valueInput.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
-                }
-
-            } else {
-                // Existing logic for renaming property key
-                const originalKey = keySpan.dataset.originalKey;
-                const newKey = keySpan.textContent.trim();
-                if (newKey !== originalKey && newKey !== '') {
-                    const isArray = keySpan.dataset.isArray === 'true';
-                    const arrayIndexStr = keySpan.dataset.arrayIndex; 
-
-                    if (isArray && arrayIndexStr !== undefined) { 
-                        await renameArrayPropertyKey(originalKey, newKey, parseInt(arrayIndexStr));
-                    } else {
-                        await renamePropertyKey(originalKey, newKey);
-                    }
-                    keySpan.dataset.originalKey = newKey; 
-                } else if (newKey === '' && originalKey) { 
-                    keySpan.textContent = originalKey; 
-                }
-            }
-        } else if (e.type === 'keydown' && e.key === 'Enter') {
-            if (e.target.matches('.page-property-value')) {
-                e.target.dispatchEvent(new Event('change', { bubbles: true }));
-            } else if (e.target.matches('.page-property-key')) {
-                e.target.blur();
-            }
-        } else if (e.type === 'click' && e.target.matches('.page-property-delete')) {
-            // Click on delete button
-            const deleteButton = e.target;
-            const propertyItemRow = deleteButton.closest('.page-property-item');
-
-            if (deleteButton.dataset.isNewDelete === 'true') {
-                if (propertyItemRow) propertyItemRow.remove(); 
-                if (ui.domRefs.pagePropertiesList.children.length === 0 && !ui.domRefs.pagePropertiesList.querySelector('p.no-properties-message')) {
-                    ui.domRefs.pagePropertiesList.innerHTML = '<p class="no-properties-message">No properties set for this page.</p>';
-                }
-            } else {
-                // Existing logic for deleting property (with confirmation)
-                const key = deleteButton.dataset.property;
-                const arrayIndexStr = deleteButton.dataset.arrayIndex;
-                let confirmMessage = arrayIndexStr !== undefined ? `Are you sure you want to delete this "${key}" value?` : `Are you sure you want to delete the property "${key}"?`;
-                
-                const confirmed = await ui.showGenericConfirmModal('Delete Property', confirmMessage); 
-                if (confirmed) {
-                    if (arrayIndexStr !== undefined) {
-                        await deleteArrayPropertyValue(key, parseInt(arrayIndexStr));
-                    } else {
-                        await deletePageProperty(key);
-                    }
-                }
-            }
+function parsePropertiesFromContent(content) {
+    const properties = {};
+    if (!content) return properties;
+    const regex = /\{([^:}]+):(:{2,})([^}]+)\}/g;
+    let match;
+    while ((match = regex.exec(content)) !== null) {
+        const key = match[1].trim();
+        const value = match[3].trim();
+        const weight = match[2].length;
+        if (!properties[key]) {
+            properties[key] = [];
         }
-    };
-    pagePropertiesList._propertyEventListener = propertyEventListener;
-    pagePropertiesList.addEventListener('blur', propertyEventListener, true);
-    pagePropertiesList.addEventListener('keydown', propertyEventListener);
-    pagePropertiesList.addEventListener('click', propertyEventListener);
-    pagePropertiesList.addEventListener('change', propertyEventListener);
-    
-    // Set up the encryption icon listener
-    setupPagePropertiesModalListeners();
-    
-    setupAddPropertyButtonListener(); // Ensure the listener for the Add button is active
-
-    if (typeof feather !== 'undefined' && feather.replace) feather.replace();
+        properties[key].push({ value, internal: weight > 2 });
+    }
+    return properties;
 }
 
-export async function renamePropertyKey(oldKey, newKey) {
-    if (!currentPageId) return;
-    try {
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        const value = properties[oldKey];
-        if (value === undefined) { console.warn(`Property ${oldKey} not found for renaming`); return; }
-        await propertiesAPI.deleteProperty('page', currentPageId, oldKey);
-        await propertiesAPI.setProperty({ entity_type: 'page', entity_id: currentPageId, name: newKey, value: value });
-        const updatedProperties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(updatedProperties); // Assumes this function is available in this module
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error renaming property key:', error); alert('Failed to rename property');
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(properties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
+function rebuildContentWithProperties(originalContent, properties) {
+    let cleanContent = (originalContent || '').replace(/\{([^:}]+):(:{2,})([^}]+)\}\n?/g, '').trim();
+    let propertiesString = '';
+    for (const [key, instances] of Object.entries(properties)) {
+        if (!instances) continue;
+        for (const instance of instances) {
+            const colons = instance.internal ? ':::' : '::';
+            propertiesString += `{${key}${colons}${instance.value}}\n`;
         }
     }
+    // Only add a newline if there's content AND properties.
+    const separator = (cleanContent && propertiesString) ? '\n\n' : '';
+    return cleanContent + separator + propertiesString.trim();
 }
 
-export async function renameArrayPropertyKey(oldKey, newKey, arrayIndex) { // arrayIndex was missing
-    if (!currentPageId) return;
+async function _updatePageContent(newContent) {
     try {
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        const values = properties[oldKey];
-        if (!Array.isArray(values)) { console.warn(`Property ${oldKey} is not an array for renaming`); return; }
-        await propertiesAPI.deleteProperty('page', currentPageId, oldKey);
-        for (const value of values) {
-            await propertiesAPI.setProperty({ entity_type: 'page', entity_id: currentPageId, name: newKey, value: value });
-        }
-        const updatedProperties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(updatedProperties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
-        }
+        ui.updateSaveStatusIndicator('pending');
+        const updatedPage = await pagesAPI.updatePage(currentPageId, { content: newContent });
+        pageContentForModal = updatedPage.content || '';
+        // The properties are now derived from the returned content, so we pass the new properties to the UI.
+        displayPageProperties(updatedPage.properties || {});
+        ui.renderPageInlineProperties(updatedPage.properties || {}, ui.domRefs.pagePropertiesContainer);
+        ui.updateSaveStatusIndicator('saved');
     } catch (error) {
-        console.error('Error renaming array property key:', error); alert('Failed to rename property');
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(properties);
-         if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
+        console.error("Failed to update page content:", error);
+        alert("Failed to save property changes.");
+        ui.updateSaveStatusIndicator('error');
     }
 }
 
-export async function updateArrayPropertyValue(key, arrayIndex, newValue) {
-    if (!currentPageId) return;
-    try {
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        const values = properties[key];
-        if (!Array.isArray(values) || arrayIndex >= values.length) { console.warn(`Invalid array property update: ${key}[${arrayIndex}]`); return; }
-        await propertiesAPI.deleteProperty('page', currentPageId, key);
-        for (let i = 0; i < values.length; i++) {
-            const value = i === arrayIndex ? newValue : values[i];
-            await propertiesAPI.setProperty({ entity_type: 'page', entity_id: currentPageId, name: key, value: value });
-        }
-        const updatedProperties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(updatedProperties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error updating array property value:', error); alert('Failed to update property value');
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(properties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
+// --- CORE CRUD Functions for Properties ---
+
+async function addPageProperty(key, value, isInternal = false) {
+    const properties = parsePropertiesFromContent(pageContentForModal);
+    if (!properties[key]) {
+        properties[key] = [];
     }
+    properties[key].push({ value, internal: isInternal });
+    const newContent = rebuildContentWithProperties(pageContentForModal, properties);
+    await _updatePageContent(newContent);
 }
 
-export async function deleteArrayPropertyValue(key, arrayIndex) {
-    if (!currentPageId) return;
-    try {
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        const values = properties[key];
-        if (!Array.isArray(values) || arrayIndex >= values.length) { console.warn(`Invalid array property deletion: ${key}[${arrayIndex}]`); return; }
-        await propertiesAPI.deleteProperty('page', currentPageId, key);
-        const remainingValues = values.filter((_, i) => i !== arrayIndex);
-        for (const value of remainingValues) {
-            await propertiesAPI.setProperty({ entity_type: 'page', entity_id: currentPageId, name: key, value: value });
-        }
-        const updatedProperties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(updatedProperties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error deleting array property value:', error); alert('Failed to delete property value');
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(properties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
+async function deletePageProperty(key, index) {
+    const properties = parsePropertiesFromContent(pageContentForModal);
+    if (properties[key] && properties[key][index] !== undefined) {
+        properties[key].splice(index, 1);
+        if (properties[key].length === 0) {
+            delete properties[key];
         }
     }
+    const newContent = rebuildContentWithProperties(pageContentForModal, properties);
+    await _updatePageContent(newContent);
 }
 
-export async function addPageProperty(key, value) {
-    if (!currentPageId) return;
-    try {
-        await propertiesAPI.setProperty({ entity_type: 'page', entity_id: currentPageId, name: key, value: value });
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(properties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
-    } catch (error) {
-        console.error('Error adding page property:', error); alert('Failed to add property');
+async function updatePageProperty(key, index, newValue) {
+    const properties = parsePropertiesFromContent(pageContentForModal);
+    if (properties[key] && properties[key][index] !== undefined) {
+        properties[key][index].value = newValue;
     }
+    const newContent = rebuildContentWithProperties(pageContentForModal, properties);
+    await _updatePageContent(newContent);
 }
 
-export async function updatePageProperty(key, value) {
-    if (!currentPageId) return;
-    try {
-        await propertiesAPI.setProperty({ entity_type: 'page', entity_id: currentPageId, name: key, value: value });
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(properties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
+async function renamePropertyKey(oldKey, index, newKey) {
+    const properties = parsePropertiesFromContent(pageContentForModal);
+    if (properties[oldKey] && properties[oldKey][index] !== undefined) {
+        const instance = properties[oldKey].splice(index, 1)[0];
+        if (properties[oldKey].length === 0) {
+            delete properties[oldKey];
         }
-    } catch (error) {
-        console.error('Error updating page property:', error); alert('Failed to update property');
+        if (!properties[newKey]) {
+            properties[newKey] = [];
+        }
+        properties[newKey].push(instance);
     }
+    const newContent = rebuildContentWithProperties(pageContentForModal, properties);
+    await _updatePageContent(newContent);
 }
 
-export async function deletePageProperty(key) {
-    if (!currentPageId) return;
+// --- UI Rendering and Event Handling ---
+
+export async function displayPageProperties(properties) {
     try {
-        await propertiesAPI.deleteProperty('page', currentPageId, key);
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        displayPageProperties(properties);
-        if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-            ui.renderPageInlineProperties(properties, ui.domRefs.pagePropertiesContainer);
-        }
+        const pageData = await pagesAPI.getPageById(currentPageId);
+        pageContentForModal = pageData.content || '';
     } catch (error) {
-        console.error('Error deleting page property:', error); alert('Failed to delete property');
+        console.error("Could not fetch page data for property editor:", error);
+        ui.domRefs.pagePropertiesList.innerHTML = '<p>Error: Page data not found.</p>';
+        return;
     }
-}
 
-/**
- * Waits for sjcl library to be available with full functionality
- */
-function waitForSjcl(maxAttempts = 20) {
-    return new Promise((resolve, reject) => {
-        let attempts = 0;
-        const checkSjcl = () => {
-            attempts++;
-            if (typeof window.sjcl !== 'undefined' && 
-                window.sjcl.hash && 
-                window.sjcl.hash.sha256 && 
-                window.sjcl.hash.sha256.hash &&
-                window.sjcl.codec &&
-                window.sjcl.codec.hex) {
-                resolve(window.sjcl);
-            } else if (attempts >= maxAttempts) {
-                console.error('SJCL check failed. Current state:', {
-                    sjclExists: typeof window.sjcl !== 'undefined',
-                    hasHash: window.sjcl?.hash,
-                    hasSha256: window.sjcl?.hash?.sha256,
-                    hasHashMethod: window.sjcl?.hash?.sha256?.hash,
-                    hasCodec: window.sjcl?.codec,
-                    hasHex: window.sjcl?.codec?.hex
-                });
-                reject(new Error('SJCL library failed to load completely after maximum attempts'));
-            } else {
-                setTimeout(checkSjcl, 100); // Wait 100ms and try again
-            }
-        };
-        checkSjcl();
+    const pagePropertiesList = ui.domRefs.pagePropertiesList;
+    if (!pagePropertiesList) return;
+    
+    pagePropertiesList.innerHTML = '';
+    let hasVisibleProperties = false;
+    
+    Object.entries(properties).forEach(([key, instances]) => {
+        if (!Array.isArray(instances)) return;
+        instances.forEach((instance, index) => {
+            hasVisibleProperties = true;
+            const propItem = document.createElement('div');
+            propItem.className = 'page-property-item';
+            propItem.innerHTML = `
+                <span class="page-property-key" contenteditable="true" data-key="${key}" data-index="${index}">${key}</span>
+                <span class="page-property-separator">:</span>
+                <input type="text" class="page-property-value" value="${instance.value}" data-key="${key}" data-index="${index}" />
+                <button class="page-property-delete" data-key="${key}" data-index="${index}" title="Delete this value"></button>
+            `;
+            pagePropertiesList.appendChild(propItem);
+        });
     });
-}
 
-/**
- * Handles setting up page encryption by prompting for a password and storing the hashed version
- */
-export async function setupPageEncryption() {
-    if (!currentPageId) {
-        console.warn('No current page ID available for encryption setup');
-        return;
+    if (!hasVisibleProperties) {
+        pagePropertiesList.innerHTML = '<p class="no-properties-message">No properties set for this page.</p>';
     }
+}
 
-    try {
-        // Check if page is already encrypted
-        const properties = await propertiesAPI.getProperties('page', currentPageId);
-        if (properties.encrypt) {
-            const confirmed = await ui.showGenericConfirmModal(
-                'Page Already Encrypted', 
-                'This page is already encrypted. Do you want to change the encryption password?'
-            );
-            if (!confirmed) return;
+const propertyModalListener = async (e) => {
+    const target = e.target;
+    
+    if (e.type === 'blur' && target.matches('.page-property-key')) {
+        const oldKey = target.dataset.key;
+        const index = parseInt(target.dataset.index, 10);
+        const newKey = target.textContent.trim();
+        if (newKey && newKey !== oldKey) {
+            await renamePropertyKey(oldKey, index, newKey);
+        } else {
+            target.textContent = oldKey;
         }
+    }
 
-        // Prompt user for password
-        const password = await ui.showGenericInputModal('Set Encryption Password', 'Enter a password to encrypt this page:');
-        if (!password || password.trim() === '') {
-            return; // User cancelled or entered empty password
-        }
+    if (e.type === 'change' && target.matches('.page-property-value')) {
+        const key = target.dataset.key;
+        const index = parseInt(target.dataset.index, 10);
+        const newValue = target.value.trim();
+        await updatePageProperty(key, index, newValue);
+    }
 
-        // Confirm password
-        const confirmPassword = await ui.showGenericInputModal('Confirm Password', 'Please confirm your password:');
-        if (confirmPassword !== password) {
-            alert('Passwords do not match. Please try again.');
-            return;
+    if (e.type === 'click' && target.matches('.page-property-delete')) {
+        const key = target.dataset.key;
+        const index = parseInt(target.dataset.index, 10);
+        if (confirm(`Are you sure you want to delete this value for "${key}"?`)) {
+            await deletePageProperty(key, index);
         }
+    }
 
-        // Wait for sjcl library to be available and hash the password
-        try {
-            const sjcl = await waitForSjcl();
-            const hashedPassword = sjcl.hash.sha256.hash(password);
-            const hashedPasswordHex = sjcl.codec.hex.fromBits(hashedPassword);
-
-            // Add/update the encrypt property
-            await propertiesAPI.setProperty({ 
-                entity_type: 'page', 
-                entity_id: currentPageId, 
-                name: 'encrypt', 
-                value: hashedPasswordHex 
-            });
-
-            // Refresh the properties display
-            const updatedProperties = await propertiesAPI.getProperties('page', currentPageId);
-            displayPageProperties(updatedProperties);
-            if (ui.domRefs.pagePropertiesContainer && typeof ui.renderPageInlineProperties === 'function') {
-                ui.renderPageInlineProperties(updatedProperties, ui.domRefs.pagePropertiesContainer);
+    if (e.type === 'click' && target.id === 'add-page-property-btn') {
+        const newKey = prompt("Enter new property key:");
+        if (newKey && newKey.trim()) {
+            const newValue = prompt(`Enter value for "${newKey}":`);
+            if (newValue !== null) {
+                await addPageProperty(newKey.trim(), newValue.trim());
             }
-
-            alert('Page encryption has been set successfully. The page will require the password when accessed.');
-
-        } catch (sjclError) {
-            console.error('Error with SJCL library or encryption setup:', sjclError);
-            alert('Encryption library not available or failed to load. Please reload the page and try again.');
         }
-
-    } catch (error) {
-        console.error('Error setting up page encryption:', error);
-        alert('Failed to set up page encryption. Please try again.');
     }
-}
-
-/**
- * Sets up event listeners for the page properties modal, including the encryption icon
- */
-export function setupPagePropertiesModalListeners() {
-    const encryptionIcon = document.getElementById('page-encryption-icon');
-    if (encryptionIcon) {
-        // Remove existing listener if any
-        const existingListener = encryptionIcon._encryptionClickListener;
-        if (existingListener) {
-            encryptionIcon.removeEventListener('click', existingListener);
-        }
+};
 
-        // Add new listener
-        const encryptionClickListener = async (e) => {
-            e.preventDefault();
-            e.stopPropagation();
-            await setupPageEncryption();
-        };
-
-        encryptionIcon._encryptionClickListener = encryptionClickListener;
-        encryptionIcon.addEventListener('click', encryptionClickListener);
+export function initPropertyEditor() {
+    const list = ui.domRefs.pagePropertiesList;
+    const addBtn = ui.domRefs.addPagePropertyBtn;
+    if (list) {
+        list.addEventListener('blur', propertyModalListener, true);
+        list.addEventListener('change', propertyModalListener, true);
+        list.addEventListener('click', propertyModalListener);
+        list.addEventListener('keydown', (e) => {
+            if (e.key === 'Enter' && e.target.matches('.page-property-key, .page-property-value')) {
+                e.preventDefault();
+                e.target.blur();
+            }
+        });
+    }
+    if (addBtn) {
+        addBtn.addEventListener('click', propertyModalListener);
     }
 }
diff --git a/assets/js/app/search.js b/assets/js/app/search.js
index e5c7601..0f9a7e0 100644
--- a/assets/js/app/search.js
+++ b/assets/js/app/search.js
@@ -23,7 +23,7 @@ function highlightSearchTerms(text, searchTerm) {
 }
 
 function displaySearchResults(results) {
-    const searchResultsEl = ui.domRefs.searchResults; // Use ui.domRefs
+    const searchResultsEl = ui.domRefs.searchResults;
     if (!searchResultsEl) return;
 
     if (!results || results.length === 0) {
@@ -46,30 +46,18 @@ function displaySearchResults(results) {
         const resultItem = e.target.closest('.search-result-item');
         if (resultItem) {
             const pageName = resultItem.dataset.pageName;
-            const noteId = resultItem.dataset.noteId;
             
             if (ui.domRefs.globalSearchInput) ui.domRefs.globalSearchInput.value = '';
             searchResultsEl.classList.remove('has-results');
             searchResultsEl.innerHTML = '';
             
-            loadPage(pageName).then(() => {
-                if (noteId) {
-                    const noteElement = document.querySelector(`[data-note-id="${noteId}"]`);
-                    if (noteElement) {
-                        noteElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
-                        const contentDiv = noteElement.querySelector('.note-content');
-                        if (contentDiv) {
-                            setTimeout(() => contentDiv.focus(), 100);
-                        }
-                    }
-                }
-            });
+            loadPage(pageName);
         }
     });
 }
 
 const debouncedSearch = debounce(async (query) => {
-    const searchResultsEl = ui.domRefs.searchResults; // Use ui.domRefs
+    const searchResultsEl = ui.domRefs.searchResults;
     if (!searchResultsEl) return;
 
     if (!query.trim()) {
@@ -79,7 +67,9 @@ const debouncedSearch = debounce(async (query) => {
     }
     
     try {
-        const response = await searchAPI.search(query); // Assumes searchAPI is global
+        const response = await searchAPI.search(query);
+        // The search API returns the full object { results: [...], pagination: ... } inside the `data` key.
+        // The apiRequest client returns this object.
         if (response && Array.isArray(response.results)) {
             displaySearchResults(response.results);
         } else {
@@ -109,7 +99,9 @@ async function openSearchOrCreatePageModal() {
         return;
     }
     try {
-        allPagesForSearch = await pagesAPI.getPages({ excludeJournal: true }); // Assumes pagesAPI is global
+        // **FIXED**: Destructure the `pages` array from the response object.
+        const { pages } = await pagesAPI.getPages({ excludeJournal: true });
+        allPagesForSearch = pages || [];
     } catch (error) {
         console.error('Failed to fetch pages for search modal:', error);
         allPagesForSearch = []; 
@@ -132,11 +124,12 @@ function renderPageSearchResults(query) {
     ui.domRefs.pageSearchModalResults.innerHTML = '';
     selectedSearchResultIndex = -1; 
 
+    const lowerCaseQuery = query.toLowerCase();
     const filteredPages = allPagesForSearch.filter(page => 
-        page.name.toLowerCase().includes(query.toLowerCase())
+        page.name.toLowerCase().includes(lowerCaseQuery)
     );
 
-    filteredPages.forEach(page => {
+    filteredPages.slice(0, 10).forEach(page => {
         const li = document.createElement('li');
         li.textContent = page.name;
         li.dataset.pageName = page.name;
@@ -144,7 +137,7 @@ function renderPageSearchResults(query) {
         ui.domRefs.pageSearchModalResults.appendChild(li);
     });
 
-    const exactMatch = allPagesForSearch.some(page => page.name.toLowerCase() === query.toLowerCase());
+    const exactMatch = allPagesForSearch.some(page => page.name.toLowerCase() === lowerCaseQuery);
     if (query.trim() !== '' && !exactMatch) {
         const li = document.createElement('li');
         li.classList.add('create-new-option');
@@ -165,7 +158,7 @@ async function selectAndActionPageSearchResult(pageName, isCreate) {
     closeSearchOrCreatePageModal();
     if (isCreate) {
         try {
-            const newPage = await pagesAPI.createPage(pageName); // Pass pageName directly as string
+            const newPage = await pagesAPI.createPage(pageName);
             if (newPage && newPage.id) {
                 await fetchAndDisplayPages(newPage.name); 
                 await loadPage(newPage.name, true); 
@@ -177,7 +170,7 @@ async function selectAndActionPageSearchResult(pageName, isCreate) {
             alert(`Error creating page: ${error.message}`);
         }
     } else {
-        await loadPage(pageName, true);
+        await loadPage(pageName);
     }
 }
 
@@ -196,7 +189,7 @@ export function initPageSearchModal() {
 
         ui.domRefs.pageSearchModalInput.addEventListener('keydown', (e) => {
             const items = ui.domRefs.pageSearchModalResults.children;
-            if (items.length === 0) return;
+            if (e.key !== 'Enter' && items.length === 0) return;
 
             switch (e.key) {
                 case 'ArrowDown':
@@ -217,11 +210,29 @@ export function initPageSearchModal() {
                     break;
                 case 'Enter':
                     e.preventDefault();
-                    if (selectedSearchResultIndex !== -1 && items[selectedSearchResultIndex]) {
+                    const pageName = ui.domRefs.pageSearchModalInput.value.trim();
+
+                    if (!pageName) {
+                        closeSearchOrCreatePageModal();
+                        return;
+                    }
+                    
+                    // If user is navigating list with arrows, respect that. Otherwise, use text.
+                    if (selectedSearchResultIndex > -1 && items[selectedSearchResultIndex]) {
                         const selectedItem = items[selectedSearchResultIndex];
-                        selectAndActionPageSearchResult(selectedItem.dataset.pageName, selectedItem.dataset.isCreate === 'true');
-                    } else if (ui.domRefs.pageSearchModalInput.value.trim() !== '') {
-                        selectAndActionPageSearchResult(ui.domRefs.pageSearchModalInput.value.trim(), true);
+                        // If the typed text is what is selected, proceed.
+                        if (pageName.toLowerCase() === selectedItem.dataset.pageName.toLowerCase()) {
+                           selectAndActionPageSearchResult(selectedItem.dataset.pageName, selectedItem.dataset.isCreate === 'true');
+                           return;
+                        }
+                    }
+
+                    const exactMatch = allPagesForSearch.find(p => p.name.toLowerCase() === pageName.toLowerCase());
+
+                    if (exactMatch) {
+                        selectAndActionPageSearchResult(exactMatch.name, false);
+                    } else {
+                        selectAndActionPageSearchResult(pageName, true);
                     }
                     break;
                 case 'Escape':
diff --git a/assets/js/app/sidebar.js b/assets/js/app/sidebar.js
index 42d5930..0078802 100644
--- a/assets/js/app/sidebar.js
+++ b/assets/js/app/sidebar.js
@@ -44,21 +44,25 @@ export const sidebarState = {
                 console.error("Favorites container not found");
                 return;
             }
-            favoritesContainer.innerHTML = 'Loading favorites...'; // Initial message
+            favoritesContainer.innerHTML = 'Loading favorites...';
     
             try {
-                const pages = await pagesAPI.getPages({ include_details: true });
-                if (!pages || !Array.isArray(pages)) {
+                // **FIXED**: Destructure the `pages` array from the response object.
+                const { pages } = await pagesAPI.getPages({ include_details: true });
+
+                if (!Array.isArray(pages)) {
                     favoritesContainer.innerHTML = 'Could not load favorites.';
                     console.error('Failed to fetch pages or invalid response:', pages);
                     return;
                 }
     
+                // **FIXED**: Filter based on the new property structure from the API Spec.
+                // A page is a favorite if it has a 'favorite' property array where at least one entry's value is 'true'.
                 const favoritePages = pages.filter(
-                    page => page.properties && page.properties.favorite === 'true'
+                    page => page.properties?.favorite?.some(prop => String(prop.value).toLowerCase() === 'true')
                 );
     
-                favoritesContainer.innerHTML = ''; // Clear loading message
+                favoritesContainer.innerHTML = '';
     
                 if (favoritePages.length === 0) {
                     favoritesContainer.textContent = 'No favorite pages yet.';
@@ -76,79 +80,93 @@ export const sidebarState = {
     
                 pagesToDisplay.forEach(page => {
                     const link = document.createElement('a');
-                    link.href = `page.php?id=${page.id}`;
+                    link.href = `?page=${encodeURIComponent(page.name)}`; // Use page name for consistency
                     link.textContent = page.name;
-                    link.classList.add('favorite-page-link'); // Add a class for potential styling
+                    link.classList.add('favorite-page-link');
+                    // Add click handler to use SPA navigation
+                    link.addEventListener('click', (e) => {
+                        e.preventDefault();
+                        window.loadPage(page.name);
+                    });
                     favoritesContainer.appendChild(link);
                 });
     
                 if (showMoreNeeded) {
                     const showMoreBtn = document.createElement('button');
                     showMoreBtn.textContent = `Show more (${favoritePages.length - displayLimit})`;
-                    showMoreBtn.classList.add('show-more-favorites-btn'); // Add a class
+                    showMoreBtn.classList.add('show-more-favorites-btn');
                     showMoreBtn.addEventListener('click', () => {
-                        favoritesContainer.innerHTML = ''; // Clear current items and button
-                        favoritePages.forEach(page => { // Render all favorites
+                        favoritesContainer.innerHTML = '';
+                        favoritePages.forEach(page => {
                             const link = document.createElement('a');
-                            link.href = `page.php?id=${page.id}`;
+                            link.href = `?page=${encodeURIComponent(page.name)}`;
                             link.textContent = page.name;
                             link.classList.add('favorite-page-link');
+                            link.addEventListener('click', (e) => {
+                                e.preventDefault();
+                                window.loadPage(page.name);
+                            });
                             favoritesContainer.appendChild(link);
                         });
-                    }, { once: true }); // Remove listener after first click
+                    }, { once: true });
                     favoritesContainer.appendChild(showMoreBtn);
                 }
     
             } catch (error) {
                 console.error("Error rendering favorites:", error);
-                if (favoritesContainer) { // Check again in case error happened before it was set
+                if (favoritesContainer) {
                     favoritesContainer.innerHTML = 'Error loading favorites.';
                 }
             }
         },
         async renderExtensionIcons() {
-            const apiUrl = 'api/v1/extensions.php'; // Ensure this path is correct from your web root
+            const apiUrl = 'api/v1/extensions.php';
             const iconsContainer = ui.domRefs.extensionIconsContainer;
 
             if (!iconsContainer) {
                 console.error('Extension icons container (extension-icons-container) not found.');
                 return;
             }
-            iconsContainer.innerHTML = ''; // Clear existing icons
+            iconsContainer.innerHTML = '';
 
             try {
+                // Using fetch directly as this is a simple GET with no complex handling
                 const response = await fetch(apiUrl);
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 const data = await response.json();
 
-                if (data.success && Array.isArray(data.extensions)) {
-                    if (data.extensions.length === 0) {
-                        // iconsContainer.textContent = 'No active extensions.'; // Optional: display message
+                // **FIXED**: Check for the new API response format from the spec.
+                if (data.status === 'success' && data.data && Array.isArray(data.data.extensions)) {
+                    if (data.data.extensions.length === 0) {
                         return; // Nothing to render
                     }
 
-                    data.extensions.forEach(extension => {
+                    data.data.extensions.forEach(extension => {
                         const linkEl = document.createElement('a');
-                        linkEl.href = `extensions/${extension.name}/index.php`; // Link to the extension's entry point
-                        linkEl.title = extension.name; // Tooltip for accessibility
+                        linkEl.href = `extensions/${extension.name}/index.php`;
+                        linkEl.title = extension.name;
+                        linkEl.target = "_blank"; // Open extensions in a new tab
 
-                        const iconEl = document.createElement('i'); // Using <i> as is common for icon fonts/SVG icons
+                        const iconEl = document.createElement('i');
                         iconEl.setAttribute('data-feather', extension.featherIcon);
-                        iconEl.classList.add('sidebar-extension-icon'); // For common styling
+                        iconEl.classList.add('sidebar-extension-icon');
                         
                         linkEl.appendChild(iconEl);
                         iconsContainer.appendChild(linkEl);
                     });
+                    
+                    if (typeof feather !== 'undefined') {
+                        feather.replace();
+                    }
 
                 } else {
-                    console.error('Failed to load extension icons or data format is incorrect:', data);
-                    // iconsContainer.textContent = 'Error loading extensions.'; // Optional: display error
+                    throw new Error('Failed to load extension icons or data format is incorrect.');
                 }
             } catch (error) {
                 console.error('Error fetching or rendering extension icons:', error);
-                // iconsContainer.textContent = 'Error loading extensions.'; // Optional: display error
+                if(iconsContainer) iconsContainer.innerHTML = '<small>Extensions unavailable</small>';
             }
         }
     },
@@ -173,12 +191,9 @@ export const sidebarState = {
             document.body.classList.toggle('right-sidebar-collapsed', this.right.isCollapsed);
             this.right.updateButtonVisuals();
             this.right.button.addEventListener('click', () => this.right.toggle());
-            if (this.right.element) { // Ensure right sidebar exists
+            if (this.right.element) {
                 await Promise.all([this.right.renderFavorites(), this.right.renderExtensionIcons()]);
             }
-            if (typeof feather !== 'undefined') {
-                feather.replace();
-            }
         }
     }
 };
diff --git a/assets/js/ui.js b/assets/js/ui.js
index 5d5e52b..ec9933f 100644
--- a/assets/js/ui.js
+++ b/assets/js/ui.js
@@ -10,15 +10,16 @@ import { domRefs } from './ui/dom-refs.js';
 // Import functions related to note elements
 import {
     displayNotes,
-    updateNoteElement,
     addNoteElement,
     removeNoteElement,
-    moveNoteElement,
     buildNoteTree,
     initializeDragAndDrop,
     handleNoteDrop
 } from './ui/note-elements.js';
 
+// Import calendar widget
+import { calendarWidget } from './ui/calendar-widget.js';
+
 // Import functions related to note rendering
 import {
     renderNote,
@@ -32,54 +33,79 @@ import {
     initializeDelegatedNoteEventListeners
 } from './ui/note-renderer.js';
 
-// Functions that will remain in ui.js or be moved to other specific UI modules (e.g., modals, page-specific UI)
-
 /**
- * Updates the page title
- * @param {string} name - Page name
+ * Updates the entire page title block, including breadcrumbs and settings gear.
+ * @param {string} pageName - The full name of the page, which may include namespaces.
  */
-function updatePageTitle(name) {
-    document.title = `${name} - notd`;
+function updatePageTitle(pageName) {
+    document.title = `${pageName} - notd`;
+    if (!domRefs.pageTitleContainer) return;
+
+    domRefs.pageTitleContainer.innerHTML = ''; // Clear existing content
+
+    const pageNameParts = pageName.split('/');
+    let currentPath = '';
+
+    pageNameParts.forEach((part, index) => {
+        if (index > 0) {
+            domRefs.pageTitleContainer.appendChild(document.createTextNode(' / '));
+        }
+        currentPath += (index > 0 ? '/' : '') + part;
+
+        if (index < pageNameParts.length - 1) {
+            const link = document.createElement('a');
+            link.href = '#';
+            link.textContent = part;
+            link.dataset.pageName = currentPath;
+            link.onclick = (e) => {
+                e.preventDefault();
+                if (window.loadPage) window.loadPage(link.dataset.pageName);
+            };
+            domRefs.pageTitleContainer.appendChild(link);
+        } else {
+            domRefs.pageTitleContainer.appendChild(document.createTextNode(part));
+        }
+    });
+    
+    const gearIcon = document.createElement('i');
+    gearIcon.dataset.feather = 'settings';
+    gearIcon.id = 'page-properties-gear';
+    gearIcon.className = 'page-title-gear';
+    gearIcon.title = 'Page Properties';
+    domRefs.pageTitleContainer.appendChild(gearIcon);
+    if (typeof feather !== 'undefined') feather.replace();
 }
 
+
 /**
  * Updates the page list in the sidebar
  * @param {Array} pages - Array of page objects
  * @param {string} activePageName - Currently active page
  */
 function updatePageList(pages, activePageName) {
+    if (!domRefs.pageListContainer) return;
     domRefs.pageListContainer.innerHTML = '';
 
-    if (!pages || pages.length === 0) {
-        const defaultPageName = typeof getTodaysJournalPageName === 'function' 
-            ? getTodaysJournalPageName() 
-            : 'Journal'; // Fallback if getTodaysJournalPageName is not defined globally
-        const link = document.createElement('a');
-        link.href = '#';
-        link.dataset.pageName = defaultPageName;
-        link.textContent = `${defaultPageName} (Create)`;
-        domRefs.pageListContainer.appendChild(link);
+    if (!pages || !Array.isArray(pages) || pages.length === 0) {
+        domRefs.pageListContainer.innerHTML = '<li>No pages found.</li>';
         return;
     }
 
-    pages.sort((a, b) => {
-        if (a.updated_at > b.updated_at) return -1;
-        if (a.updated_at < b.updated_at) return 1;
-        return a.name.localeCompare(b.name);
-    });
-
-    const limitedPages = pages.slice(0, 7);
-
-    limitedPages.forEach(page => {
-        const link = document.createElement('a');
-        link.href = '#';
-        link.dataset.pageName = page.name;
-        link.textContent = page.name;
-        if (page.name === activePageName) {
-            link.classList.add('active');
-        }
-        domRefs.pageListContainer.appendChild(link);
-    });
+    pages
+        .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))
+        .slice(0, 10)
+        .forEach(page => {
+            const li = document.createElement('li');
+            const link = document.createElement('a');
+            link.href = `#`;
+            link.dataset.pageName = page.name;
+            link.textContent = page.name;
+            if (page.name === activePageName) {
+                link.classList.add('active');
+            }
+            li.appendChild(link);
+            domRefs.pageListContainer.appendChild(li);
+        });
 }
 
 /**
@@ -93,1239 +119,281 @@ function updateActivePageLink(pageName) {
 }
 
 /**
- * Shows or updates a property in a note (potentially for properties not handled by inline rendering)
- * @param {string} noteId - Note ID
- * @param {string} propertyName - Property name
- * @param {string} propertyValue - Property value
+ * Renders page properties as inline "pills" directly on the page.
+ * @param {Object} properties - The page's properties object.
+ * @param {HTMLElement} targetContainer - The HTML element to render properties into.
  */
-function showPropertyInNote(noteId, propertyName, propertyValue) {
-    const noteEl = document.querySelector(`.note-item[data-note-id="${noteId}"]`);
-    if (!noteEl) return;
-
-    let propertiesEl = noteEl.querySelector('.note-properties');
-    if (!propertiesEl) {
-        propertiesEl = document.createElement('div');
-        propertiesEl.className = 'note-properties';
-        // Assuming note-content-wrapper is where properties should be appended if not inline
-        const contentWrapper = noteEl.querySelector('.note-content-wrapper');
-        if (contentWrapper) {
-            contentWrapper.appendChild(propertiesEl);
-        } else {
-            noteEl.appendChild(propertiesEl); // Fallback
-        }
-    }
-    
-    // This function might need to be smarter if `renderProperties` handles the main display
-    // For now, it adds/updates a specific property.
-    const existingProp = propertiesEl.querySelector(`.property-item[data-property="${propertyName}"]`);
-    if (existingProp) {
-        existingProp.querySelector('.property-value').innerHTML = parseAndRenderContent(String(propertyValue));
-    } else {
-        const propItem = document.createElement('span');
-        propItem.className = 'property-item';
-        propItem.dataset.property = propertyName; // For easier selection
-        propItem.innerHTML = `
-            <span class="property-key">${propertyName}::</span>
-            <span class="property-value">${parseAndRenderContent(String(propertyValue))}</span>
-        `;
-        propertiesEl.appendChild(propItem);
-    }
-    propertiesEl.style.display = 'block'; // Or 'flex' if using flexbox for layout
-}
+function renderPageInlineProperties(properties, targetContainer) {
+    if (!targetContainer) return;
+    targetContainer.innerHTML = '';
+    targetContainer.style.display = 'none';
 
-/**
- * Removes a property from a note (potentially for properties not handled by inline rendering)
- * @param {string} noteId - Note ID
- * @param {string} propertyName - Property name to remove
- */
-function removePropertyFromNote(noteId, propertyName) {
-    const noteEl = document.querySelector(`.note-item[data-note-id="${noteId}"]`);
-    if (!noteEl) return;
+    if (!properties || Object.keys(properties).length === 0) return;
 
-    const propertiesEl = noteEl.querySelector('.note-properties');
-    if (!propertiesEl) return;
+    const fragment = document.createDocumentFragment();
+    let hasVisibleProperties = false;
+    const RENDER_INTERNAL = window.APP_CONFIG?.RENDER_INTERNAL_PROPERTIES ?? false;
 
-    const propItem = propertiesEl.querySelector(`.property-item[data-property="${propertyName}"]`);
-    if (propItem) {
-        propItem.remove();
-        if (propertiesEl.children.length === 0) {
-            propertiesEl.style.display = 'none';
-        }
-    }
-}
+    Object.entries(properties).forEach(([key, instances]) => {
+        instances.forEach(instance => {
+            if (instance.internal && !RENDER_INTERNAL) return;
 
-/**
- * Renders transcluded content
- * @param {HTMLElement} placeholderEl - Transclusion placeholder element
- * @param {string} noteContent - Content to render
- * @param {string} noteId - ID of the transcluded note
- */
-function renderTransclusion(placeholderEl, noteContent, noteId) {
-    if (!placeholderEl || !noteContent) return;
+            hasVisibleProperties = true;
+            const propItem = document.createElement('span');
+            propItem.className = 'property-inline';
 
-    const contentEl = document.createElement('div');
-    contentEl.className = 'transcluded-content';
-    contentEl.innerHTML = `
-        <div class="transclusion-header">
-            <span class="transclusion-icon"></span>
-            <a href="#" class="transclusion-link" data-note-id="${noteId}">View original note</a>
-        </div>
-        <div class="transclusion-body">
-            ${parseAndRenderContent(noteContent)}
-        </div>
-    `;
-    
-    const transclusionLink = contentEl.querySelector('.transclusion-link');
-    if (transclusionLink) {
-        transclusionLink.addEventListener('click', (e) => {
-            e.preventDefault();
-            const originalNote = document.querySelector(`[data-note-id="${noteId}"]`);
-            if (originalNote) {
-                originalNote.scrollIntoView({ behavior: 'smooth', block: 'center' });
-                originalNote.style.background = 'rgba(59, 130, 246, 0.1)';
-                setTimeout(() => {
-                    originalNote.style.background = '';
-                }, 2000);
+            if (key === 'favorite' && String(instance.value).toLowerCase() === 'true') {
+                propItem.innerHTML = `<span class="property-favorite"></span>`;
+            } else {
+                propItem.innerHTML = `<span class="property-key">${key}:</span> <span class="property-value">${instance.value}</span>`;
             }
+            fragment.appendChild(propItem);
         });
-    }
-    
-    placeholderEl.replaceWith(contentEl);
-}
-
-/**
- * Calendar Widget Module
- */
-const calendarWidget = {
-    currentDate: new Date(),
-    currentPageName: null,
-    
-    init() {
-        this.calendarEl = document.querySelector('.calendar-widget');
-        if (!this.calendarEl) return;
-        
-        this.monthEl = this.calendarEl.querySelector('.current-month');
-        this.daysEl = this.calendarEl.querySelector('.calendar-days');
-        this.prevBtn = this.calendarEl.querySelector('.calendar-nav.prev');
-        this.nextBtn = this.calendarEl.querySelector('.calendar-nav.next');
-        
-        this.bindEvents();
-        this.render();
-    },
-    
-    bindEvents() {
-        if (this.prevBtn) {
-            this.prevBtn.addEventListener('click', () => {
-                this.currentDate.setMonth(this.currentDate.getMonth() - 1);
-                this.render();
-            });
-        }
-        
-        if (this.nextBtn) {
-            this.nextBtn.addEventListener('click', () => {
-                this.currentDate.setMonth(this.currentDate.getMonth() + 1);
-                this.render();
-            });
-        }
-    },
-    
-    setCurrentPage(pageName) {
-        this.currentPageName = pageName;
-        this.render();
-    },
-    
-    render() {
-        if (!this.monthEl || !this.daysEl) return;
-        
-        const year = this.currentDate.getFullYear();
-        const month = this.currentDate.getMonth();
-        
-        this.monthEl.textContent = new Date(year, month).toLocaleString('default', { 
-            month: 'long', 
-            year: 'numeric' 
-        });
-        
-        this.daysEl.innerHTML = '';
-        
-        const firstDay = new Date(year, month, 1);
-        const lastDay = new Date(year, month + 1, 0);
-        const totalDays = lastDay.getDate();
-        const startingDay = firstDay.getDay();
-        
-        for (let i = 0; i < startingDay; i++) {
-            const emptyDay = document.createElement('div');
-            emptyDay.className = 'calendar-day empty';
-            this.daysEl.appendChild(emptyDay);
-        }
-        
-        const today = new Date();
-        for (let day = 1; day <= totalDays; day++) {
-            const dayEl = document.createElement('div');
-            dayEl.className = 'calendar-day';
-            dayEl.textContent = day;
-            
-            const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
-            
-            if (day === today.getDate() && 
-                month === today.getMonth() && 
-                year === today.getFullYear()) {
-                dayEl.classList.add('today');
-            }
-            
-            if (this.currentPageName === dateStr) {
-                dayEl.classList.add('current-page');
-            }
-            
-            dayEl.addEventListener('click', () => {
-                if (typeof window.loadPage === 'function') {
-                    window.loadPage(dateStr);
-                }
-            });
-            
-            this.daysEl.appendChild(dayEl);
-        }
-    }
-};
+    });
 
-document.addEventListener('DOMContentLoaded', () => {
-    calendarWidget.init();
-    updateSidebarToggleButtons(); // Already here, good.
-    if (domRefs.notesContainer) {
-        initializeDelegatedNoteEventListeners(domRefs.notesContainer);
-    } else {
-        console.error("Failed to initialize delegated note event listeners: notesContainer not found.");
+    if (hasVisibleProperties) {
+        targetContainer.appendChild(fragment);
+        targetContainer.style.display = 'flex';
     }
-});
-
-
-/**
- * Shows a generic input modal and returns a Promise with the entered value.
- * @param {string} title - The title for the modal.
- * @param {string} [defaultValue=''] - The default value for the input field.
- * @returns {Promise<string|null>} A Promise that resolves with the input string or null if canceled.
- */
-function showGenericInputModal(title, defaultValue = '') {
-    return new Promise((resolve) => {
-        const modal = document.getElementById('generic-input-modal');
-        const titleEl = document.getElementById('generic-input-modal-title');
-        const inputEl = document.getElementById('generic-input-modal-input');
-        const okBtn = document.getElementById('generic-input-modal-ok');
-        const cancelBtn = document.getElementById('generic-input-modal-cancel');
-
-        if (!modal || !titleEl || !inputEl || !okBtn || !cancelBtn) {
-            console.error('Generic input modal elements not found!');
-            resolve(prompt(title, defaultValue)); 
-            return;
-        }
-
-        // Define all handlers first
-        const closeHandler = (value) => {
-            modal.classList.remove('active');
-            okBtn.removeEventListener('click', okHandler);
-            inputEl.removeEventListener('keypress', enterKeyHandler);
-            cancelBtn.removeEventListener('click', cancelHandler);
-            document.removeEventListener('keydown', escapeKeyHandler);
-            if (closeButtonX) {
-                closeButtonX.removeEventListener('click', cancelHandler);
-            }
-            resolve(value);
-        };
-
-        const okHandler = () => {
-            closeHandler(inputEl.value);
-        };
-
-        const cancelHandler = () => {
-            closeHandler(null);
-        };
-
-        const enterKeyHandler = (e) => {
-            if (e.key === 'Enter') {
-                okHandler();
-            }
-        };
-        
-        const escapeKeyHandler = (e) => {
-            if (e.key === 'Escape') {
-                cancelHandler();
-            }
-        };
-
-        // Now set up the modal
-        titleEl.textContent = title;
-        inputEl.value = defaultValue;
-        modal.classList.add('active');
-        inputEl.focus();
-        inputEl.select();
-
-        const closeButtonX = modal.querySelector('.modal-close-x');
-        if (closeButtonX) {
-            closeButtonX.addEventListener('click', cancelHandler);
-        }
-
-        // Add event listeners
-        okBtn.addEventListener('click', okHandler);
-        inputEl.addEventListener('keypress', enterKeyHandler);
-        cancelBtn.addEventListener('click', cancelHandler);
-        document.addEventListener('keydown', escapeKeyHandler);
-    });
 }
 
 /**
- * Shows a generic confirmation modal and returns a Promise with a boolean.
- * @param {string} title - The title for the modal.
- * @param {string} message - The confirmation message.
- * @returns {Promise<boolean>} A Promise that resolves with true if OK is clicked, false otherwise.
+ * Initializes the page properties modal and its event listeners
  */
-function showGenericConfirmModal(title, message) {
-    return new Promise((resolve) => {
-        const modal = document.getElementById('generic-confirm-modal');
-        const titleEl = document.getElementById('generic-confirm-modal-title');
-        const messageEl = document.getElementById('generic-confirm-modal-message');
-        const okBtn = document.getElementById('generic-confirm-modal-ok');
-        const cancelBtn = document.getElementById('generic-confirm-modal-cancel');
+function initPagePropertiesModal() {
+    const modal = domRefs.pagePropertiesModal;
+    if (!modal) return;
 
-        if (!modal || !titleEl || !messageEl || !okBtn || !cancelBtn) {
-            console.error('Generic confirm modal elements not found!');
-            resolve(confirm(message)); 
-            return;
+    const showModal = async () => {
+        if (!window.currentPageId || !window.pagesAPI) return;
+        try {
+            const pageData = await window.pagesAPI.getPageById(window.currentPageId);
+            if (window.displayPageProperties) {
+                await window.displayPageProperties(pageData.properties || {});
+                modal.classList.add('active');
+            }
+        } catch (error) {
+            console.error("Error fetching page properties for modal:", error);
+            alert("Error loading page properties.");
         }
+    };
 
-        titleEl.textContent = title;
-        messageEl.textContent = message;
-        modal.classList.add('active');
-        okBtn.focus();
-
-        const closeButtonX = modal.querySelector('.modal-close-x');
-        if (closeButtonX) {
-            closeButtonX.addEventListener('click', cancelHandler);
+    const hideModal = () => modal.classList.remove('active');
+    
+    // Use event delegation on the document to catch clicks on the gear icon
+    document.addEventListener('click', (e) => {
+        if (e.target.closest('#page-properties-gear')) {
+            showModal();
         }
-
-        const closeHandler = (value) => {
-            modal.classList.remove('active');
-            okBtn.removeEventListener('click', okHandler);
-            cancelBtn.removeEventListener('click', cancelHandler);
-            document.removeEventListener('keydown', escapeKeyHandler);
-            if (closeButtonX) {
-                closeButtonX.removeEventListener('click', cancelHandler);
-            }
-            resolve(value);
-        };
-
-        const okHandler = () => {
-            closeHandler(true);
-        };
-
-        const cancelHandler = () => {
-            closeHandler(false);
-        };
-        
-        const escapeKeyHandler = (e) => {
-            if (e.key === 'Escape') {
-                cancelHandler();
-            }
-        };
-
-        okBtn.addEventListener('click', okHandler);
-        cancelBtn.addEventListener('click', cancelHandler);
-        document.addEventListener('keydown', escapeKeyHandler);
     });
-}
 
-/**
- * @deprecated This function is kept for backward compatibility but properties are now handled inline
- */
-function extractPropertiesFromContent(content) {
-    return { content: content || '', properties: {} };
+    domRefs.pagePropertiesModalClose?.addEventListener('click', hideModal);
+    modal.addEventListener('click', (e) => { if (e.target === modal) hideModal(); });
 }
 
 /**
- * @deprecated This function is kept for backward compatibility but properties are now handled inline
+ * Updates the visual save status indicator.
+ * @param {string} newStatus - The new status ('saved', 'pending', 'error').
  */
-function renderInlineProperties(properties) {
-    return '';
-}
+function updateSaveStatusIndicator(newStatus) {
+    const indicator = document.getElementById('save-status-indicator');
+    if (!indicator) return;
 
-/**
- * Renders page properties as inline "pills" directly on the page.
- * @param {Object} properties - The page's properties object.
- * @param {HTMLElement} targetContainer - The HTML element to render properties into.
- */
-function renderPageInlineProperties(properties, targetContainer) {
-    if (!targetContainer) {
-        console.error("Target container for inline page properties not provided.");
-        return;
-    }
-    targetContainer.innerHTML = ''; 
+    setSaveStatus(newStatus);
+    indicator.className = 'save-status-indicator'; // Reset classes
+    indicator.classList.add(`status-${newStatus}`);
 
-    if (!properties || Object.keys(properties).length === 0) {
-        targetContainer.style.display = 'none';
-        return;
+    let iconHtml = '';
+    switch (newStatus) {
+        case 'saved':
+            iconHtml = '<i data-feather="check-circle"></i>';
+            indicator.title = 'All changes saved';
+            break;
+        case 'pending':
+            iconHtml = '<div class="dot-spinner"><div class="dot-spinner__dot"></div><div class="dot-spinner__dot"></div><div class="dot-spinner__dot"></div></div>';
+            indicator.title = 'Saving...';
+            break;
+        case 'error':
+            iconHtml = '<i data-feather="alert-triangle"></i>';
+            indicator.title = 'Error saving changes';
+            break;
     }
-
-    let hasVisibleProperties = false;
-    const fragment = document.createDocumentFragment();
-
-    Object.entries(properties).forEach(([key, value]) => {
-        hasVisibleProperties = true;
-        const processValue = (val) => {
-            const propItem = document.createElement('span');
-            propItem.className = 'property-inline'; 
-            if (key.toLowerCase() === 'favorite' && String(val).toLowerCase() === 'true') {
-                propItem.innerHTML = `<span class="property-favorite"></span>`;
-                fragment.appendChild(propItem); return;
-            }
-            if (key.startsWith('tag::')) {
-                const tagName = key.substring(5); 
-                propItem.innerHTML = `<span class="property-key">#${tagName}</span>`;
-                propItem.classList.add('property-tag'); 
-            } else {
-                const displayValue = String(val).trim();
-                propItem.innerHTML = `<span class="property-key">${key}:</span> <span class="property-value">${displayValue}</span>`;
-            }
-            fragment.appendChild(propItem);
-        };
-        if (Array.isArray(value)) { value.forEach(v => processValue(v)); } else { processValue(value); }
-    });
-
-    if (hasVisibleProperties) {
-        targetContainer.appendChild(fragment);
-        targetContainer.style.display = 'flex'; 
-        targetContainer.style.flexWrap = 'wrap'; 
-        targetContainer.style.gap = 'var(--ls-space-2, 8px)'; 
-        targetContainer.classList.remove('hidden'); 
-    } else {
-        targetContainer.style.display = 'none';
-        targetContainer.classList.add('hidden');
+    indicator.innerHTML = iconHtml;
+    if (newStatus !== 'pending' && typeof feather !== 'undefined') {
+        feather.replace({ width: '18px', height: '18px' });
     }
 }
 
-/**
- * Traverses upwards from the noteId to collect all ancestors.
- * @param {string} noteId - The ID of the note to start from.
- * @param {Array<Object>} allNotesOnPage - Flat list of all notes on the current page.
- * @returns {Array<Object>} Array of note objects, ordered from furthest ancestor to direct parent.
- */
+
+// --- Fully restored UI functions from original context ---
+
 function getNoteAncestors(noteId, allNotesOnPage) {
     const ancestors = [];
-    if (!allNotesOnPage) { console.warn('getNoteAncestors called without allNotesOnPage'); return ancestors; }
     let currentNote = allNotesOnPage.find(note => String(note.id) === String(noteId));
     while (currentNote && currentNote.parent_note_id) {
         const parentNote = allNotesOnPage.find(note => String(note.id) === String(currentNote.parent_note_id));
-        if (parentNote) { ancestors.unshift(parentNote); currentNote = parentNote; } else { break; }
+        if (parentNote) {
+            ancestors.unshift(parentNote);
+            currentNote = parentNote;
+        } else {
+            break;
+        }
     }
     return ancestors;
 }
 
-/**
- * Renders breadcrumbs for the focused note.
- * @param {string|null} focusedNoteId - The ID of the currently focused note, or null.
- * @param {Array<Object>} allNotesOnPage - Flat list of all notes for the current page.
- * @param {string} currentPageName - The name of the current page.
- */
 function renderBreadcrumbs(focusedNoteId, allNotesOnPage, currentPageName) {
-    if (!domRefs.noteFocusBreadcrumbsContainer) { console.warn('Note-focus breadcrumbs container not found in DOM.'); return; }
-    if (!currentPageName) { console.warn('renderBreadcrumbs called without currentPageName.'); currentPageName = 'Page'; } // Basic fallback
-
-    let breadcrumbLinksHtml = `<a href="#" onclick="ui.showAllNotesAndLoadPage('${currentPageName}'); return false;">${currentPageName.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</a>`;
+    if (!domRefs.noteFocusBreadcrumbsContainer || !currentPageName) return;
 
-    if (focusedNoteId && allNotesOnPage && allNotesOnPage.length > 0) {
-        const focusedNote = allNotesOnPage.find(n => String(n.id) === String(focusedNoteId));
-        if (focusedNote) {
-            const ancestors = getNoteAncestors(focusedNoteId, allNotesOnPage);
-            ancestors.forEach(ancestor => {
-                const noteName = (ancestor.content ? (ancestor.content.split('\n')[0].substring(0, 30) + (ancestor.content.length > 30 ? '...' : '')) : `Note ${ancestor.id}`).replace(/</g, '&lt;').replace(/>/g, '&gt;');
-                breadcrumbLinksHtml += ` &gt; <a href="#" onclick="ui.focusOnNote('${ancestor.id}'); return false;">${noteName}</a>`;
-            });
-            const focusedNoteName = (focusedNote.content ? (focusedNote.content.split('\n')[0].substring(0, 30) + (focusedNote.content.length > 30 ? '...' : '')) : `Note ${focusedNote.id}`).replace(/</g, '&lt;').replace(/>/g, '&gt;');
-            breadcrumbLinksHtml += ` &gt; <span class="breadcrumb-current">${focusedNoteName}</span>`;
-        }
-    }
+    let breadcrumbLinksHtml = `<a href="#" onclick="ui.showAllNotesAndLoadPage('${currentPageName}'); return false;">${currentPageName}</a>`;
 
-    const breadcrumbHTML = `
-        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
-            <span>${breadcrumbLinksHtml}</span>
-            <i data-feather="settings" class="page-title-gear" style="cursor: pointer;"></i>
-        </div>
-    `;
-    domRefs.noteFocusBreadcrumbsContainer.innerHTML = breadcrumbHTML;
-    domRefs.noteFocusBreadcrumbsContainer.style.display = 'flex';
-    if (typeof feather !== 'undefined' && feather.replace) {
-        feather.replace();
+    if (focusedNoteId) {
+        const ancestors = getNoteAncestors(focusedNoteId, allNotesOnPage);
+        ancestors.forEach(ancestor => {
+            const noteName = (ancestor.content || `Note ${ancestor.id}`).split('\n')[0].substring(0, 30);
+            breadcrumbLinksHtml += ` > <a href="#" onclick="ui.focusOnNote('${ancestor.id}'); return false;">${noteName}</a>`;
+        });
     }
+    domRefs.noteFocusBreadcrumbsContainer.innerHTML = breadcrumbLinksHtml;
+    domRefs.noteFocusBreadcrumbsContainer.style.display = 'block';
 }
 
-// Helper function to be called by breadcrumb page link
-function showAllNotesAndLoadPage(pageName) {
-    if (typeof ui !== 'undefined' && ui.showAllNotes) { ui.showAllNotes(); }
-    if (typeof window.loadPage === 'function') { window.loadPage(pageName); } 
-    else { console.warn('window.loadPage function not found. Cannot reload page for breadcrumb.'); }
-}
-
-// renderNoteProperties function was removed from here as it was redundant.
-// The primary renderProperties is in note-renderer.js and exported via ui.renderProperties.
-
-function updateSidebarToggleButtons() {
-    const leftToggle = domRefs.toggleLeftSidebarBtn;
-    const rightToggle = domRefs.toggleRightSidebarBtn;
-    const isLeftCollapsed = domRefs.leftSidebar && domRefs.leftSidebar.classList.contains('collapsed');
-    const isRightCollapsed = domRefs.rightSidebar && domRefs.rightSidebar.classList.contains('collapsed');
-    if (leftToggle) { leftToggle.textContent = isLeftCollapsed ? '' : ''; leftToggle.title = isLeftCollapsed ? 'Show left sidebar' : 'Hide left sidebar'; }
-    if (rightToggle) { rightToggle.textContent = isRightCollapsed ? '' : ''; rightToggle.title = isRightCollapsed ? 'Show right sidebar' : 'Hide right sidebar'; }
-}
-
-
-/**
- * Focuses on a specific note by hiding all other notes at the same level and above
- * @param {string} noteId - The ID of the note to focus on
- */
 function focusOnNote(noteId) {
-    window.currentFocusedNoteId = noteId; 
-    const focusedNote = document.querySelector(`.note-item[data-note-id="${noteId}"]`);
-    const notesContainer = document.getElementById('notes-container'); 
-    if (!focusedNote) { console.warn(`Focus target note with ID ${noteId} not found.`); return; }
-
-    const elementsToMakeVisible = new Set();
-    const elementsToFocus = new Set();
-    elementsToMakeVisible.add(focusedNote);
-    elementsToFocus.add(focusedNote);
-
-    function collectAndMarkDescendants(currentElement) {
-        const childrenContainer = currentElement.querySelector('.note-children');
-        if (childrenContainer) {
-            const childNotes = Array.from(childrenContainer.children).filter(el => el.matches('.note-item'));
-            childNotes.forEach(child => {
-                elementsToMakeVisible.add(child);
-                elementsToFocus.add(child);
-                collectAndMarkDescendants(child); 
-            });
-        }
-    }
-    collectAndMarkDescendants(focusedNote);
-
-    let currentAncestor = focusedNote.parentElement.closest('.note-item');
-    while (currentAncestor) {
-        elementsToMakeVisible.add(currentAncestor);
-        currentAncestor = currentAncestor.parentElement.closest('.note-item');
+    window.currentFocusedNoteId = noteId;
+    const allNoteElements = document.querySelectorAll('.note-item');
+    allNoteElements.forEach(el => el.classList.add('note-hidden'));
+    
+    const elementsToShow = new Set();
+    let current = document.querySelector(`.note-item[data-note-id="${noteId}"]`);
+    while(current) {
+        elementsToShow.add(current);
+        const children = Array.from(current.querySelectorAll('.note-item'));
+        children.forEach(child => elementsToShow.add(child));
+        current = current.parentElement.closest('.note-item');
     }
 
-    const allNoteElements = document.querySelectorAll('#notes-container .note-item');
-    allNoteElements.forEach(noteElement => {
-        if (elementsToMakeVisible.has(noteElement)) { noteElement.classList.remove('note-hidden'); } 
-        else { noteElement.classList.add('note-hidden'); }
-        if (elementsToFocus.has(noteElement)) { noteElement.classList.add('note-focused'); } 
-        else { noteElement.classList.remove('note-focused'); }
-    });
-
-    notesContainer.classList.add('has-focused-notes');
-    const existingBtn = notesContainer.querySelector('.show-all-notes-btn');
-    if (existingBtn) { existingBtn.remove(); }
-    const showAllBtn = document.createElement('button');
-    showAllBtn.className = 'show-all-notes-btn';
-    showAllBtn.textContent = ' Show All Notes';
-    showAllBtn.addEventListener('click', showAllNotes);
-    notesContainer.insertBefore(showAllBtn, notesContainer.firstChild);
-
-    if (window.notesForCurrentPage && window.currentPageName) {
-        renderBreadcrumbs(noteId, window.notesForCurrentPage, window.currentPageName);
-    } else {
-        console.warn("Cannot render breadcrumbs: notesForCurrentPage or currentPageName is missing.");
-        if (domRefs.noteFocusBreadcrumbsContainer) {
-            domRefs.noteFocusBreadcrumbsContainer.innerHTML = '';
-            domRefs.noteFocusBreadcrumbsContainer.style.display = 'none';
-        }
-    }
+    elementsToShow.forEach(el => el.classList.remove('note-hidden'));
+    
+    renderBreadcrumbs(noteId, window.notesForCurrentPage, window.currentPageName);
 }
 
-/**
- * Shows all notes and clears focus state
- */
 function showAllNotes() {
-    window.currentFocusedNoteId = null; 
-    const allNotes = document.querySelectorAll('.note-item');
-    const notesContainer = document.getElementById('notes-container');
-    allNotes.forEach(note => {
-        note.classList.remove('note-hidden');
-        note.classList.remove('note-focused');
-    });
-    notesContainer.classList.remove('has-focused-notes');
-    const showAllBtn = notesContainer.querySelector('.show-all-notes-btn');
-    if (showAllBtn) { showAllBtn.remove(); }
-    if (domRefs.noteFocusBreadcrumbsContainer) {
-        domRefs.noteFocusBreadcrumbsContainer.innerHTML = '';
-        domRefs.noteFocusBreadcrumbsContainer.style.display = 'none';
-    }
+    window.currentFocusedNoteId = null;
+    document.querySelectorAll('.note-item').forEach(el => el.classList.remove('note-hidden'));
+    if (domRefs.noteFocusBreadcrumbsContainer) domRefs.noteFocusBreadcrumbsContainer.style.display = 'none';
+}
+
+function showAllNotesAndLoadPage(pageName) {
+    showAllNotes();
+    if(window.loadPage) window.loadPage(pageName);
 }
 
 function getNestingLevel(noteElement) {
     let level = 0;
     let parent = noteElement.parentElement;
     while (parent) {
-        if (parent.classList.contains('note-children')) { level++; }
-        if (parent.id === 'notes-container') { break; }
+        if (parent.classList.contains('note-children')) level++;
+        if (parent.id === 'notes-container') break;
         parent = parent.parentElement;
     }
     return level;
 }
 
-function updateParentVisuals(parentNoteElement) {
-    if (!parentNoteElement) return;
-    const noteId = parentNoteElement.dataset.noteId;
-    const controlsEl = parentNoteElement.querySelector('.note-controls');
-    if (!controlsEl || !window.notesForCurrentPage || !window.propertiesAPI) return; // Added checks for globals
-
-    const children = window.notesForCurrentPage.filter(n => String(n.parent_note_id) === String(noteId));
-    const hasChildren = children.length > 0;
-    const existingArrow = controlsEl.querySelector('.note-collapse-arrow');
-    if (existingArrow) { existingArrow.remove(); }
-
-    if (hasChildren) {
-        const arrow = document.createElement('span');
-        arrow.className = 'note-collapse-arrow';
-        arrow.dataset.noteId = noteId;
-        arrow.dataset.collapsed = 'false';
-        arrow.innerHTML = '<i data-feather="chevron-right"></i>';
-        controlsEl.insertBefore(arrow, controlsEl.firstChild);
-        
-        arrow.addEventListener('click', async (e) => {
-            e.stopPropagation();
-            const isCollapsed = arrow.dataset.collapsed === 'true';
-            const childrenContainer = parentNoteElement.querySelector('.note-children');
-            if (!childrenContainer) return;
-            try {
-                arrow.dataset.collapsed = (!isCollapsed).toString();
-                childrenContainer.style.display = isCollapsed ? 'block' : 'none';
-                parentNoteElement.classList.toggle('collapsed', !isCollapsed);
-                const childNotes = childrenContainer.querySelectorAll('.note-item');
-                childNotes.forEach(child => { child.classList.toggle('note-hidden', !isCollapsed); });
-                await propertiesAPI.setProperty({
-                    entity_type: 'note', entity_id: parseInt(noteId),
-                    name: 'collapsed', value: (!isCollapsed).toString()
-                });
-                if (typeof feather !== 'undefined') feather.replace();
-            } catch (error) {
-                console.error('Error updating collapse state:', error);
-                arrow.dataset.collapsed = isCollapsed.toString();
-                childrenContainer.style.display = isCollapsed ? 'none' : 'block';
-                parentNoteElement.classList.toggle('collapsed', isCollapsed);
-                alert('Failed to save collapse state. Please try again.');
-            }
-        });
-        parentNoteElement.classList.add('has-children');
-        const noteData = window.notesForCurrentPage.find(n => String(n.id) === String(noteId));
-        if (noteData && noteData.properties && noteData.properties.collapsed === 'true') {
-            arrow.dataset.collapsed = 'true';
-            const childrenContainer = parentNoteElement.querySelector('.note-children');
-            if (childrenContainer) {
-                childrenContainer.style.display = 'none';
-                parentNoteElement.classList.add('collapsed');
-                childrenContainer.querySelectorAll('.note-item').forEach(child => { child.classList.add('note-hidden'); });
-            }
-        }
-    } else {
-        parentNoteElement.classList.remove('has-children');
-    }
-    if (typeof feather !== 'undefined') feather.replace();
-}
-
 /**
- * Initializes the page properties modal and its event listeners
+ * Renders the content of a transcluded block into a placeholder element.
+ * @param {HTMLElement} placeholder - The placeholder element to render into.
+ * @param {string} content - The raw content of the note to be rendered.
+ * @param {string} blockId - The ID of the block being transcluded.
  */
-function initPagePropertiesModal() {
-    // Ensure the modal is properly initialized
-    const modal = domRefs.pagePropertiesModal;
-    if (!modal) {
-        console.error('Page properties modal element not found');
-        return;
-    }
-
-    // Initialize Feather Icons for the modal
-    if (typeof feather !== 'undefined' && feather.replace) {
-        feather.replace({
-            width: '18px',
-            height: '18px',
-            'stroke-width': '2'
-        });
-    }
-
-    // Function to show the modal
-    const showModal = () => {
-        modal.classList.add('active');
-        const modalContent = modal.querySelector('.generic-modal-content');
-        if (modalContent) {
-            modalContent.style.transform = 'scale(1)';
-        }
-    };
-
-    // Function to hide the modal
-    const hideModal = () => {
-        // --- START Added cleanup logic ---
-        const pagePropertiesList = domRefs.pagePropertiesList; // domRefs should be available in initPagePropertiesModal scope
-        if (pagePropertiesList) {
-            const newRows = pagePropertiesList.querySelectorAll('.new-property-row');
-            newRows.forEach(row => {
-                const keySpan = row.querySelector('.page-property-key');
-                const valueInput = row.querySelector('.page-property-value');
-
-                // Check if key is still marked as new (data-is-new) and its text content is empty,
-                // AND the value input is also empty.
-                if (keySpan && keySpan.dataset.isNew === 'true' && keySpan.textContent.trim() === '' &&
-                    valueInput && valueInput.value.trim() === '') {
-                    row.remove();
-                }
-            });
-
-            // If, after removals, the list is empty, show the "No properties" message
-            if (pagePropertiesList.children.length === 0 && !pagePropertiesList.querySelector('p.no-properties-message')) {
-                pagePropertiesList.innerHTML = '<p class="no-properties-message">No properties set for this page.</p>';
-            }
-        }
-        // --- END Added cleanup logic ---
-
-        modal.classList.remove('active');
-        const modalContent = modal.querySelector('.generic-modal-content');
-        if (modalContent) {
-            modalContent.style.transform = 'scale(0.95)';
-        }
-    };
-
-    // Close button handler
-    const closeButton = modal.querySelector('#page-properties-modal-close');
-    if (closeButton) {
-        closeButton.addEventListener('click', hideModal);
-    }
-
-    // Click outside to close
-    modal.addEventListener('click', (e) => {
-        if (e.target === modal) {
-            hideModal();
-        }
-    });
-
-    // Function to handle gear icon click
-    const handleGearClick = async () => {
-        console.log('Page properties gear clicked');
-        if (!window.currentPageId || !(window.propertiesAPI && typeof window.propertiesAPI.getProperties === 'function')) {
-            console.error('currentPageId or window.propertiesAPI.getProperties is not available.');
-            alert('Cannot load page properties at the moment.');
-            return;
-        }
-        try {
-            const properties = await window.propertiesAPI.getProperties('page', window.currentPageId);
-            
-            if (typeof window.displayPageProperties === 'function') {
-                window.displayPageProperties(properties);
-                showModal();
-            } else {
-                console.error('window.displayPageProperties is not defined. Cannot populate property modal.');
-            }
-        } catch (error) {
-            console.error("Error fetching or displaying page properties:", error);
-            alert("Error loading page properties.");
-        }
-    };
-
-    // Attach click handler to gear icon
-    const attachGearClickListener = () => {
-        const gearElement = document.getElementById('page-properties-gear') || 
-                           document.querySelector('.page-title-gear') ||
-                           document.querySelector('[data-feather="settings"]') ||
-                           document.querySelector('svg.feather-settings');
-        
-        if (gearElement && !gearElement.hasAttribute('data-properties-listener-attached')) {
-            gearElement.setAttribute('data-properties-listener-attached', 'true');
-            gearElement.addEventListener('click', handleGearClick);
-            console.log('Page properties gear click listener attached successfully');
-        }
-    };
-
-    // Try to attach immediately and after delays
-    attachGearClickListener();
-    setTimeout(attachGearClickListener, 100);
-    setTimeout(attachGearClickListener, 500);
-
-    // Event delegation as backup
-    const pageHeaderContainer = document.querySelector('.page-header') || document.querySelector('#current-page-title-container');
-    if (pageHeaderContainer && !pageHeaderContainer.hasAttribute('data-properties-delegation-attached')) {
-        pageHeaderContainer.setAttribute('data-properties-delegation-attached', 'true');
-        pageHeaderContainer.addEventListener('click', (e) => {
-            if (e.target.matches('#page-properties-gear, .page-title-gear, [data-feather="settings"], svg.feather-settings') ||
-                e.target.closest('#page-properties-gear, .page-title-gear, [data-feather="settings"], svg.feather-settings')) {
-                handleGearClick();
-            }
-        });
-    }
-}
-
-function updateSaveStatusIndicatorVisuals() {
-    const indicator = document.getElementById('save-status-indicator');
-    if (!indicator) { console.warn('Save status indicator element not found.'); return; }
-    const currentSaveStatus = saveStatus; 
-    const splashScreen = document.getElementById('splash-screen');
-    const isSplashVisible = splashScreen && !splashScreen.classList.contains('hidden');
-    if (isSplashVisible) { indicator.classList.add('status-hidden'); indicator.innerHTML = ''; return; } 
-    else { indicator.classList.remove('status-hidden'); }
-    indicator.classList.remove('status-saved', 'status-pending', 'status-error');
-    indicator.classList.add(`status-${currentSaveStatus}`);
-    let iconHtml = '';
-    switch (currentSaveStatus) {
-        case 'saved': iconHtml = '<i data-feather="check-circle"></i>'; indicator.title = 'All changes saved'; break;
-        case 'pending': iconHtml = `<div class="dot-spinner"><div class="dot-spinner__dot"></div><div class="dot-spinner__dot"></div><div class="dot-spinner__dot"></div></div>`; indicator.title = 'Saving changes...'; break;
-        case 'error': iconHtml = '<i data-feather="alert-triangle"></i>'; indicator.title = 'Error saving changes. Please try again.'; break;
-        default: console.warn(`Unknown save status: ${currentSaveStatus}. Defaulting visual to 'saved'.`); indicator.classList.remove('status-pending', 'status-error'); indicator.classList.add(`status-saved`); iconHtml = '<i data-feather="check-circle"></i>'; indicator.title = 'All changes saved'; break;
-    }
-    indicator.innerHTML = iconHtml;
-    if (currentSaveStatus === 'saved' || currentSaveStatus === 'error') {
-        if (typeof feather !== 'undefined' && feather.replace) { feather.replace({ width: '18px', height: '18px', 'stroke-width': '2' }); } 
-        else { console.warn('Feather Icons library not found.'); if (currentSaveStatus === 'saved') indicator.textContent = ''; if (currentSaveStatus === 'error') indicator.textContent = '!'; }
-    }
-}
-
-function updateSaveStatusIndicator(newStatus) {
-    setSaveStatus(newStatus); 
-    updateSaveStatusIndicatorVisuals(); 
-}
-
-// Template related functions (to be potentially moved)
-async function handleNoteTemplateInsertion(contentDiv, templateName) { 
-    console.log('[Templates] handleNoteTemplateInsertion called with:', templateName);
-    // Actual insertion logic is complex and deferred.
-    // For now, just replace the trigger.
-    if (contentDiv && contentDiv.textContent.endsWith('/' + templateName.split(' ')[0])) { // crude match
-        contentDiv.textContent = contentDiv.textContent.replace(/\/[^\s]*$/, `[[Template: ${templateName}]]`);
-    } else if (contentDiv && contentDiv.textContent.includes('/')) {
-         contentDiv.textContent = contentDiv.textContent.replace('/', `[[Template: ${templateName}]]` );
+function renderTransclusion(placeholder, content, blockId) {
+    if (!placeholder) return;
+
+    // The main content of the transclusion
+    const contentDiv = document.createElement('div');
+    contentDiv.className = 'transclusion-content';
+    contentDiv.innerHTML = parseAndRenderContent(content); // Use existing parser
+
+    // Optional: Add a link back to the original block
+    const permalink = document.createElement('a');
+    permalink.href = `?block_id=${blockId}`; // Simple link, might need context-aware routing
+    permalink.className = 'transclusion-permalink';
+    permalink.innerHTML = '<i data-feather="corner-up-left"></i>';
+    permalink.title = 'Go to block';
+    
+    // Clear placeholder and append new elements
+    placeholder.innerHTML = '';
+    placeholder.appendChild(contentDiv);
+    placeholder.appendChild(permalink);
+    placeholder.classList.remove('transclusion-placeholder');
+    placeholder.classList.add('transclusion-item');
+    
+    // Re-run feather icons if needed
+    if (typeof feather !== 'undefined') {
+        feather.replace({ width: '1em', height: '1em' });
     }
-    templateAutocomplete.hide();
 }
-async function showPageTemplateMenu(pageId) { console.log('[Templates] showPageTemplateMenu called for pageId:', pageId); }
-function addTemplateButtonToPageProperties() { console.log('[Templates] addTemplateButtonToPageProperties called'); }
-
-const templateAutocomplete = {
-    templates: [],
-    dropdownEl: null,
-    activeTarget: null,
-    selectedIndex: -1,
-
-    async init() {
-        console.log('[Templates] templateAutocomplete.init()');
-        this.dropdownEl = document.createElement('div');
-        this.dropdownEl.className = 'template-autocomplete-dropdown';
-        this.dropdownEl.style.display = 'none';
-        this.dropdownEl.style.position = 'absolute';
-        this.dropdownEl.style.border = '1px solid #ccc';
-        this.dropdownEl.style.backgroundColor = 'white';
-        this.dropdownEl.style.zIndex = '1000';
-        document.body.appendChild(this.dropdownEl);
-        await this.loadTemplates();
-
-        // Add global click listener to hide dropdown
-        document.addEventListener('click', (e) => {
-            if (this.dropdownEl && !this.dropdownEl.contains(e.target) && this.activeTarget !== e.target) {
-                this.hide();
-            }
-        }, true); // Use capture phase
-
-        // Add keyboard navigation
-        // Storing the bound function reference for potential future removal (e.g., in a destroy method)
-        this._boundKeyDownHandler = this._handleKeyDown.bind(this);
-        document.addEventListener('keydown', this._boundKeyDownHandler, true); // true for capture phase
-    },
-
-    _handleKeyDown(e) {
-        // If dropdown is not active, do nothing and let event propagate.
-        if (!this.dropdownEl || this.dropdownEl.style.display !== 'block' || !this.activeTarget) {
-            return; 
-        }
-
-        // If dropdown IS active, then we will handle specific keys.
-        // The activeTarget check ensures context.
-        if (!this.activeTarget.matches('.note-content.edit-mode')) {
-            // console.log('[Templates] _handleKeyDown: Dropdown is active, but target is not a note content div in edit mode.');
-            // This path should ideally not be hit if show() correctly sets activeTarget
-            // and hide() clears it / click-away logic is sound.
-            // If it does, letting event propagate might be okay, or we could hide().
-            return; 
-        }
-        
-        // console.log('[Templates] _handleKeyDown CAPTURE key:', e.key, 'SelectedIndex:', this.selectedIndex);
-
-        switch (e.key) {
-            case 'ArrowDown':
-                e.preventDefault(); // Must be first
-                e.stopPropagation(); // Then stop others
-                // console.log('[Templates] ArrowDown CAPTURE. Current selectedIndex:', this.selectedIndex, 'Templates length:', this.templates ? this.templates.length : 'undefined');
-                if (this.templates && this.templates.length > 0 && this.selectedIndex < this.templates.length - 1) {
-                    const items = this.dropdownEl.querySelectorAll('li');
-                    if (this.selectedIndex > -1 && items[this.selectedIndex]) {
-                        items[this.selectedIndex].classList.remove('selected');
-                    }
-                    this.selectedIndex++;
-                    if (items[this.selectedIndex]) {
-                        items[this.selectedIndex].classList.add('selected');
-                        // console.log('[Templates] ArrowDown CAPTURE: New selectedIndex:', this.selectedIndex, 'Item:', items[this.selectedIndex].textContent);
-                    }
-                }
-                break;
-            case 'ArrowUp':
-                e.preventDefault(); // Must be first
-                e.stopPropagation(); // Then stop others
-                // console.log('[Templates] ArrowUp CAPTURE. Current selectedIndex:', this.selectedIndex);
-                if (this.templates && this.templates.length > 0 && this.selectedIndex > 0) {
-                    const items = this.dropdownEl.querySelectorAll('li');
-                    if (items[this.selectedIndex]) { // current item
-                        items[this.selectedIndex].classList.remove('selected');
-                    }
-                    this.selectedIndex--;
-                    if (items[this.selectedIndex]) { // new current item
-                        items[this.selectedIndex].classList.add('selected');
-                        // console.log('[Templates] ArrowUp CAPTURE: New selectedIndex:', this.selectedIndex, 'Item:', items[this.selectedIndex].textContent);
-                    }
-                }
-                break;
-            case 'Enter':
-                e.preventDefault(); // Must be first
-                e.stopPropagation(); // Then stop others
-                // console.log('[Templates] Enter CAPTURE. SelectedIndex:', this.selectedIndex);
-                if (this.selectedIndex !== -1 && this.templates && this.templates[this.selectedIndex]) {
-                    const templateName = this.templates[this.selectedIndex].name;
-                    // console.log('[Templates] Enter CAPTURE: Attempting to insert template:', templateName);
-                    this._insertTemplate(this.activeTarget, templateName);
-                } else {
-                    // console.log('[Templates] Enter CAPTURE: no item selected or templates array issue.');
-                    this.hide(); // Hide if no selection or issue with templates
-                }
-                break;
-            case 'Escape':
-                e.preventDefault(); // Must be first
-                e.stopPropagation(); // Then stop others
-                // console.log('[Templates] Escape CAPTURE. Hiding dropdown.');
-                this.hide();
-                break;
-            default:
-                // If the dropdown is active but we don't handle the key (e.g., typing a letter),
-                // we let the event propagate by doing nothing here. This allows typing into the
-                // note content, which might be desired for filtering later or if the user decides
-                // not to use a template. The problem of the dropdown disappearing on typing
-                // will be handled by other logic (e.g., in handleNoteInput or by filtering).
-                break; 
-        }
-    },
-
-    _insertTemplate(contentDiv, templateName) {
-        if (!contentDiv || !templateName) return;
-
-        try {
-            // Get the current cursor position
-            const selection = window.getSelection();
-            if (!selection.rangeCount) return;
-            
-            const range = selection.getRangeAt(0);
-            const cursorPosition = range.startOffset;
-
-            // Get the text content
-            const text = contentDiv.textContent || '';
-            
-            // Find the last '/' before the cursor
-            const lastSlashIndex = text.lastIndexOf('/', cursorPosition);
-            if (lastSlashIndex === -1) return;
-
-            // Find the template object
-            const template = this.templates.find(t => t.name === templateName);
-            if (!template) {
-                console.error(`[Templates] Template "${templateName}" not found.`);
-                this.hide(); // Still hide the dropdown
-                return;
-            }
-
-            const templateContent = template.content || '';
-
-            // Create new text with template content inserted
-            const beforeSlash = text.substring(0, lastSlashIndex);
-            const afterCursor = text.substring(cursorPosition);
-            const newText = beforeSlash + templateContent + afterCursor;
-
-            // Update the content
-            contentDiv.textContent = newText;
 
-            // Set cursor position after the inserted template
-            const newCursorPosition = beforeSlash.length + templateContent.length;
-            const newRange = document.createRange();
-
-            // Ensure contentDiv has a text node if it's empty, otherwise setStart might fail
-            if (contentDiv.childNodes.length === 0) {
-                contentDiv.appendChild(document.createTextNode(''));
-            }
-            // Try to set range on firstChild, fallback to contentDiv itself if no child or firstChild is not a text node
-            const nodeToSetCursorIn = (contentDiv.firstChild && contentDiv.firstChild.nodeType === Node.TEXT_NODE) ? contentDiv.firstChild : contentDiv;
-            const maxOffset = nodeToSetCursorIn.nodeType === Node.TEXT_NODE ? nodeToSetCursorIn.textContent.length : nodeToSetCursorIn.childNodes.length;
-            
-            newRange.setStart(nodeToSetCursorIn, Math.min(newCursorPosition, maxOffset));
-            newRange.setEnd(nodeToSetCursorIn, Math.min(newCursorPosition, maxOffset));
-            selection.removeAllRanges();
-            selection.addRange(newRange);
-
-            // Update dataset for save mechanism
-            contentDiv.dataset.rawContent = contentDiv.textContent;
-
-            // Trigger input event to ensure note content is saved
-            contentDiv.dispatchEvent(new Event('input', { bubbles: true }));
-        } catch (error) {
-            console.error('[Templates] Error inserting template:', error);
-        } finally {
-            this.hide();
-        }
-    },
-
-    show(targetElement) {
-        this.activeTarget = targetElement;
-        this.selectedIndex = -1; // Reset selection
-        console.log('[Templates] templateAutocomplete.show() called for target:', targetElement);
-        
-        if (!this.dropdownEl) {
-            console.error('[Templates] Dropdown element not initialized.');
-            return;
-        }
-
-        if (!this.templates || this.templates.length === 0) {
-            console.log('[Templates] No templates to show or still loading.');
-            this.dropdownEl.innerHTML = '<li>Loading templates...</li>';
-        } else {
-            this.dropdownEl.innerHTML = ''; // Clear previous items
-            const ul = document.createElement('ul');
-            ul.style.listStyle = 'none';
-            ul.style.margin = '0';
-            ul.style.padding = '5px';
-            
-            // Create all items first
-            const items = this.templates.map((template, index) => {
-                const li = document.createElement('li');
-                li.textContent = template.name;
-                li.style.padding = '5px';
-                li.style.cursor = 'pointer';
-                li.dataset.index = index;
-                li.dataset.templateName = template.name;
-                return li;
-            });
-
-            // Then add event listeners
-            items.forEach((li, index) => {
-                li.addEventListener('mouseover', () => {
-                    if (this.selectedIndex !== -1) {
-                        items[this.selectedIndex].classList.remove('selected');
-                    }
-                    this.selectedIndex = index;
-                    li.classList.add('selected');
-                });
-                li.addEventListener('mouseout', () => {
-                    if (this.selectedIndex !== index) {
-                        li.classList.remove('selected');
-                    }
-                });
-                li.addEventListener('click', (e) => {
-                    e.preventDefault();
-                    e.stopPropagation();
-                    const templateName = li.dataset.templateName;
-                    if (templateName) {
-                        this._insertTemplate(this.activeTarget, templateName);
-                    }
-                });
-                ul.appendChild(li);
-            });
-
-            this.dropdownEl.appendChild(ul);
-
-            // Auto-select first item
-            if (items.length > 0) {
-                this.selectedIndex = 0;
-                items[0].classList.add('selected');
-            }
-        }
-
-        const rect = targetElement.getBoundingClientRect();
-        this.dropdownEl.style.top = `${rect.bottom + window.scrollY}px`;
-        this.dropdownEl.style.left = `${rect.left + window.scrollX}px`;
-        this.dropdownEl.style.display = 'block';
-        console.log('[Templates] Dropdown displayed with items:', this.templates.length);
-    },
-
-    hide() {
-        if (this.dropdownEl) {
-            this.dropdownEl.style.display = 'none';
-        }
-        this.activeTarget = null;
-        this.selectedIndex = -1;
-        console.log('[Templates] Dropdown hidden');
-    },
+/**
+ * Prompts the user for a password using a modal.
+ * @returns {Promise<string>} A promise that resolves with the entered password.
+ */
+function promptForPassword() {
+    return new Promise((resolve, reject) => {
+        const modal = domRefs.passwordModal;
+        const input = domRefs.passwordInput;
+        const submit = domRefs.passwordSubmit;
+        const cancel = domRefs.passwordCancel;
+
+        if (!modal || !input || !submit || !cancel) {
+            return reject(new Error('Password modal elements not found in the DOM.'));
+        }
+
+        const cleanup = () => {
+            submit.removeEventListener('click', handleSubmit);
+            cancel.removeEventListener('click', handleCancel);
+            input.removeEventListener('keydown', handleKeydown);
+            modal.style.display = 'none';
+        };
 
-    async loadTemplates() {
-        console.log('[Templates] templateAutocomplete.loadTemplates()');
-        if (window.templatesAPI && typeof window.templatesAPI.getTemplates === 'function') {
-            try {
-                // Pass 'note' as the type parameter since this is for note templates
-                const response = await window.templatesAPI.getTemplates('note');
-                // Handle both array and object response formats
-                this.templates = Array.isArray(response) ? response : (response.data || []);
-                console.log('[Templates] Templates loaded:', this.templates);
-                
-                if (this.templates.length === 0) {
-                    this.templates = [{name: "No templates available", content: ""}];
-                }
-            } catch (error) {
-                console.error('[Templates] Error loading templates:', error);
-                this.templates = [{name: "Error loading templates. Please try again.", content: ""}];
+        const handleSubmit = () => {
+            const password = input.value;
+            if (password) {
+                cleanup();
+                resolve(password);
             }
-        } else {
-            console.error('[Templates] window.templatesAPI.getTemplates is not available.');
-            this.templates = [{name: "Template system not available", content: ""}];
-        }
-    }
-};
-
-function getCursorCharacterOffsetWithin(element) { /* ... */ return 0; } // Stubbed
-
-function handleNoteInput(e) {
-    if (!e.target || !e.target.matches || !e.target.matches('.note-content.edit-mode')) {
-        // console.log('[Templates] handleNoteInput: Event target is not a note content div in edit mode.');
-        return;
-    }
-    const contentDiv = e.target;
-    const text = contentDiv.textContent || '';
-    
-    // Determine cursor position carefully
-    let cursorPosition = 0;
-    const selection = window.getSelection();
-    if (selection && selection.rangeCount > 0) {
-        const range = selection.getRangeAt(0);
-        // Ensure the cursor is within the contentDiv.
-        // If range.startContainer is contentDiv itself, startOffset is char offset or child index.
-        // If range.startContainer is a text node inside contentDiv, startOffset is char offset within text node.
-        // For simplicity, assuming cursor is directly in contentDiv or its direct text node.
-        // A more robust way might involve traversing from range.startContainer up to contentDiv.
-        if (contentDiv.contains(range.startContainer)) {
-             cursorPosition = range.startOffset;
-             // If startContainer is not contentDiv itself but a child (e.g. text node)
-             // we might need to sum offsets of previous siblings if contentDiv has mixed content.
-             // However, note-content is usually a single text block or gets replaced.
-             // For this specific case, this should be mostly fine.
-        } else {
-            // Cursor is not within the contentDiv that received the input event. Strange.
-            // console.log('[Templates] handleNoteInput: Cursor not in the target contentDiv.');
-            return;
-        }
-    } else {
-        // console.log('[Templates] handleNoteInput: No selection or range.');
-        // If no selection, we might not be able to determine where to show dropdown.
-        // However, an input event usually implies there's a cursor/selection.
-        return; 
-    }
-
-    const isDropdownVisible = templateAutocomplete.dropdownEl && 
-                            templateAutocomplete.dropdownEl.style.display === 'block';
-
-    let shouldShowDropdown = false;
-    let shouldHideDropdown = false;
-    // let potentialFilterText = ""; // For future filtering logic
+        };
 
-    // Analyze text around cursor to decide whether to show/hide/keep open
-    if (cursorPosition > 0) {
-        const textBeforeCursor = text.substring(0, cursorPosition);
-        const lastCharIndexInTextBeforeCursor = textBeforeCursor.length - 1;
+        const handleCancel = () => {
+            cleanup();
+            reject(new Error('Password entry cancelled.'));
+        };
         
-        if (lastCharIndexInTextBeforeCursor >= 0 && textBeforeCursor[lastCharIndexInTextBeforeCursor] === '/') {
-            // If the character right before cursor is '/', show.
-            shouldShowDropdown = true;
-        } else {
-            // If not '/', check if we are in "template typing mode"
-            // This means: dropdown is already visible, and the text from the last '/' 
-            // to the cursor is a valid non-empty sequence without spaces/newlines.
-            if (isDropdownVisible) {
-                const lastSlashGlobalIndex = textBeforeCursor.lastIndexOf('/');
-                if (lastSlashGlobalIndex !== -1) {
-                    const textAfterSlash = textBeforeCursor.substring(lastSlashGlobalIndex + 1);
-                    // If textAfterSlash is empty, it means cursor is right after / - handled by previous 'if'
-                    // If textAfterSlash is not empty, check if it's a valid filter prefix
-                    if (textAfterSlash.length > 0 && !textAfterSlash.includes(' ') && !textAfterSlash.includes('\n')) {
-                        // Likely typing a template name. Keep dropdown open.
-                        shouldShowDropdown = true; // Effectively "keep open"
-                        // potentialFilterText = textAfterSlash;
-                    } else {
-                        // Invalid char after slash (space, newline) or slash was deleted. Hide.
-                        shouldHideDropdown = true;
-                    }
-                } else {
-                    // No '/' found before cursor while dropdown is visible. Hide.
-                    shouldHideDropdown = true;
-                }
+        const handleKeydown = (e) => {
+            if (e.key === 'Enter') {
+                handleSubmit();
+            } else if (e.key === 'Escape') {
+                handleCancel();
             }
-            // If dropdown is not visible and char before cursor is not '/', do nothing.
-        }
-    } else if (isDropdownVisible) { 
-        // Cursor is at the beginning of the text (cursorPosition === 0), but dropdown is visible.
-        // This implies the trigger '/' was deleted.
-        shouldHideDropdown = true;
-    }
-    // If text is empty, and dropdown is visible, hide it.
-    if (text.length === 0 && isDropdownVisible) {
-        shouldHideDropdown = true;
-    }
+        };
 
+        input.value = '';
+        submit.addEventListener('click', handleSubmit);
+        cancel.addEventListener('click', handleCancel);
+        input.addEventListener('keydown', handleKeydown);
 
-    if (shouldShowDropdown) {
-        // If it should be shown (or kept open)
-        if (!isDropdownVisible) {
-            // console.log('[Templates] handleNoteInput: Showing dropdown.');
-            templateAutocomplete.show(contentDiv); 
-        }
-        // If it's already visible, do nothing here, just don't hide it.
-        // Later, filtering logic would go here:
-        // templateAutocomplete.filter(potentialFilterText);
-    } else if (shouldHideDropdown && isDropdownVisible) {
-        // console.log('[Templates] handleNoteInput: Hiding dropdown.');
-        templateAutocomplete.hide();
-    }
-    // Otherwise, do nothing (e.g. dropdown not visible, no trigger).
+        modal.style.display = 'flex';
+        input.focus();
+    });
 }
 
-// Add global click handler for template dropdown
-document.addEventListener('click', (e) => {
-    if (templateAutocomplete.dropdownEl && 
-        templateAutocomplete.dropdownEl.style.display === 'block' && 
-        !templateAutocomplete.dropdownEl.contains(e.target) &&
-        !e.target.matches('.note-content.edit-mode')) {
-        templateAutocomplete.hide();
-    }
-});
-
-document.addEventListener('DOMContentLoaded', () => {
-    templateAutocomplete.init(); // init will call loadTemplates
-    addTemplateButtonToPageProperties(); // Remains stubbed for now
-    // The 'input' event listener for notesContainer in app.js handles general input.
-    // This document 'input' listener in ui.js is specifically for template autocomplete.
-    // It might conflict or be redundant if app.js notesContainer input listener is too broad.
-    // For now, let's assume this specific one is for templates.
-    // Re-evaluating: The input listener in app.js is for saving notes.
-    // This one in ui.js should be specifically for the template trigger.
-    // It's better to attach this to notesContainer as well for consistency.
-    // However, the original code has `document.addEventListener('input', handleNoteInput);`
-    // Let's keep it for now, but be aware it might need refinement.
-    console.log('[Templates] Adding document input listener for handleNoteInput');
-    document.addEventListener('input', handleNoteInput);
-});
-
 // Export the main UI object
 export const ui = {
-    // Functions imported from note-elements.js
     displayNotes,
-    updateNoteElement,
     addNoteElement,
     removeNoteElement,
-    moveNoteElement,
     buildNoteTree,
     initializeDragAndDrop,
     handleNoteDrop,
-
-    // Functions imported from note-renderer.js
     renderNote,
     parseAndRenderContent,
     switchToEditMode,
@@ -1334,40 +402,25 @@ export const ui = {
     normalizeNewlines,
     renderAttachments,
     renderProperties,
-
-    // Functions remaining in ui.js
+    initializeDelegatedNoteEventListeners,
+    renderTransclusion,
     domRefs,
     updatePageTitle,
     updatePageList,
     updateActivePageLink,
-    showPropertyInNote,
-    removePropertyFromNote,
-    renderTransclusion,
-    calendarWidget,
-    showGenericInputModal,
-    showGenericConfirmModal,
-    extractPropertiesFromContent,
-    renderInlineProperties,
     renderPageInlineProperties,
-    getNoteAncestors,
+    initPagePropertiesModal,
+    updateSaveStatusIndicator,
     renderBreadcrumbs,
-    showAllNotesAndLoadPage,
-    // renderNoteProperties, // Removed
     focusOnNote,
     showAllNotes,
+    showAllNotesAndLoadPage,
     getNestingLevel,
-    updateParentVisuals,
-    initPagePropertiesModal,
-    updateSaveStatusIndicatorVisuals,
-    updateSaveStatusIndicator,
-    handleNoteTemplateInsertion,
-    showPageTemplateMenu,
-    addTemplateButtonToPageProperties,
-    templateAutocomplete,
-    // initializeDelegatedNoteEventListeners // It's used internally in this file now, not re-exported typically
+    calendarWidget,
+    promptForPassword
 };
 
-// Make ui available globally for backward compatibility
+// Make ui available globally
 if (typeof window !== 'undefined') {
     window.ui = ui;
-}
+}
\ No newline at end of file
diff --git a/assets/js/ui/calendar-widget.js b/assets/js/ui/calendar-widget.js
new file mode 100644
index 0000000..22d771e
--- /dev/null
+++ b/assets/js/ui/calendar-widget.js
@@ -0,0 +1,237 @@
+/**
+ * Calendar Widget Module for NotTD application
+ * Handles rendering and interaction of the calendar.
+ * @module calendarWidget
+ */
+
+import { apiRequest } from '../api_client.js';
+
+const domRefs = {}; // To store DOM references for the calendar widget
+
+let currentPageName = null; // To keep track of the currently active page for highlighting
+
+/**
+ * Converts a Date object to a 'YYYY-MM-DD' string.
+ * @param {Date} date - The date to convert.
+ * @returns {string} The formatted date string.
+ */
+function toYYYYMMDD(date) {
+    const year = date.getFullYear();
+    const month = String(date.getMonth() + 1).padStart(2, '0');
+    const day = String(date.getDate()).padStart(2, '0');
+    return `${year}-${month}-${day}`;
+}
+
+/**
+ * Initializes DOM references for the calendar widget.
+ */
+function initializeDomRefs() {
+    domRefs.calendarWidget = document.getElementById('calendar-widget');
+    domRefs.calendarHeader = document.querySelector('.calendar-header');
+    domRefs.monthYearDisplay = document.getElementById('current-month-year');
+    domRefs.prevMonthBtn = document.getElementById('prev-month-btn');
+    domRefs.nextMonthBtn = document.getElementById('next-month-btn');
+    domRefs.calendarDaysGrid = document.getElementById('calendar-days-grid');
+}
+
+let currentDisplayDate = new Date(); // Stores the month and year currently displayed by the calendar
+
+/**
+ * Renders the calendar grid for the current month and year.
+ * @param {Date} date - The date to display the calendar for (month and year).
+ * @param {Array} pagesWithDates - Array of pages that have a 'date' property, used for highlighting.
+ */
+async function renderCalendar(date, pagesWithDates = []) {
+    if (!domRefs.calendarDaysGrid) {
+        initializeDomRefs(); // Ensure refs are initialized
+    }
+    if (!domRefs.calendarDaysGrid) return; // If still not found, exit
+
+    domRefs.calendarDaysGrid.innerHTML = '';
+    domRefs.monthYearDisplay.textContent = date.toLocaleString('default', { month: 'long', year: 'numeric' });
+
+    const year = date.getFullYear();
+    const month = date.getMonth(); // 0-indexed
+
+    // Get the first day of the month
+    const firstDay = new Date(year, month, 1);
+    // Get the last day of the month
+    const lastDay = new Date(year, month + 1, 0);
+
+    // Calculate the day of the week for the first day (0 = Sunday, 6 = Saturday)
+    // Adjust to make Monday = 0, Sunday = 6
+    let startDayOfWeek = firstDay.getDay();
+    startDayOfWeek = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1; // Convert Sunday (0) to 6, Monday (1) to 0, etc.
+
+    // Fill in leading empty days
+    for (let i = 0; i < startDayOfWeek; i++) {
+        domRefs.calendarDaysGrid.appendChild(createDayElement('', true));
+    }
+
+    // Fill in days of the month
+    for (let day = 1; day <= lastDay.getDate(); day++) {
+        const currentDate = new Date(year, month, day);
+        const formattedDate = toYYYYMMDD(currentDate);
+
+        // Find a page that is either named with this date, or has a property for this date.
+        const pageForThisDate = pagesWithDates.find(p => {
+            if (p.name === formattedDate) return true;
+            if (p.properties && p.properties.date) {
+                return p.properties.date.some(prop => prop.value === formattedDate);
+            }
+            return false;
+        });
+
+        const isToday = formattedDate === toYYYYMMDD(new Date());
+        const isCurrentPageDate = pageForThisDate && currentPageName === pageForThisDate.name;
+
+        domRefs.calendarDaysGrid.appendChild(
+            createDayElement(day, false, isToday, pageForThisDate, isCurrentPageDate)
+        );
+    }
+}
+
+/**
+ * Creates a single day element for the calendar.
+ * @param {string|number} day - The day number or empty string for placeholder.
+ * @param {boolean} isEmpty - True if it's an empty placeholder day.
+ * @param {boolean} isToday - True if the day is today.
+ * @param {Object|null} pageForThisDate - The page object associated with this date, if any.
+ * @param {boolean} isCurrentPageDate - True if the page for this date is the currently active page.
+ * @returns {HTMLElement} The day element.
+ */
+function createDayElement(day, isEmpty, isToday = false, pageForThisDate = null, isCurrentPageDate = false) {
+    const div = document.createElement('div');
+    div.className = 'calendar-day';
+    if (isEmpty) {
+        div.classList.add('empty');
+    } else {
+        div.textContent = day;
+        const formattedDate = currentDisplayDate.getFullYear() + '-' + 
+                              String(currentDisplayDate.getMonth() + 1).padStart(2, '0') + '-' + 
+                              String(day).padStart(2, '0');
+        div.dataset.date = formattedDate;
+
+        if (isToday) {
+            div.classList.add('today');
+        }
+        if (pageForThisDate) {
+            div.classList.add('has-content'); // Indicate that there's content on this day
+            // Store the page name to navigate to if clicked
+            div.dataset.pageName = pageForThisDate.name;
+            div.title = `Page: ${pageForThisDate.name}`; // Tooltip for content
+        }
+        if (isCurrentPageDate) {
+            div.classList.add('current-page');
+        }
+    }
+    return div;
+}
+
+/**
+ * Fetches pages for a given month and re-renders the calendar.
+ * @param {Date} date - The date representing the month to fetch pages for.
+ */
+async function fetchAndRenderCalendar(date) {
+    const year = date.getFullYear();
+    const month = date.getMonth(); // month is 0-indexed
+
+    try {
+        // Fetch all pages to check against calendar dates.
+        // In a larger app, this might be optimized to fetch only pages for the visible month.
+        const response = await apiRequest(`pages.php?page=1&per_page=1000`);
+
+        const allPages = response.data || [];
+        const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
+        
+        // Filter pages to find those that have a 'date' property or are named like a date for the current month
+        const pagesForMonth = allPages.filter(page => {
+            // Check if page name is a date in the current view
+            if (dateRegex.test(page.name)) {
+                const [pageYear, pageMonth] = page.name.split('-').map(Number);
+                if (pageYear === year && (pageMonth - 1) === month) {
+                    return true;
+                }
+            }
+
+            // Check if a 'date' property points to a date in the current view
+            if (page.properties && page.properties.date) {
+                return page.properties.date.some(prop => {
+                    if (!prop.value) return false;
+                    const [propYear, propMonth] = prop.value.split('-').map(Number);
+                    return propYear === year && (propMonth - 1) === month;
+                });
+            }
+            return false;
+        });
+
+        renderCalendar(date, pagesForMonth);
+    } catch (error) {
+        console.error('Error fetching pages for calendar:', error);
+        // Render calendar without page data if there's an error
+        renderCalendar(date);
+    }
+}
+
+
+/**
+ * Sets up event listeners for the calendar navigation.
+ */
+function setupEventListeners() {
+    if (!domRefs.calendarWidget) {
+        initializeDomRefs();
+    }
+    if (!domRefs.prevMonthBtn || !domRefs.nextMonthBtn || !domRefs.calendarDaysGrid) return;
+
+    domRefs.prevMonthBtn.addEventListener('click', () => {
+        currentDisplayDate.setMonth(currentDisplayDate.getMonth() - 1);
+        fetchAndRenderCalendar(currentDisplayDate);
+    });
+
+    domRefs.nextMonthBtn.addEventListener('click', () => {
+        currentDisplayDate.setMonth(currentDisplayDate.getMonth() + 1);
+        fetchAndRenderCalendar(currentDisplayDate);
+    });
+
+    domRefs.calendarDaysGrid.addEventListener('click', (e) => {
+        const dayElement = e.target.closest('.calendar-day');
+        if (!dayElement || dayElement.classList.contains('empty')) return;
+
+        // If a page name is directly associated (from 'date' property or name match), use it.
+        let pageNameToLoad = dayElement.dataset.pageName;
+
+        // If no page name is associated, assume it's a daily note named after the date.
+        if (!pageNameToLoad && dayElement.dataset.date) {
+            pageNameToLoad = dayElement.dataset.date;
+        }
+
+        if (pageNameToLoad && window.loadPage) {
+            window.loadPage(pageNameToLoad);
+        }
+    });
+}
+
+/**
+ * Initializes the calendar widget.
+ */
+function init() {
+    initializeDomRefs();
+    setupEventListeners();
+    fetchAndRenderCalendar(currentDisplayDate);
+}
+
+/**
+ * Updates the currently active page name for highlighting in the calendar.
+ * @param {string} pageName - The name of the currently loaded page.
+ */
+function setCurrentPage(pageName) {
+    currentPageName = pageName;
+    // Re-render to update highlights if the calendar is already visible
+    fetchAndRenderCalendar(currentDisplayDate);
+}
+
+export const calendarWidget = {
+    init,
+    setCurrentPage,
+    domRefs // Expose domRefs for external access if needed (e.g., for initial setup in app.js)
+}; 
\ No newline at end of file
diff --git a/assets/js/ui/dom-refs.js b/assets/js/ui/dom-refs.js
index 1f7f767..e68cc15 100644
--- a/assets/js/ui/dom-refs.js
+++ b/assets/js/ui/dom-refs.js
@@ -6,7 +6,7 @@
 
 export const domRefs = {
     notesContainer: document.getElementById('notes-container'),
-    pagePropertiesContainer: document.getElementById('page-properties'),
+    pagePropertiesContainer: document.getElementById('page-properties-container'),
     pageListContainer: document.getElementById('page-list'),
     addRootNoteBtn: document.getElementById('add-root-note-btn'),
     toggleLeftSidebarBtn: document.getElementById('toggle-left-sidebar-btn'),
diff --git a/assets/js/ui/note-elements.js b/assets/js/ui/note-elements.js
index 6dac37f..a727b13 100644
--- a/assets/js/ui/note-elements.js
+++ b/assets/js/ui/note-elements.js
@@ -5,286 +5,97 @@
  */
 
 import { domRefs } from './dom-refs.js';
-// Assuming note-renderer.js will export renderNote, parseAndRenderContent, and renderAttachments
-import { renderNote, parseAndRenderContent, renderAttachments } from './note-renderer.js';
-// Assuming note-interactions.js will export updateParentVisuals and handleNoteDrop
-// import { updateParentVisuals } from './note-interactions.js';  // Remove this import as the function is in ui.js
-import { calculateOrderIndex } from '../app/order-index-service.js'; // Added import
-
-// Globals assumed to be available: Sortable, feather, window.notesAPI, window.notesForCurrentPage, window.currentPageId, ui (for ui.displayNotes in handleNoteDrop error case)
+import { renderNote } from './note-renderer.js';
+import { calculateOrderIndex } from '../app/order-index-service.js';
 
 /**
  * Displays notes in the container
  * @param {Array} notesData - Array of note objects
  * @param {number} pageId - Current page ID
  */
-function displayNotes(notesData, pageId) {
+export function displayNotes(notesData, pageId) {
     domRefs.notesContainer.innerHTML = '';
+    if (!notesData || notesData.length === 0) return;
 
-    if (!notesData || notesData.length === 0) {
-        // ui.displayNotes will now simply leave the container empty if there are no notes.
-        // The creation of the first note on an empty page is handled by app.js (handleCreateAndFocusFirstNote).
-        // No temporary client-side note needed here anymore.
-        return;
-    }
-
-    // Sort notes by order_index before building the tree
-    const sortedNotes = [...notesData].sort((a, b) => a.order_index - b.order_index);
-    
-    // Build and display note tree
+    const sortedNotes = [...notesData].sort((a, b) => (a.order_index || 0) - (b.order_index || 0));
     const noteTree = buildNoteTree(sortedNotes);
+    
     noteTree.forEach(note => {
         domRefs.notesContainer.appendChild(renderNote(note, 0));
     });
     
-    // Initialize drag and drop functionality
     initializeDragAndDrop();
-
-    // Initialize Feather icons after all notes are rendered
-    if (typeof feather !== 'undefined' && feather.replace) {
-        feather.replace();
-    }
+    if (typeof feather !== 'undefined') feather.replace();
 }
 
 /**
- * Updates an existing note element in the DOM with new data.
- * @param {string} noteId - The ID of the note to update.
- * @param {Object} updatedNoteData - The new data for the note.
+ * Adds a new note element to the DOM in its correct sorted position.
+ * @param {Object} noteData - The data for the new note.
+ * @returns {HTMLElement|null} The newly created note element.
  */
-function updateNoteElement(noteId, updatedNoteData) {
-    const noteElement = document.querySelector(`.note-item[data-note-id="${noteId}"]`);
-    if (!noteElement) {
-        console.warn(`updateNoteElement: Note element with ID ${noteId} not found.`);
-        return;
-    }
-
-    // Update content
-    const contentDiv = noteElement.querySelector('.note-content');
-    if (contentDiv) {
-        contentDiv.dataset.rawContent = updatedNoteData.content || '';
-        // If in rendered mode, re-render. If in edit mode, user is typing, so don't overwrite.
-        // However, if a background save updated content, edit mode should reflect it.
-        // For simplicity now, only re-render if in rendered-mode.
-        // More complex sync for edit mode might be needed if server changes content significantly.
-        if (contentDiv.classList.contains('rendered-mode')) {
-            contentDiv.innerHTML = parseAndRenderContent(updatedNoteData.content || '');
-        } else {
-            // If in edit mode, and the updated content is different from current text,
-            // it implies a background change. For now, we log this.
-            // A more sophisticated merge or notification could be implemented.
-            if (contentDiv.textContent !== (updatedNoteData.content || '')) {
-                console.log(`Note ${noteId} content updated in background while in edit mode. UI not refreshed to preserve user edits.`, { current: contentDiv.textContent, new: updatedNoteData.content });
-                 // Optionally, you could signal this to the user or update rawContent and let blur handle it.
-            }
-        }
-    }
+export function addNoteElement(noteData) {
+    if (!noteData) return null;
 
-    // Update properties (assuming parseAndRenderContent handles inline properties)
-    // If properties were displayed in a separate div, that would be updated here.
+    const parentId = noteData.parent_note_id || null;
+    const parentEl = parentId ? document.querySelector(`.note-item[data-note-id="${parentId}"]`) : domRefs.notesContainer;
 
-    // Update collapse state
-    const isCollapsed = updatedNoteData.collapsed === true || String(updatedNoteData.collapsed) === 'true';
-    noteElement.classList.toggle('collapsed', isCollapsed);
-    const arrowEl = noteElement.querySelector('.note-collapse-arrow');
-    if (arrowEl) {
-        arrowEl.dataset.collapsed = isCollapsed.toString();
-    }
-    const childrenContainer = noteElement.querySelector('.note-children');
-    if (childrenContainer) {
-        childrenContainer.classList.toggle('collapsed', isCollapsed);
-         childrenContainer.style.display = isCollapsed ? 'none' : ''; // Direct style for immediate effect
+    if (!parentEl) {
+        console.error("Could not find parent element for new note.", { parentId });
+        return null;
     }
     
-    // Update "has-children" indicator and parent visuals
-    // This relies on updatedNoteData.children being part of the data if it's available
-    // or checking the DOM if not. For now, let updateParentVisuals handle it based on DOM.
-    ui.updateParentVisuals(noteElement); // Call on itself to update its own arrow if children status changed
-
-    // Update attachments section if has_attachments info is available
-    const attachmentsContainer = noteElement.querySelector('.note-attachments');
-    if (attachmentsContainer && typeof updatedNoteData.has_attachments !== 'undefined') {
-        // renderAttachments is now idempotent and handles showing/hiding/fetching based on the flag
-        renderAttachments(attachmentsContainer, noteId, updatedNoteData.has_attachments);
-    }
-
-    if (typeof feather !== 'undefined' && feather.replace) {
-        feather.replace();
-    }
-}
-
-/**
- * Adds a new note element to the DOM.
- * @param {Object} noteData - The data for the new note.
- * @param {HTMLElement} targetDomContainer - The parent DOM container (notesContainer or a .note-children div).
- * @param {number} nestingLevel - The nesting level for the new note.
- * @param {HTMLElement|null} [beforeElement=null] - Optional: if provided, insert noteElement before this sibling.
- */
-function addNoteElement(noteData, targetDomContainer, nestingLevel, beforeElement = null) {
-    if (!noteData || !targetDomContainer) {
-        console.error('addNoteElement: noteData or targetDomContainer is null');
-        return null;
+    let parentContainer;
+    let nestingLevel;
+
+    if (parentId) {
+        parentContainer = parentEl.querySelector('.note-children');
+        if (!parentContainer) {
+            parentContainer = document.createElement('div');
+            parentContainer.className = 'note-children';
+            parentEl.appendChild(parentContainer);
+            parentEl.classList.add('has-children');
+            // Re-render arrow if needed
+            const controls = parentEl.querySelector('.note-controls');
+            if(controls && !controls.querySelector('.note-collapse-arrow')) {
+                const arrow = document.createElement('span');
+                arrow.className = 'note-collapse-arrow';
+                arrow.innerHTML = `<i data-feather="chevron-right"></i>`;
+                controls.insertBefore(arrow, controls.firstChild);
+                feather.replace();
+            }
+        }
+        nestingLevel = window.ui.getNestingLevel(parentEl) + 1;
+    } else {
+        parentContainer = domRefs.notesContainer;
+        nestingLevel = 0;
     }
 
     const newNoteEl = renderNote(noteData, nestingLevel);
 
-    // Find the correct position to insert based on order_index
-    if (!beforeElement) {
-        const siblings = Array.from(targetDomContainer.children)
-            .filter(child => child.classList.contains('note-item'))
-            .map(childEl => ({
-                element: childEl,
-                order_index: window.notesForCurrentPage.find(n => String(n.id) === String(childEl.dataset.noteId))?.order_index || Infinity
-            }))
-            .sort((a, b) => a.order_index - b.order_index);
+    const siblings = Array.from(parentContainer.children)
+        .filter(child => child.classList.contains('note-item'))
+        .map(el => ({ element: el, orderIndex: parseInt(window.notesForCurrentPage.find(n => n.id == el.dataset.noteId)?.order_index, 10) || 0 }));
 
-        // Find the first sibling with a higher order_index
-        const nextSibling = siblings.find(s => s.order_index > noteData.order_index);
-        if (nextSibling) {
-            beforeElement = nextSibling.element;
-        } else if (siblings.length > 0 && noteData.order_index < siblings[0].order_index) {
-            // If this note should be first, insert before the first sibling
-            beforeElement = siblings[0].element;
-        }
-    }
+    const nextSibling = siblings.find(sib => sib.orderIndex > noteData.order_index);
 
-    // Insert the new note at the correct position
-    if (beforeElement && beforeElement.parentElement === targetDomContainer) {
-        targetDomContainer.insertBefore(newNoteEl, beforeElement);
+    if (nextSibling) {
+        parentContainer.insertBefore(newNoteEl, nextSibling.element);
     } else {
-        // If no beforeElement or it's not in the target container, append to the end
-        targetDomContainer.appendChild(newNoteEl);
+        parentContainer.appendChild(newNoteEl);
     }
 
-    // Update visuals of the parent if this note is added as a child
-    if (targetDomContainer.classList.contains('note-children')) {
-        const parentNoteItem = targetDomContainer.closest('.note-item');
-        if (parentNoteItem) {
-            ui.updateParentVisuals(parentNoteItem);
-        }
-    }
-    
-    // Initialize Sortable on its children container if it has one and it's newly created by renderNote
-    const newChildrenContainer = newNoteEl.querySelector('.note-children');
-    if (newChildrenContainer && !newChildrenContainer.classList.contains('ui-sortable')) {
-        if (typeof Sortable !== 'undefined' && Sortable.create) {
-            Sortable.create(newChildrenContainer, { 
-                group: 'notes', 
-                animation: 150, 
-                handle: '.note-bullet', 
-                ghostClass: 'note-ghost', 
-                chosenClass: 'note-chosen', 
-                dragClass: 'note-drag', 
-                onEnd: handleNoteDrop 
-            });
-        }
-    }
-    
-    if (typeof feather !== 'undefined' && feather.replace) {
-        feather.replace();
-    }
     return newNoteEl;
 }
 
+
 /**
  * Removes a note element from the DOM.
  * @param {string} noteId - The ID of the note to remove.
  */
-function removeNoteElement(noteId) {
+export function removeNoteElement(noteId) {
     const noteElement = document.querySelector(`.note-item[data-note-id="${noteId}"]`);
-    if (!noteElement) {
-        console.warn(`removeNoteElement: Note element with ID ${noteId} not found.`);
-        return;
-    }
-
-    const parentDomContainer = noteElement.parentElement;
-    noteElement.remove();
-
-    if (parentDomContainer && parentDomContainer.classList.contains('note-children')) {
-        const parentNoteItem = parentDomContainer.closest('.note-item');
-        if (parentNoteItem) {
-            ui.updateParentVisuals(parentNoteItem);
-            if (parentDomContainer.children.length === 0) {
-                // If children container is empty, remove it to clean up DOM
-                parentDomContainer.remove();
-                parentNoteItem.classList.remove('has-children'); // Ensure visual state is correct
-            }
-        }
-    }
-    // No specific Feather call needed here unless parent visuals change icons.
-}
-
-/**
- * Moves a note element in the DOM to a new parent and nesting level.
- * Handles creation of children containers and updates nesting styles.
- * @param {HTMLElement} noteElement - The note element to move.
- * @param {HTMLElement} newParentDomElement - The new parent DOM element (can be notesContainer).
- * @param {number} newNestingLevel - The new nesting level for the moved note.
- * @param {HTMLElement|null} [beforeElement=null] - Optional: if provided, insert noteElement before this sibling.
- */
-function moveNoteElement(noteElement, newParentDomElement, newNestingLevel, beforeElement = null) {
-    if (!noteElement || !newParentDomElement) {
-        console.error('moveNoteElement: noteElement or newParentDomElement is null');
-        return;
-    }
-
-    const oldParentChildrenContainer = noteElement.parentElement;
-
-    let targetChildrenContainer;
-    if (newParentDomElement.id === 'notes-container') {
-        targetChildrenContainer = newParentDomElement;
-    } else {
-        targetChildrenContainer = newParentDomElement.querySelector('.note-children');
-        if (!targetChildrenContainer) {
-            targetChildrenContainer = document.createElement('div');
-            targetChildrenContainer.className = 'note-children';
-            newParentDomElement.appendChild(targetChildrenContainer);
-            // If Sortable is used, it might need to be initialized here for the new container
-            if (typeof Sortable !== 'undefined' && Sortable.create) {
-                 Sortable.create(targetChildrenContainer, { group: 'notes', animation: 150, handle: '.note-bullet', ghostClass: 'note-ghost', chosenClass: 'note-chosen', dragClass: 'note-drag', onEnd: handleNoteDrop });
-            }
-        }
-    }
-
-    // Move the element
-    if (beforeElement && beforeElement.parentElement === targetChildrenContainer) {
-        targetChildrenContainer.insertBefore(noteElement, beforeElement);
-    } else {
-        targetChildrenContainer.appendChild(noteElement);
-    }
-
-    // Update nesting level for the moved note and its children
-    function updateNestingRecursive(element, level) {
-        element.style.setProperty('--nesting-level', level);
-        const childrenContainer = element.querySelector('.note-children');
-        if (childrenContainer) {
-            Array.from(childrenContainer.children)
-                .filter(child => child.classList.contains('note-item'))
-                .forEach(childNote => updateNestingRecursive(childNote, level + 1));
-        }
-    }
-    updateNestingRecursive(noteElement, newNestingLevel);
-
-    // Update visuals for old and new parents
-    if (oldParentChildrenContainer && oldParentChildrenContainer !== targetChildrenContainer) {
-        const oldParentEl = oldParentChildrenContainer.closest('.note-item');
-        if (oldParentEl) {
-            ui.updateParentVisuals(oldParentEl);
-             // Check if old children container is empty
-            if (oldParentChildrenContainer.classList.contains('note-children') && oldParentChildrenContainer.children.length === 0) {
-                oldParentChildrenContainer.remove(); // Or hide, depending on desired behavior
-                oldParentEl.classList.remove('has-children'); // Ensure parent no longer shows as expandable
-            }
-        }
-    }
-    if (newParentDomElement.id !== 'notes-container') {
-        ui.updateParentVisuals(newParentDomElement);
-    } else {
-        // If new parent is notesContainer, there's no specific parent element to update visuals for in this way,
-        // but SortableJS root list might need refresh if not handled by its own mechanisms.
-    }
-     // Ensure Feather icons are re-applied if any were moved or changed
-    if (typeof feather !== 'undefined' && feather.replace) {
-        feather.replace();
+    if (noteElement) {
+        noteElement.remove();
     }
 }
 
@@ -294,12 +105,12 @@ function moveNoteElement(noteElement, newParentDomElement, newNestingLevel, befo
  * @param {number|null} [parentId=null] - Parent note ID
  * @returns {Array} Tree structure of notes
  */
-function buildNoteTree(notes, parentId = null) {
+export function buildNoteTree(notes, parentId = null) {
     if (!notes) return [];
     
     return notes
-        .filter(note => note.parent_note_id === parentId)
-        .sort((a, b) => a.order_index - b.order_index)
+        .filter(note => (note.parent_note_id || null) == parentId)
+        .sort((a, b) => (a.order_index || 0) - (b.order_index || 0))
         .map(note => ({
             ...note,
             children: buildNoteTree(notes, note.id)
@@ -307,289 +118,78 @@ function buildNoteTree(notes, parentId = null) {
 }
 
 /**
- * Handles note drop events
- * @param {Object} evt - Sortable drop event
+ * Initializes drag and drop functionality for notes using Sortable.js
  */
-async function handleNoteDrop(evt) {
-    const noteId = evt.item.dataset.noteId;
-    if (!noteId || noteId.startsWith('temp-')) {
-        console.warn('Attempted to drop a temporary or invalid note. Aborting.');
-        // Optionally revert drag UI immediately if needed
-        if (evt.from && evt.item.parentNode === evt.from) { // Check if it's still in the original container
-          evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
-        } else if (evt.item.parentNode) { // If it was moved, try to remove it
-          evt.item.parentNode.removeChild(evt.item);
+export function initializeDragAndDrop() {
+    if (typeof Sortable === 'undefined') return;
+
+    const containers = [domRefs.notesContainer, ...document.querySelectorAll('.note-children')];
+    containers.forEach(container => {
+        if (container && !container.classList.contains('ui-sortable')) {
+            Sortable.create(container, {
+                group: 'notes',
+                animation: 150,
+                handle: '.note-bullet',
+                ghostClass: 'note-ghost',
+                onEnd: handleNoteDrop
+            });
         }
-        return;
-    }
+    });
+}
 
-    const newContainer = evt.to;
-    const oldContainer = evt.from;
-    const newSortableIndex = evt.newDraggableIndex !== undefined ? evt.newDraggableIndex : evt.newIndex;
-    const oldSortableIndex = evt.oldDraggableIndex !== undefined ? evt.oldDraggableIndex : evt.oldIndex;
+/**
+ * Handles the logic after a note is dropped via drag-and-drop.
+ * @param {Object} evt - The event object from Sortable.js.
+ */
+export async function handleNoteDrop(evt) {
+    const noteId = evt.item.dataset.noteId;
+    const newParentEl = evt.to.closest('.note-item');
+    const newParentId = newParentEl ? newParentEl.dataset.noteId : null;
 
-    // Get the current note data to preserve content
-    const currentNoteData = window.notesForCurrentPage.find(n => String(n.id) === String(noteId));
-    if (!currentNoteData) {
-        console.error('Note data not found for ID:', noteId, 'in window.notesForCurrentPage. Aborting drop.');
-        // Revert the DOM change on error
-        if (oldContainer !== newContainer) {
-            oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex]);
-        } else {
-            if (oldSortableIndex < newSortableIndex) {
-                oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex]);
-            } else {
-                oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex + 1]);
-            }
-        }
+    if (newParentId === noteId || evt.item.contains(evt.to)) {
+        evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
         return;
     }
 
-    let newParentId = null;
-    if (newContainer.classList.contains('note-children')) {
-        const parentNoteItem = newContainer.closest('.note-item');
-        if (parentNoteItem) {
-            newParentId = parentNoteItem.dataset.noteId;
-            if (!newParentId || newParentId.startsWith('temp-')) {
-                console.error('Cannot drop note onto a temporary or invalid parent note.');
-                // Revert logic as above
-                 if (oldContainer !== newContainer) { oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex]); } else { if (oldSortableIndex < newSortableIndex) { oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex]); } else { oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex + 1]); } }
-                return;
-            }
-        }
-    }
-
-    // Determine logical previous and next siblings based on the item's final DOM position.
-    // This correctly uses the visual order from the DOM instead of relying on the
-    // data model's order (order_index), which can be out of sync during a drag-and-drop operation.
     const previousEl = evt.item.previousElementSibling;
-    const nextEl = evt.item.nextElementSibling;
-
-    let previousSiblingId = null;
-    if (previousEl && previousEl.classList.contains('note-item') && previousEl.dataset.noteId) {
-        previousSiblingId = previousEl.dataset.noteId;
-    }
-
-    let nextSiblingId = null;
-    if (nextEl && nextEl.classList.contains('note-item') && nextEl.dataset.noteId) {
-        nextSiblingId = nextEl.dataset.noteId;
-    }
-
-    const originalNotesState = JSON.parse(JSON.stringify(window.notesForCurrentPage)); // For revert
+    const previousSiblingId = previousEl?.classList.contains('note-item') ? previousEl.dataset.noteId : null;
 
     const { targetOrderIndex, siblingUpdates } = calculateOrderIndex(
         window.notesForCurrentPage,
         newParentId,
         previousSiblingId,
-        nextSiblingId
+        null
     );
     
-    console.log(`[HANDLE_NOTE_DROP] For Note ID: ${noteId}, New Parent ID: ${newParentId}, Prev Sib ID: ${previousSiblingId}, Next Sib ID: ${nextSiblingId}. Calculated: targetOrderIndex=${targetOrderIndex}, siblingUpdates:`, siblingUpdates);
-
-    // Optimistic local state updates
-    const noteToUpdate = window.notesForCurrentPage.find(n => String(n.id) === String(noteId));
-    if (noteToUpdate) {
-        noteToUpdate.parent_note_id = newParentId;
-        noteToUpdate.order_index = targetOrderIndex;
-    } else {
-        console.error(`[HANDLE_NOTE_DROP] Dropped note with ID ${noteId} not found in local cache for optimistic update.`);
-        // Revert and bail, something is wrong.
-        window.notesForCurrentPage = originalNotesState;
-        window.ui.displayNotes(window.notesForCurrentPage, window.currentPageId); // Re-render
-        return;
-    }
-
-    siblingUpdates.forEach(update => {
-        const siblingNote = window.notesForCurrentPage.find(n => String(n.id) === String(update.id));
-        if (siblingNote) {
-            siblingNote.order_index = update.newOrderIndex;
-        } else {
-            console.warn(`[HANDLE_NOTE_DROP] Sibling note with ID ${update.id} for order_index update not found in local cache.`);
-        }
-    });
-    window.notesForCurrentPage.sort((a, b) => a.order_index - b.order_index);
-
-    // Prepare API calls
-    const apiPromises = [];
-    const droppedNotePayload = {
-        page_id: window.currentPageId,
-        // content: currentNoteData.content || '', // Content is not changed on drop
-        parent_note_id: newParentId,
-        order_index: targetOrderIndex
-    };
-    apiPromises.push(window.notesAPI.updateNote(noteId, droppedNotePayload));
-
-    siblingUpdates.forEach(update => {
-        apiPromises.push(window.notesAPI.updateNote(update.id, {
-            order_index: update.newOrderIndex,
-            page_id: window.currentPageId
-            // parent_note_id is not changed for siblings
-        }));
+    // Create a list of all operations needed for the batch update.
+    const operations = [
+        { type: 'update', payload: { id: noteId, parent_note_id: newParentId, order_index: targetOrderIndex } },
+        ...siblingUpdates.map(upd => ({ type: 'update', payload: { id: upd.id, order_index: upd.newOrderIndex } }))
+    ];
+    
+    // Optimistically update local state before calling API
+    const noteToMove = window.notesForCurrentPage.find(n => n.id == noteId);
+    if(noteToMove) {
+        noteToMove.parent_note_id = newParentId;
+        noteToMove.order_index = targetOrderIndex;
+    }
+    siblingUpdates.forEach(upd => {
+        const sib = window.notesForCurrentPage.find(n => n.id == upd.id);
+        if(sib) sib.order_index = upd.newOrderIndex;
     });
 
     try {
-        const results = await Promise.allSettled(apiPromises);
-        console.log('[HANDLE_NOTE_DROP] API call results:', results);
-
-        let isError = false;
-        results.forEach(result => {
-            if (result.status === 'rejected') {
-                isError = true;
-                console.error(`[HANDLE_NOTE_DROP] Failed API operation:`, result.reason);
-            } else if (result.status === 'fulfilled') {
-                // Sync successful updates back to local state (e.g., updated_at, server-confirmed order_index)
-                const updatedNoteFromServer = result.value;
-                const localNoteIndex = window.notesForCurrentPage.findIndex(n => String(n.id) === String(updatedNoteFromServer.id));
-                if (localNoteIndex > -1) {
-                    window.notesForCurrentPage[localNoteIndex] = {
-                        ...window.notesForCurrentPage[localNoteIndex], // Preserve local properties like 'children'
-                        ...updatedNoteFromServer // Apply server updates
-                    };
-                }
-            }
-        });
-
-        if (isError) {
-            throw new Error('One or more note updates failed during drag and drop.');
-        }
-        
-        // Final sort after successful server updates
-        window.notesForCurrentPage.sort((a, b) => a.order_index - b.order_index);
-
-        // DOM is already updated by SortableJS.
-        // Update visual properties for the moved item and parents.
-        const movedNoteElement = evt.item;
-        const newParentNoteElement = newContainer.closest('.note-item');
-        const newNestingLevel = newParentId ? ui.getNestingLevel(newParentNoteElement) + 1 : 0;
-        movedNoteElement.style.setProperty('--nesting-level', newNestingLevel);
-        
-        const oldParentEl = oldContainer.closest('.note-item');
-        const newParentEl = newContainer.closest('.note-item');
-
-        if (oldParentEl) {
-            ui.updateParentVisuals(oldParentEl);
-            if (oldContainer.classList.contains('note-children') && oldContainer.children.length === 0) {
-                oldContainer.remove();
-                oldParentEl.classList.remove('has-children');
-            }
-        }
-        if (newParentEl && newParentEl !== oldParentEl) {
-            ui.updateParentVisuals(newParentEl);
-        } else if (!newParentEl && newContainer === domRefs.notesContainer) {
-            // Handled by oldParentEl logic if it exists
-        }
-        
-        console.log(`[HANDLE_NOTE_DROP] Successfully processed drop for note ${noteId}.`);
-
-    } catch (error) { // Catches errors from Promise.allSettled block or if isError was true
-        console.error('[HANDLE_NOTE_DROP] Error processing note drop, attempting to revert:', error);
-        
-        // Revert local state
-        window.notesForCurrentPage = originalNotesState;
-        
-        // Show user-friendly error message
-        const feedback = document.createElement('div');
-        feedback.className = 'copy-feedback error-feedback'; 
-        feedback.style.background = 'var(--color-error, #dc2626)';
-        feedback.textContent = `Failed to save position: ${error.message || 'Unknown error'}`;
-        document.body.appendChild(feedback);
-        setTimeout(() => feedback.remove(), 3000);
-
-        // Re-render the entire notes list from the reverted state
-        // This effectively reverts DOM changes made by SortableJS as well.
-        if (window.ui && typeof window.ui.displayNotes === 'function') {
-            window.ui.displayNotes(window.notesForCurrentPage, window.currentPageId);
-        } else {
-            console.warn("[HANDLE_NOTE_DROP] ui.displayNotes not available for error recovery. UI might be inconsistent.");
-            // Fallback DOM revert (might not be perfect if SortableJS made complex changes)
-            if (oldContainer !== newContainer) {
-                oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex]);
-            } else {
-                if (oldSortableIndex < newSortableIndex) {
-                    oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex]);
-                } else {
-                    oldContainer.insertBefore(evt.item, oldContainer.children[oldSortableIndex + 1]);
-                }
-            }
-        }
-    }
-}
-
-/**
- * Initializes drag and drop functionality for notes
- */
-function initializeDragAndDrop() {
-    if (typeof Sortable === 'undefined') {
-        console.warn('Sortable.js not loaded, drag and drop disabled');
-        return;
+        await window.notesAPI.batchUpdateNotes(operations);
+        // On success, we can just do a light DOM update if needed, but a reload is safest.
+        await window.loadPage(window.currentPageName, false, false); // Reload without adding to history
+    } catch (error) {
+        console.error("Failed to save note drop changes:", error);
+        alert("Could not save new note positions. Reverting.");
+        await window.loadPage(window.currentPageName, false, false);
     }
-
-    // Track drag state to prevent interference
-    window.isDragInProgress = false;
-
-    // Initialize sortable for the main notes container
-    const notesContainer = domRefs.notesContainer;
-    if (notesContainer) {
-        Sortable.create(notesContainer, {
-            group: 'notes',
-            animation: 150,
-            handle: '.note-bullet',
-            ghostClass: 'note-ghost',
-            chosenClass: 'note-chosen',
-            dragClass: 'note-drag',
-            onStart: function(evt) {
-                window.isDragInProgress = true;
-            },
-            onEnd: async function(evt) {
-                try {
-                    await handleNoteDrop(evt);
-                } finally {
-                    setTimeout(() => {
-                        window.isDragInProgress = false;
-                    }, 500); // Keep the flag for a bit longer to prevent interference
-                }
-            }
-        });
-    }
-
-    // Initialize sortable for all children containers
-    const childrenContainers = document.querySelectorAll('.note-children');
-    childrenContainers.forEach(container => {
-        // Check if sortable already initialized
-        if (container.classList.contains('ui-sortable')) { // Sortable.js adds 'ui-sortable' class
-            return;
-        }
-        Sortable.create(container, {
-            group: 'notes',
-            animation: 150,
-            handle: '.note-bullet',
-            ghostClass: 'note-ghost',
-            chosenClass: 'note-chosen',
-            dragClass: 'note-drag',
-            onStart: function(evt) {
-                window.isDragInProgress = true;
-            },
-            onEnd: async function(evt) {
-                try {
-                    await handleNoteDrop(evt);
-                } finally {
-                    setTimeout(() => {
-                        window.isDragInProgress = false;
-                    }, 500); // Keep the flag for a bit longer to prevent interference
-                }
-            }
-        });
-    });
 }
 
 
-export {
-    displayNotes,
-    updateNoteElement,
-    addNoteElement,
-    removeNoteElement,
-    moveNoteElement,
-    buildNoteTree,
-    initializeDragAndDrop,
-    handleNoteDrop // Exporting if it's needed by other modules, though current plan is internal use.
-};
+// These functions are not used by other modules and can be kept internal to this file or moved if needed.
+function updateNoteElement() { /* placeholder if needed */ }
+function moveNoteElement() { /* placeholder if needed */ }
\ No newline at end of file
diff --git a/assets/js/ui/note-renderer.js b/assets/js/ui/note-renderer.js
index 5966dc2..637cb3d 100644
--- a/assets/js/ui/note-renderer.js
+++ b/assets/js/ui/note-renderer.js
@@ -793,7 +793,7 @@ function parseAndRenderContent(rawContent) {
         const sqlQueryRegex = /SQL\{([^}]+)\}/g;
         html = html.replace(sqlQueryRegex, (match, sqlQuery) => {
             // Ensure quotes within the SQL query are properly escaped for the HTML attribute
-            const escapedSqlQuery = sqlQuery.replace(/"/g, '&quot;');
+            const escapedSqlQuery = sqlQuery.replace(/"/g, '"');
             return `<div class="sql-query-placeholder" data-sql-query="${escapedSqlQuery}">Loading SQL Query...</div>`;
         });
 
@@ -1016,6 +1016,36 @@ export {
 
 // --- Delegated Event Handler Functions ---
 
+/**
+ * Opens a modal to display an image.
+ * @param {string} imageUrl The URL of the image to display.
+ */
+function openImageViewerModal(imageUrl) {
+    if (!imageUrl) return;
+
+    if (domRefs.imageViewerModal && domRefs.imageViewerModalImg && domRefs.imageViewerModalClose) {
+        domRefs.imageViewerModalImg.src = imageUrl;
+        domRefs.imageViewerModal.classList.add('active');
+
+        const closeImageModal = () => {
+            domRefs.imageViewerModal.classList.remove('active');
+            domRefs.imageViewerModalImg.src = '';
+        };
+
+        const outsideClickHandlerForModal = (event) => {
+            if (event.target === domRefs.imageViewerModal) {
+                closeImageModal();
+            }
+        };
+
+        domRefs.imageViewerModalClose.addEventListener('click', closeImageModal, { once: true });
+        domRefs.imageViewerModal.addEventListener('click', outsideClickHandlerForModal, { once: true });
+    } else {
+        console.error('Image viewer modal elements not found.');
+        window.open(imageUrl, '_blank');
+    }
+}
+
 async function handleDelegatedCollapseArrowClick(targetElement) {
     const noteItem = targetElement.closest('.note-item');
     const noteId = noteItem?.dataset.noteId;
@@ -1234,40 +1264,101 @@ async function handleDelegatedAttachmentDelete(targetElement) {
 }
 
 function handleDelegatedAttachmentImageView(targetElement) {
-    const attachmentUrl = targetElement.dataset.attachmentUrl;
-    if (!attachmentUrl) { // Might be the img itself, not the link
+    let attachmentUrl = targetElement.dataset.attachmentUrl;
+    if (!attachmentUrl) {
+        // This logic handles clicking the <img> preview instead of the <a> link.
         const imgPreview = targetElement.closest('.attachment-preview-image');
         if (imgPreview) {
            const attachmentItem = imgPreview.closest('.note-attachment-item');
+           // Find the sibling link that holds the data
            const linkElement = attachmentItem?.querySelector('.attachment-name[data-attachment-url]');
-           if(linkElement) handleDelegatedAttachmentImageView(linkElement); // Recurse with the link
+           if (linkElement) {
+               attachmentUrl = linkElement.dataset.attachmentUrl;
+           }
         }
-        return;
     }
 
+    if (attachmentUrl) {
+        openImageViewerModal(attachmentUrl);
+    }
+}
 
-    if (domRefs.imageViewerModal && domRefs.imageViewerModalImg && domRefs.imageViewerModalClose) {
-        domRefs.imageViewerModalImg.src = attachmentUrl;
-        domRefs.imageViewerModal.classList.add('active');
+async function handleDelegatedTaskCheckboxClick(checkbox) {
+    const noteItem = checkbox.closest('.note-item');
+    const contentEl = noteItem?.querySelector('.note-content');
+    if (!noteItem || !contentEl) return;
 
-        const closeImageModal = () => {
-            domRefs.imageViewerModal.classList.remove('active');
-            domRefs.imageViewerModalImg.src = ''; 
-            domRefs.imageViewerModalClose.removeEventListener('click', closeImageModal);
-            domRefs.imageViewerModal.removeEventListener('click', outsideClickHandlerForModal);
-        };
+    const noteId = noteItem.dataset.noteId;
+    if (!noteId || noteId.startsWith('temp-')) return;
+    
+    let rawContent = contentEl.dataset.rawContent;
+    const currentMarker = checkbox.dataset.markerType.toUpperCase();
+    let newContent;
+    let newMarker;
 
-        const outsideClickHandlerForModal = (event) => {
-            if (event.target === domRefs.imageViewerModal) { 
-                closeImageModal();
-            }
-        };
+    // Logic based on current state and the new checked status of the box
+    const isChecked = checkbox.checked;
 
-        domRefs.imageViewerModalClose.addEventListener('click', closeImageModal, { once: true });
-        domRefs.imageViewerModal.addEventListener('click', outsideClickHandlerForModal, { once: true });
-    } else {
-        console.error('Image viewer modal elements not found.');
-        window.open(attachmentUrl, '_blank');
+    if (isChecked) { // The user is checking the box (moving to a "done" state)
+        if (['TODO', 'DOING', 'WAITING', 'SOMEDAY'].includes(currentMarker)) {
+            newMarker = 'DONE';
+        }
+    } else { // The user is un-checking the box (moving to an "active" state)
+        if (currentMarker === 'DONE') {
+            newMarker = 'TODO';
+        }
+    }
+    
+    // If no state change is defined, or for un-clickable types, revert the checkbox and exit
+    if (!newMarker) {
+        checkbox.checked = !isChecked; // Revert visual change
+        return;
+    }
+
+    // Find the original content part by stripping the old marker
+    let contentPart = '';
+    const prefixes = ['TODO ', 'DONE ', 'DOING ', 'SOMEDAY ', 'WAITING ', 'CANCELLED ', 'NLR '];
+    for (const prefix of prefixes) {
+        if (rawContent.startsWith(prefix)) {
+            contentPart = rawContent.substring(prefix.length);
+            break;
+        }
+    }
+    // Fallback if no prefix found
+    if (contentPart === '' && rawContent.includes(' ')) {
+        contentPart = rawContent.substring(rawContent.indexOf(' ') + 1);
+    } else if (contentPart === '') {
+        contentPart = rawContent;
+    }
+
+    newContent = `${newMarker} ${contentPart}`;
+    
+    // Update the raw content dataset for the next save
+    contentEl.dataset.rawContent = newContent;
+    
+    // The visual state of the checkbox is already correct from the user click.
+    // Now, update the rest of the UI optimistically.
+    const taskContainer = checkbox.closest('.task-container');
+    if (taskContainer) {
+        taskContainer.classList.remove(currentMarker.toLowerCase());
+        taskContainer.classList.add(newMarker.toLowerCase());
+        
+        const badge = taskContainer.querySelector('.task-status-badge');
+        badge.className = `task-status-badge ${newMarker.toLowerCase()}`;
+        badge.textContent = newMarker;
+
+        const taskContentDiv = taskContainer.querySelector('.task-content');
+        taskContentDiv.classList.toggle('done-text', newMarker === 'DONE');
+        
+        checkbox.dataset.markerType = newMarker;
+    }
+
+    // Save the change
+    try {
+        await saveNoteImmediately(noteItem);
+    } catch (error) {
+        console.error(`Error saving task state for note ${noteId}:`, error);
+        alert('Failed to save the task state change. Please refresh the page.');
     }
 }
 
@@ -1302,6 +1393,14 @@ function initializeDelegatedNoteEventListeners(notesContainerEl) {
             return;
         }
 
+        // Task checkbox click
+        const checkbox = target.closest('.task-checkbox');
+        if (checkbox) {
+            event.stopPropagation();
+            handleDelegatedTaskCheckboxClick(checkbox);
+            return;
+        }
+
         // Content click to edit
         const contentArea = target.closest('.note-content.rendered-mode');
         if (contentArea) {
@@ -1317,24 +1416,22 @@ function initializeDelegatedNoteEventListeners(notesContainerEl) {
             return;
         }
 
+        // Markdown-embedded content image click
+        const contentImage = target.closest('.content-image');
+        if (contentImage) {
+            event.preventDefault();
+            const imageUrl = contentImage.dataset.originalSrc;
+            openImageViewerModal(imageUrl);
+            return;
+        }
+
         // Attachment image view (delegated from .attachment-name or .attachment-preview-image)
-        const imageLink = target.closest('.attachment-name.delegated-attachment-image');
+        const imageLink = target.closest('.attachment-name.delegated-attachment-image, .attachment-preview-image');
         if (imageLink) {
             event.preventDefault();
             handleDelegatedAttachmentImageView(imageLink);
             return;
         }
-        const imagePreview = target.closest('.attachment-preview-image');
-        if(imagePreview){
-            // The preview itself might not have the URL, find the associated link
-            const attachmentItem = imagePreview.closest('.note-attachment-item');
-            const actualLink = attachmentItem?.querySelector('.attachment-name.delegated-attachment-image');
-            if(actualLink) {
-                 event.preventDefault();
-                 handleDelegatedAttachmentImageView(actualLink);
-            }
-            return;
-        }
     });
 
     notesContainerEl.addEventListener('contextmenu', (event) => {
@@ -1347,4 +1444,4 @@ function initializeDelegatedNoteEventListeners(notesContainerEl) {
     });
 
     console.log("Delegated note event listeners initialized.");
-}
+}
\ No newline at end of file
diff --git a/assets/js/utils.js b/assets/js/utils.js
index ab37f94..a1b4051 100644
--- a/assets/js/utils.js
+++ b/assets/js/utils.js
@@ -151,7 +151,6 @@ function parseContentForDisplay(content) {
 // but ensure ES6 exports are primary for consistency in this project.
 if (typeof module !== 'undefined' && module.exports) {
     module.exports = {
-        debounce, // This will now export the already ES6-exported function
         generateTempId,
         uuidv4,
         escapeHTML,
@@ -178,4 +177,101 @@ export function safeAddEventListener(element, event, handler, elementName) {
         return;
     }
     element.addEventListener(event, handler);
+}
+
+/**
+ * Inserts text at the current cursor position in a contentEditable element.
+ * @param {string} text - The text to insert.
+ * @param {number} [cursorOffset=0] - The offset from the end of the inserted text where the cursor should be placed.
+ * @returns {boolean} True if text was inserted, false otherwise.
+ */
+export function insertTextAtCursor(text, cursorOffset = 0) {
+    const selection = window.getSelection();
+    if (!selection || selection.rangeCount === 0) return false;
+
+    const range = selection.getRangeAt(0);
+    range.deleteContents(); // Delete any selected content
+
+    const textNode = document.createTextNode(text);
+    range.insertNode(textNode);
+
+    // Set cursor position after insertion
+    const newRange = document.createRange();
+    newRange.setStart(textNode, text.length - cursorOffset);
+    newRange.setEnd(textNode, text.length - cursorOffset);
+    selection.removeAllRanges();
+    selection.addRange(newRange);
+    
+    return true;
+}
+
+/**
+ * Handles auto-closing of brackets/parentheses/braces.
+ * @param {Event} e - The keyboard event.
+ * @returns {boolean} True if a bracket was auto-closed, false otherwise.
+ */
+export function handleAutocloseBrackets(e) {
+    let handled = false;
+    const selection = window.getSelection();
+    if (!selection || !selection.rangeCount) return false;
+    const range = selection.getRangeAt(0);
+    const editor = e.target; // contentEditable div
+
+    const keyActionMap = { '[': '[]', '{': '{}', '(': '()' };
+
+    if (keyActionMap[e.key]) {
+        const textToInsert = keyActionMap[e.key];
+        let cursorOffset = 1;
+
+        e.preventDefault();
+        insertTextAtCursor(textToInsert, cursorOffset);
+        handled = true;
+    }
+
+    if (handled) {
+        // Dispatch an input event so note-renderer's listeners (like for page link suggestions) are triggered
+        editor.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
+    }
+    return handled;
+}
+
+/**
+ * Encrypts a string using SJCL with AES-256-CCM.
+ * @param {string} text - The plaintext to encrypt.
+ * @param {string} password - The password to use for encryption.
+ * @returns {string} The encrypted ciphertext as a JSON string.
+ */
+export function encrypt(text, password) {
+    if (!text || !password) return '';
+    try {
+        const encrypted = sjcl.encrypt(password, text, {
+            ks: 256,
+            ts: 128,
+            mode: 'ccm',
+            iter: 1000
+        });
+        return encrypted; // This is a JSON string
+    } catch (e) {
+        console.error("Encryption failed:", e);
+        return '';
+    }
+}
+
+/**
+ * Decrypts a string using SJCL.
+ * @param {string} encryptedJson - The encrypted JSON string.
+ * @param {string} password - The password to use for decryption.
+ * @returns {string} The decrypted plaintext.
+ */
+export function decrypt(encryptedJson, password) {
+    if (!encryptedJson || !password) return '';
+    try {
+        const decrypted = sjcl.decrypt(password, encryptedJson);
+        return decrypted;
+    } catch (e) {
+        // It's common for this to fail with a wrong password, so we can use console.warn
+        // to avoid flooding the console with errors during normal use.
+        console.warn("Decryption failed. This might be due to a wrong password.");
+        return null; // Return null to indicate failure
+    }
 }
\ No newline at end of file
diff --git a/config.php b/config.php
index 3052136..3bc5cb9 100644
--- a/config.php
+++ b/config.php
@@ -1,76 +1,117 @@
 <?php
-if (!defined('DB_PATH')) { define('DB_PATH', __DIR__ . '/db/database.sqlite'); }
-if (!defined('UPLOADS_DIR')) { define('UPLOADS_DIR', __DIR__ . '/uploads'); }
+
+// --- Core Paths and URLs ---
+if (!defined('DB_PATH')) {
+    define('DB_PATH', __DIR__ . '/db/database.sqlite');
+}
+if (!defined('UPLOADS_DIR')) {
+    define('UPLOADS_DIR', __DIR__ . '/uploads');
+}
 if (!defined('APP_BASE_URL')) {
-    define('APP_BASE_URL', ''); // Set this if your app is in a subdirectory, e.g., /notetaker
+    // Set this if your app is in a subdirectory, e.g., /notetaker
+    // For a root domain, leave it empty.
+    define('APP_BASE_URL', '');
 }
 
-define('ACTIVE_THEME', 'flatly'); // Defines the active theme file (e.g., 'default' for 'default.css')
-define('WEBHOOKS_ENABLED', true); // Option to disable webhooks
+// --- Application Features ---
+define('ACTIVE_THEME', 'flatly'); // Defines the active theme CSS file.
+define('WEBHOOKS_ENABLED', true); // Master switch to enable or disable all webhook dispatches.
 define('ACTIVE_EXTENSIONS', ['attachment_dashboard', 'pomodoro_timer', 'kanban_board']);
-define('TASK_STATES', ['TODO', 'DOING', 'DONE', 'SOMEDAY', 'WAITING']);
+define('TASK_STATES', ['TODO', 'DOING', 'DONE', 'SOMEDAY', 'WAITING', 'CANCELLED']); // Allowed task states for the task status parser.
 
-// Property Visibility Configuration
-if (!defined('RENDER_INTERNAL_PROPERTIES')) {
-    define('RENDER_INTERNAL_PROPERTIES', false); // Default: true (internal properties are rendered)
-}
-if (!defined('SHOW_INTERNAL_PROPERTIES_IN_EDIT_MODE')) {
-    define('SHOW_INTERNAL_PROPERTIES_IN_EDIT_MODE', true); // Default: true (internal properties are visible as text in edit mode)
-}
+// --- Property System Configuration ---
+// This array defines the behavior of properties based on their 'weight', which
+// is determined by the number of colons used in the property syntax.
+// This configuration is primarily interpreted by the FRONTEND to control rendering.
+// The backend uses 'update_behavior' to manage how the Properties table is updated.
+define('PROPERTY_WEIGHTS', [
+    // Default Public Property (e.g., {key::value})
+    2 => [
+        'label' => 'Public',
+        'description' => 'Standard properties visible in all views.',
+        'update_behavior' => 'replace', // On update, the old value in the DB is replaced with the new one.
+        'visible_in_view_mode' => true,   // Frontend should show this in read-only views.
+        'visible_in_edit_mode' => true    // Frontend should show this in editable views.
+    ],
+    // Internal Property (e.g., {key:::value})
+    3 => [
+        'label' => 'Internal',
+        'description' => 'Properties for internal logic, hidden by default.',
+        'update_behavior' => 'replace', // Replace the value on update.
+        'visible_in_view_mode' => true,  // Changed from false to true
+        'visible_in_edit_mode' => true    // Frontend should SHOW this in editable views.
+    ],
+    // System/Log Property (e.g., {key::::value})
+    4 => [
+        'label' => 'System Log',
+        'description' => 'Properties that act as an immutable log or history.',
+        'update_behavior' => 'append',  // On update, a NEW row is added to the DB, preserving the old one.
+        'visible_in_view_mode' => false,  // Frontend should HIDE this in read-only views.
+        'visible_in_edit_mode' => false   // Frontend should HIDE this in editable views.
+    ]
+    // You can add more weights here, e.g., weight 5 for "Archived" properties.
+]);
 
-// Error reporting (for development)
+// --- Development and Debugging ---
+// WARNING: Do not use these settings in a production environment.
 ini_set('display_errors', 1); // Enable error display
 ini_set('display_startup_errors', 1); // Enable startup error display
-error_reporting(E_ALL); // Log all errors
+error_reporting(E_ALL); // Report all PHP errors
+
+// --- Timezone ---
+// Set a consistent timezone to avoid issues with DATETIME functions.
+date_default_timezone_set('UTC');
 
-// Timezone
-date_default_timezone_set('UTC'); // Or your preferred timezone
+// --- Global Error and Exception Handling ---
+// These handlers ensure that if a fatal error occurs, the API returns a
+// structured JSON error response instead of a blank page or HTML error dump.
 
-// Set error handler to return JSON responses
+// Set custom error handler
 set_error_handler(function($errno, $errstr, $errfile, $errline) {
+    // Respect the error_reporting level.
     if (!(error_reporting() & $errno)) {
-        // This error code is not included in error_reporting
         return false;
     }
-    
-    // Only handle errors if headers haven't been sent yet
+
+    // Only handle errors if headers haven't been sent yet.
     if (!headers_sent()) {
-        header('Content-Type: application/json', true, 500);
+        http_response_code(500);
+        header('Content-Type: application/json');
         echo json_encode([
-            'success' => false,
-            'error' => 'Internal Server Error',
+            'status' => 'error',
+            'message' => 'An internal server error occurred.',
             'details' => [
+                'type' => 'PHP Error',
                 'message' => $errstr,
                 'file' => $errfile,
-                'line' => $errline,
-                'type' => 'error',
-                'errno' => $errno
+                'line' => $errline
             ]
         ]);
     } else {
-        // Log the error if we can't send JSON
+        // Log the error if we can't send JSON.
         error_log("PHP Error: [$errno] $errstr in $errfile on line $errline");
     }
     exit(1);
 });
 
-// Set exception handler to return JSON responses
+// Set custom exception handler
 set_exception_handler(function($e) {
     if (!headers_sent()) {
-        header('Content-Type: application/json', true, 500);
+        http_response_code(500);
+        header('Content-Type: application/json');
         echo json_encode([
-            'success' => false,
-            'error' => 'Internal Server Error',
+            'status' => 'error',
+            'message' => 'An uncaught exception occurred.',
             'details' => [
+                'type' => get_class($e),
                 'message' => $e->getMessage(),
                 'file' => $e->getFile(),
                 'line' => $e->getLine(),
-                'type' => 'exception',
-                'trace' => $e->getTraceAsString()
+                'trace' => explode("\n", $e->getTraceAsString()) // More JSON-friendly trace
             ]
         ]);
     } else {
-        // Log the exception if we can't send JSON
+        // Log the exception if we can't send JSON.
         error_log("Uncaught Exception: " . $e->getMessage() . " in " . $e->getFile() . " on line " . $e->getLine());
     }
     exit(1);
diff --git a/db/schema.sql b/db/schema.sql
index 86b03cf..ba44582 100644
--- a/db/schema.sql
+++ b/db/schema.sql
@@ -1,18 +1,30 @@
--- Enable Foreign Key support
+-- Notd Database Schema
+-- Version: 2.0 (Content-first Property Model)
+--
+-- This schema implements a "content-first" architecture where the `content`
+-- field of a Note or Page is the single source of truth for its properties.
+-- The `Properties` table serves as a queryable index of the properties
+-- parsed from the content.
+
+-- Enable Foreign Key support for data integrity
 PRAGMA foreign_keys = ON;
 
 -- Pages Table
+-- Pages are top-level containers for notes. They now include a `content`
+-- field to store page-level properties and other metadata.
 CREATE TABLE IF NOT EXISTS Pages (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     name TEXT UNIQUE NOT NULL,
+    content TEXT, -- Content for the page itself, used for page-level properties
     alias TEXT,
-    active INTEGER NOT NULL DEFAULT 1, -- 1 for active, 0 for inactive/historical
+    active INTEGER NOT NULL DEFAULT 1,
     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
 );
-CREATE INDEX IF NOT EXISTS idx_pages_name ON Pages(name);
+CREATE INDEX IF NOT EXISTS idx_pages_name ON Pages(LOWER(name));
 
 -- Notes Table
+-- Notes are the core content blocks, belonging to a single page.
 CREATE TABLE IF NOT EXISTS Notes (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     page_id INTEGER NOT NULL,
@@ -20,8 +32,7 @@ CREATE TABLE IF NOT EXISTS Notes (
     content TEXT,
     order_index INTEGER NOT NULL DEFAULT 0,
     collapsed INTEGER NOT NULL DEFAULT 0,
-    internal INTEGER NOT NULL DEFAULT 0,
-    active INTEGER NOT NULL DEFAULT 1, -- 1 for active, 0 for inactive/historical
+    active INTEGER NOT NULL DEFAULT 1,
     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
     FOREIGN KEY (page_id) REFERENCES Pages(id) ON DELETE CASCADE,
@@ -31,6 +42,7 @@ CREATE INDEX IF NOT EXISTS idx_notes_page_id ON Notes(page_id);
 CREATE INDEX IF NOT EXISTS idx_notes_parent_note_id ON Notes(parent_note_id);
 
 -- Attachments Table
+-- Stores file attachments linked to notes.
 CREATE TABLE IF NOT EXISTS Attachments (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     note_id INTEGER,
@@ -44,14 +56,16 @@ CREATE TABLE IF NOT EXISTS Attachments (
 CREATE INDEX IF NOT EXISTS idx_attachments_note_id ON Attachments(note_id);
 
 -- Properties Table
+-- This table is an INDEX of properties parsed from Note and Page content.
+-- It is managed by the backend and should not be written to directly.
 CREATE TABLE IF NOT EXISTS Properties (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     note_id INTEGER,
     page_id INTEGER,
     name TEXT NOT NULL,
     value TEXT,
-    internal INTEGER NOT NULL DEFAULT 0,
-    active INTEGER NOT NULL DEFAULT 1, -- 1 for active, 0 for inactive/historical
+    weight INTEGER NOT NULL DEFAULT 2, -- Derived from the number of colons (e.g., '::' -> 2, ':::' -> 3)
+    active INTEGER NOT NULL DEFAULT 1,
     created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
     updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
     FOREIGN KEY (note_id) REFERENCES Notes(id) ON DELETE CASCADE,
@@ -62,26 +76,13 @@ CREATE TABLE IF NOT EXISTS Properties (
     )
 );
 
--- Indexes for performance
+-- Indexes for performance on the Properties table
 CREATE INDEX IF NOT EXISTS idx_properties_note_id_name ON Properties(note_id, name);
 CREATE INDEX IF NOT EXISTS idx_properties_page_id_name ON Properties(page_id, name);
 CREATE INDEX IF NOT EXISTS idx_properties_name_value ON Properties(name, value);
+CREATE INDEX IF NOT EXISTS idx_properties_weight ON Properties(weight); -- New index for querying by weight
 
--- Property Definitions Table
--- This table defines which property names should be treated as internal
-CREATE TABLE IF NOT EXISTS PropertyDefinitions (
-    id INTEGER PRIMARY KEY AUTOINCREMENT,
-    name TEXT NOT NULL UNIQUE,
-    internal INTEGER NOT NULL DEFAULT 0,
-    description TEXT,
-    auto_apply INTEGER NOT NULL DEFAULT 1, -- Whether to auto-apply to existing properties
-    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
-    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
-);
-CREATE INDEX IF NOT EXISTS idx_property_definitions_name ON PropertyDefinitions(name);
-CREATE INDEX IF NOT EXISTS idx_property_definitions_internal ON PropertyDefinitions(internal);
-
--- Triggers for updated_at (optional, can be handled by PHP)
+-- Triggers to automatically update `updated_at` timestamps
 CREATE TRIGGER IF NOT EXISTS update_pages_updated_at
 AFTER UPDATE ON Pages FOR EACH ROW
 BEGIN
@@ -94,28 +95,15 @@ BEGIN
     UPDATE Properties SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
 END;
 
-CREATE TRIGGER IF NOT EXISTS update_property_definitions_updated_at
-AFTER UPDATE ON PropertyDefinitions FOR EACH ROW
-BEGIN
-    UPDATE PropertyDefinitions SET updated_at = CURRENT_TIMESTAMP WHERE id = OLD.id;
-END;
-
--- Insert default property definitions
-INSERT OR IGNORE INTO PropertyDefinitions (name, internal, description, auto_apply) VALUES
-('internal', 1, 'Properties that control note/page visibility', 1),
-('debug', 1, 'Debug and development properties', 1),
-('system', 1, 'System-generated properties', 1),
-('_private', 1, 'Private properties (underscore prefix)', 1),
-('metadata', 1, 'Metadata properties for internal use', 1);
-
 -- Webhooks Table
+-- Manages webhook subscriptions for real-time event notifications.
 CREATE TABLE IF NOT EXISTS Webhooks (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     url TEXT NOT NULL,
     secret TEXT NOT NULL,
     entity_type TEXT NOT NULL, -- 'note' or 'page'
     property_names TEXT NOT NULL, -- JSON array of property names or "*" for all properties
-    event_types TEXT NOT NULL DEFAULT '["property_change"]', -- JSON array of event types to trigger on
+    event_types TEXT NOT NULL DEFAULT '["property_change"]', -- JSON array of event types
     active INTEGER NOT NULL DEFAULT 1,
     verified INTEGER NOT NULL DEFAULT 0,
     last_verified DATETIME,
@@ -126,10 +114,11 @@ CREATE TABLE IF NOT EXISTS Webhooks (
 CREATE INDEX IF NOT EXISTS idx_webhooks_lookup ON Webhooks(entity_type, active);
 
 -- Webhook Events Log Table
+-- Logs all outgoing webhook attempts and their results.
 CREATE TABLE IF NOT EXISTS WebhookEvents (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     webhook_id INTEGER NOT NULL,
-    event_type TEXT NOT NULL, -- 'property_change', 'test', 'verification'
+    event_type TEXT NOT NULL, -- e.g., 'property_change', 'test', 'verification'
     payload TEXT,
     response_code INTEGER,
     response_body TEXT,
diff --git a/db/setup_db.php b/db/setup_db.php
index 4e1ce40..ff4359e 100644
--- a/db/setup_db.php
+++ b/db/setup_db.php
@@ -8,7 +8,7 @@ if (!function_exists('log_setup_local')) {
 }
 
 /**
- * Runs the entire database schema and initial data setup.
+ * Runs the entire database schema setup.
  * This function requires a valid PDO connection to be passed to it.
  *
  * @param PDO $pdo The database connection object.
@@ -21,31 +21,13 @@ function run_database_setup(PDO $pdo) {
             throw new Exception("Could not read schema.sql file.");
         }
 
-        log_setup_local("Applying database schema...");
+        log_setup_local("Applying database schema from schema.sql...");
         
         $pdo->beginTransaction();
         try {
-            // Remove comments and execute statements one by one.
-            $schemaSql = preg_replace('/--.*$/m', '', $schemaSql);
-            $triggers = [];
-            $schemaWithoutTriggers = preg_replace_callback(
-                '/(CREATE TRIGGER.*?END;)/si',
-                function($matches) use (&$triggers) {
-                    $triggers[] = trim($matches[0]);
-                    return ''; // Remove trigger from main SQL string
-                },
-                $schemaSql
-            );
-            $statements = explode(';', $schemaWithoutTriggers);
-            
-            foreach ($statements as $statement) {
-                if (!empty(trim($statement))) {
-                    $pdo->exec($statement);
-                }
-            }
-            foreach ($triggers as $trigger) {
-                $pdo->exec($trigger);
-            }
+            // The 'exec' command can handle multiple statements separated by semicolons.
+            // This is simpler and more robust for applying a full schema.
+            $pdo->exec($schemaSql);
             
             $pdo->commit();
             log_setup_local("Database schema applied successfully.");
@@ -54,30 +36,6 @@ function run_database_setup(PDO $pdo) {
             log_setup_local("Database setup failed during schema application: " . $e->getMessage());
             throw $e;
         }
-
-        // Apply property definitions to existing properties
-        log_setup_local("Applying property definitions to existing properties...");
-        $stmt = $pdo->prepare("SELECT name, internal FROM PropertyDefinitions WHERE auto_apply = 1");
-        $stmt->execute();
-        $definitions = $stmt->fetchAll(PDO::FETCH_ASSOC);
-        
-        $totalUpdated = 0;
-        foreach ($definitions as $definition) {
-            $updateStmt = $pdo->prepare("UPDATE Properties SET internal = ? WHERE name = ? AND internal != ?");
-            $updateStmt->execute([$definition['internal'], $definition['name'], $definition['internal']]);
-            $updated = $updateStmt->rowCount();
-            $totalUpdated += $updated;
-            if ($updated > 0) {
-                log_setup_local("Applied '{$definition['name']}' definition to {$updated} properties");
-            }
-        }
-        
-        if ($totalUpdated === 0) {
-            log_setup_local("No existing properties needed updating");
-        } else {
-            log_setup_local("Total properties updated: {$totalUpdated}");
-        }
-
         log_setup_local("Database setup completed successfully!");
 
     } catch (Exception $e) {
diff --git a/docs/API_SPECIFICATION.md b/docs/API_SPECIFICATION.md
index 6e9ad3c..196c3ef 100644
--- a/docs/API_SPECIFICATION.md
+++ b/docs/API_SPECIFICATION.md
@@ -1,5 +1,3 @@
-Of course. Here is the complete, revised `API_SPECIFICATION.md` file with detailed examples for all endpoints, adhering to the GET/POST-only constraint. It has been updated for consistency, clarity, and completeness based on the provided PHP files.
-
 ---
 
 # API Specification (v1)
@@ -8,17 +6,17 @@ This document provides a detailed specification for the API endpoints, revised t
 
 **Key Design Principles:**
 *   **API Versioning:** All endpoints are prefixed with `/api/v1/`.
-*   **GET/POST Only:** Operations typically using PUT or DELETE are handled via POST requests, using an `_method` parameter in the request body (for form-like requests) or as a top-level key in JSON payloads.
-*   **Idempotent GETs:** GET requests are strictly for data retrieval and have no side effects.
-*   **Universal Pagination:** All list-returning endpoints support `page` and `per_page` parameters and include a consistent pagination object in the response.
+*   **GET/POST Only:** Write operations (create, update, delete) are handled via POST requests, using an `_method` override key in the JSON payload.
+*   **Content as Single Source of Truth:** Properties for notes and pages are derived directly from their respective `content` fields. The `Properties` database table serves as a queryable index of this content.
+*   **Universal Pagination:** All list-returning endpoints support `page` and `per_page` and include a consistent pagination object.
 *   **Response Standardization:**
     *   Unified success/error reporting using `status: "success"` or `status: "error"`.
     *   Successful responses wrap their payload in a `data` key.
-*   **Consistent Property Structure:** Property objects within responses are consistently structured as ` "property_name": [{"value": "...", "internal": 0/1}]`.
 
 ## Table of Contents
 
 - [General Concepts](#general-concepts)
+  - [Content-Driven Properties](#content-driven-properties)
   - [Pagination](#pagination)
   - [Error Responses](#error-responses)
 - [Endpoints](#endpoints)
@@ -29,14 +27,67 @@ This document provides a detailed specification for the API endpoints, revised t
   - [Pages (`/api/v1/pages.php`)](#pages-apiv1pagesphp)
   - [Append to Page (`/api/v1/append_to_page.php`)](#append-to-page-apiv1append_to_pagephp)
   - [Properties (`/api/v1/properties.php`)](#properties-apiv1propertiesphp)
-  - [Property Definitions (`/api/v1/property_definitions.php`)](#property-definitions-apiv1property_definitionsphp)
-  - [Query Notes (`/api/v1/query_notes.php`)](#query-notes-apiv1query_notesphp)
   - [Search (`/api/v1/search.php`)](#search-apiv1searchphp)
+  - [Query Notes (`/api/v1/query_notes.php`)](#query-notes-apiv1query_notesphp)
   - [Templates (`/api/v1/templates.php`)](#templates-apiv1templatesphp)
   - [Webhooks (`/api/v1/webhooks.php`)](#webhooks-apiv1webhooksphp)
 
+---
+
 ## General Concepts
 
+### Content-Driven Properties
+
+The `Properties` table is no longer directly managed. Instead, it is an index populated by parsing the `content` of a Note or Page. This is the new core of the system.
+
+#### Syntax
+
+Properties are defined within content using a key, a variable number of colons (`:`), and a value, optionally enclosed in curly braces `{}`. The number of colons determines the property's `weight`.
+
+*   `key::value` or `{key::value}` -> **Weight 2** (Default, public property)
+*   `key:::value` or `{key:::value}` -> **Weight 3** (Internal property)
+*   `key::::value` or `{key::::value}` -> **Weight 4** (System property, e.g., for logging)
+
+#### Configuration (`config.php`)
+
+The behavior of properties based on their weight is defined in `config.php` and interpreted by the **frontend**. The API's role is simply to parse and return the properties with their weight.
+
+**Example `config.php` structure:**
+```php
+define('PROPERTY_WEIGHTS', [
+    2 => [
+        'label' => 'Public',
+        'update_behavior' => 'replace', // 'replace' or 'append'
+        'visible_in_view_mode' => true,
+        'visible_in_edit_mode' => true
+    ],
+    3 => [
+        'label' => 'Internal',
+        'update_behavior' => 'replace',
+        'visible_in_view_mode' => false,
+        'visible_in_edit_mode' => true
+    ],
+    4 => [
+        'label' => 'System Log',
+        'update_behavior' => 'append',
+        'visible_in_view_mode' => false,
+        'visible_in_edit_mode' => false
+    ]
+]);
+```
+
+#### Backend Logic
+
+When a Note or Page is created or updated via the API:
+1.  The backend receives the new `content`.
+2.  It parses all property strings from the content.
+3.  For each parsed property, it intelligently updates the `Properties` table:
+    *   It compares the parsed properties with what's currently in the `Properties` table for that entity.
+    *   If a property's weight is configured with `update_behavior: 'replace'`, it finds and updates the existing row for that property name or inserts a new one if it doesn't exist.
+    *   If a property's weight is configured with `update_behavior: 'append'`, it **always inserts a new row**, creating a history of values.
+    *   Properties that existed in the table but are no longer in the content are deleted (unless their weight config specifies they should be preserved).
+4.  This logic ensures timestamps (`created_at`, `updated_at`) in the `Properties` table are meaningful.
+
 ### Pagination
 
 Endpoints that return a list of items support pagination via URL parameters.
@@ -51,9 +102,7 @@ The response for a paginated list will include a `pagination` object:
     "total_items": 150,
     "per_page": 20,
     "current_page": 2,
-    "total_pages": 8,
-    "has_next_page": true,
-    "has_prev_page": true
+    "total_pages": 8
 }
 ```
 
@@ -71,6 +120,8 @@ Errors are returned with an appropriate `4xx` or `5xx` status code and a consist
 }
 ```
 
+---
+
 ## Endpoints
 
 ### Ping (`/api/v1/ping.php`)
@@ -111,6 +162,7 @@ Retrieves details about currently active extensions.
     ```
 
 ### Attachments (`/api/v1/attachments.php`)
+
 Manages file attachments for notes.
 
 #### **`POST /api/v1/attachments.php` (Upload)**
@@ -124,12 +176,12 @@ Manages file attachments for notes.
         "status": "success",
         "data": {
             "id": 101,
-            "note_id": "42",
+            "note_id": 42,
             "name": "my-document.pdf",
             "path": "2023/10/uniqueid_my-document.pdf",
             "type": "application/pdf",
-            "created_at": "2023-10-27 10:30:00",
-            "size": null
+            "size": 123456,
+            "created_at": "2023-10-27 10:30:00"
         }
     }
     ```
@@ -173,38 +225,14 @@ Manages file attachments for notes.
         ]
     }
     ```
-*   **Example (List All, Paginated)**: `GET /api/v1/attachments.php?page=1&per_page=10`
-*   **Response (200 OK)**:
-    ```json
-    {
-        "status": "success",
-        "data": {
-            "data": [
-                {
-                    "id": 101,
-                    "name": "my-document.pdf",
-                    "path": "2023/10/uniqueid_my-document.pdf",
-                    "type": "application/pdf",
-                    "size": 123456,
-                    "created_at": "2023-10-27 10:30:00",
-                    "url": "http://localhost/uploads/2023/10/uniqueid_my-document.pdf"
-                }
-            ],
-            "pagination": {
-                "total_items": 1,
-                "per_page": 10,
-                "current_page": 1,
-                "total_pages": 1
-            }
-        }
-    }
-    ```
+---
 
 ### Notes (`/api/v1/notes.php`)
-Manages notes, their content, and their hierarchy.
+
+Manages notes and their content. All property modifications are now done by updating the note's `content` field.
 
 #### **`POST /api/v1/notes.php` (Batch Operations)**
-*   **Description**: Create, update, and delete multiple notes in a single atomic request. This is the primary way to modify notes.
+*   **Description**: Create, update, and delete multiple notes in a single atomic request. This is the **primary method** for all write operations on notes.
 *   **Request**: `application/json`
     ```json
     {
@@ -215,23 +243,14 @@ Manages notes, their content, and their hierarchy.
           "payload": {
             "client_temp_id": "temp-note-1",
             "page_id": 1,
-            "content": "This is the parent note."
-          }
-        },
-        {
-          "type": "create",
-          "payload": {
-            "client_temp_id": "temp-note-2",
-            "page_id": 1,
-            "content": "This is a child note.",
-            "parent_note_id": "temp-note-1"
+            "content": "This is a new task.\n{status::TODO}\n{priority::High}"
           }
         },
         {
           "type": "update",
           "payload": {
-            "id": 55,
-            "content": "Updated content for an existing note."
+            "id": 42,
+            "content": "This is an updated task.\n{status::::DONE}\n{priority::High}"
           }
         },
         {
@@ -253,19 +272,13 @@ Manages notes, their content, and their hierarchy.
                 {
                     "type": "create",
                     "status": "success",
-                    "note": { "id": 101, "content": "This is the parent note.", "...": "..." },
+                    "note": { "id": 101, "content": "This is a new task...", "properties": {"status": [...], "priority": [...]}, "...": "..." },
                     "client_temp_id": "temp-note-1"
                 },
-                {
-                    "type": "create",
-                    "status": "success",
-                    "note": { "id": 102, "parent_note_id": 101, "content": "This is a child note.", "...": "..." },
-                    "client_temp_id": "temp-note-2"
-                },
                 {
                     "type": "update",
                     "status": "success",
-                    "note": { "id": 55, "content": "Updated content for an existing note.", "...": "..." }
+                    "note": { "id": 42, "content": "This is an updated task...", "properties": {"status": [...], "priority": [...]}, "...": "..." }
                 },
                 {
                     "type": "delete",
@@ -278,90 +291,97 @@ Manages notes, their content, and their hierarchy.
     ```
 
 #### **`GET /api/v1/notes.php?id={id}`**
-*   **Description**: Retrieves a single note by its ID.
+*   **Description**: Retrieves a single note, including its properties derived from its content.
 *   **Response (200 OK)**:
     ```json
     {
         "status": "success",
         "data": {
-            "id": 1,
+            "id": 42,
             "page_id": 10,
-            "content": "This is a sample note.\n{status::TODO}",
+            "content": "This is an updated task.\n{status::::DONE}\n{priority::High}",
             "parent_note_id": null,
             "order_index": 0,
             "collapsed": 0,
-            "has_attachments": 1,
             "created_at": "2023-10-27 10:30:00",
             "updated_at": "2023-10-27 10:31:00",
-            "internal": 0,
             "properties": {
-                "status": [{"value": "TODO", "internal": 0}]
+                "status": [
+                    { "value": "TODO", "weight": 2, "created_at": "2023-10-27 10:30:00" },
+                    { "value": "DONE", "weight": 4, "created_at": "2023-10-27 10:31:00" }
+                ],
+                "priority": [
+                    { "value": "High", "weight": 2, "created_at": "2023-10-27 10:30:00" }
+                ]
             }
         }
     }
     ```
 
 #### **`GET /api/v1/notes.php?page_id={id}`**
-*   **Description**: Retrieves all notes for a specific page, ordered by their `order_index`.
+*   **Description**: Retrieves all notes for a specific page.
 *   **Response (200 OK)**:
     ```json
     {
         "status": "success",
         "data": [
             {
-                "id": 1,
-                "page_id": 10,
-                "content": "First note on the page.",
-                "properties": {},
+                "id": 42,
+                "content": "First note...",
+                "properties": { "...": "..." },
                 "...": "..."
             },
             {
-                "id": 2,
-                "page_id": 10,
-                "content": "Second note on the page.",
-                "properties": {},
+                "id": 43,
+                "content": "Second note...",
+                "properties": { "...": "..." },
                 "...": "..."
             }
         ]
     }
     ```
 
+---
+
 ### Pages (`/api/v1/pages.php`)
-Manages pages, which are containers for notes.
+
+Manages pages, which now also have a `content` field to drive their properties.
 
 #### **`POST /api/v1/pages.php` (Create)**
-*   **Description**: Creates a new page. If a page with the given name exists, it returns the existing page.
+*   **Description**: Creates a new page.
 *   **Request**: `application/json`
     ```json
     {
-        "name": "New Project Page",
-        "alias": "proj-new"
+      "name": "New Project Page",
+      "content": "{type::Project}\n{lead:::John Doe}"
     }
     ```
-*   **Response (201 Created or 200 OK)**:
+*   **Response (201 Created)**:
     ```json
     {
         "status": "success",
         "data": {
             "id": 25,
             "name": "New Project Page",
-            "alias": "proj-new",
-            "updated_at": "2023-10-27 10:35:00",
+            "content": "{type::Project}\n{lead:::John Doe}",
             "created_at": "2023-10-27 10:35:00",
-            "active": 1,
-            "properties": {}
+            "updated_at": "2023-10-27 10:35:00",
+            "properties": {
+                "type": [{"value": "Project", "weight": 2, "created_at": "2023-10-27 10:35:00"}],
+                "lead": [{"value": "John Doe", "weight": 3, "created_at": "2023-10-27 10:35:00"}]
+            }
         }
     }
     ```
 
 #### **`POST /api/v1/pages.php` (Update)**
-*   **Description**: Updates a page's name or alias.
+*   **Description**: Updates a page's name or content.
 *   **Request**: `application/json`
     ```json
     {
         "_method": "PUT",
         "id": 25,
-        "name": "Updated Project Page"
+        "content": "{type::Project}\n{lead:::Jane Doe}\n{status::Active}"
     }
     ```
 *   **Response (200 OK)**:
@@ -370,15 +390,16 @@ Manages pages, which are containers for notes.
         "status": "success",
         "data": {
             "id": 25,
-            "name": "Updated Project Page",
-            "alias": "proj-new",
-            "...": "..."
+            "name": "New Project Page",
+            "content": "{type::Project}\n{lead:::Jane Doe}\n{status::Active}",
+            "...": "...",
+            "properties": { "..." : "..." }
         }
     }
     ```
-
+    
 #### **`POST /api/v1/pages.php` (Delete)**
-*   **Description**: Deletes a page and all its associated notes and properties via database cascade.
+*   **Description**: Deletes a page and all its associated notes.
 *   **Request**: `application/json`
     ```json
     {
@@ -396,50 +417,47 @@ Manages pages, which are containers for notes.
     }
     ```
 
-#### **`GET /api/v1/pages.php?name={name}`**
-*   **Description**: Retrieves a page by its name. If the page doesn't exist, it is created and returned.
-*   **Response (200 OK or 201 Created)**:
+#### **`GET /api/v1/pages.php?id={id}`**
+*   **Description**: Retrieves a single page by its ID.
+*   **Response (200 OK)**:
     ```json
     {
         "status": "success",
         "data": {
-            "id": 26,
-            "name": "2023-10-27",
-            "alias": null,
+            "id": 25,
+            "name": "New Project Page",
+            "content": "{type::Project}\n{lead:::Jane Doe}\n{status::Active}",
+            "created_at": "2023-10-27 10:35:00",
+            "updated_at": "2023-10-27 10:40:00",
             "properties": {
-                "type": [{"value": "journal", "internal": 0}]
-            },
-            "...": "..."
+                "type": [{"value": "Project", "weight": 2, "created_at": "2023-10-27 10:35:00"}],
+                "lead": [{"value": "Jane Doe", "weight": 3, "created_at": "2023-10-27 10:40:00"}],
+                "status": [{"value": "Active", "weight": 2, "created_at": "2023-10-27 10:40:00"}]
+            }
         }
     }
     ```
 
-#### **`GET /api/v1/pages.php` (List All)**
-*   **Description**: Retrieves a paginated list of all pages.
-*   **Example**: `GET /api/v1/pages.php?page=1&per_page=10&exclude_journal=1`
+#### **`GET /api/v1/pages.php` (List)**
+*   **Description**: Retrieves a paginated list of pages.
 *   **Response (200 OK)**:
     ```json
     {
         "status": "success",
-        "data": {
-            "data": [
-                {
-                    "id": 2,
-                    "name": "Project Alpha",
-                    "...": "..."
-                }
-            ],
-            "pagination": {
-                "current_page": 1,
-                "per_page": 10,
-                "total_pages": 1,
-                "total_items": 1,
-                "...": "..."
+        "data": [
+            {
+                "id": 25,
+                "name": "New Project Page",
+                "content": "...",
+                "properties": { "...": "..." }
             }
-        }
+        ],
+        "pagination": { "total_items": 1, "...": "..." }
     }
     ```
 
+---
+
 ### Append to Page (`/api/v1/append_to_page.php`)
 A utility endpoint to quickly add notes to a page, creating the page if it doesn't exist.
 
@@ -452,11 +470,11 @@ A utility endpoint to quickly add notes to a page, creating the page if it doesn
       "notes": [
         {
           "client_temp_id": "topic-1",
-          "content": "Discussion Topic 1: Budget",
+          "content": "Discussion Topic 1: Budget {priority::High}",
           "order_index": 0
         },
         {
-          "content": "Action Item: Follow up with finance.",
+          "content": "Action Item: Follow up with finance. {status::TODO}",
           "parent_note_id": "topic-1",
           "order_index": 0
         }
@@ -472,20 +490,24 @@ A utility endpoint to quickly add notes to a page, creating the page if it doesn
             "page": {
                 "id": 27,
                 "name": "Meeting Notes 2023-10-27",
+                "content": null,
+                "properties": {},
                 "...": "..."
             },
             "appended_notes": [
                 {
                     "id": 103,
                     "page_id": 27,
-                    "content": "Discussion Topic 1: Budget",
+                    "content": "Discussion Topic 1: Budget {priority::High}",
+                    "properties": { "priority": [{"value": "High", "weight": 2, "...":"..."}] },
                     "...": "..."
                 },
                 {
                     "id": 104,
                     "page_id": 27,
                     "parent_note_id": 103,
-                    "content": "Action Item: Follow up with finance.",
+                    "content": "Action Item: Follow up with finance. {status::TODO}",
+                    "properties": { "status": [{"value": "TODO", "weight": 2, "...":"..."}] },
                     "...": "..."
                 }
             ]
@@ -493,155 +515,39 @@ A utility endpoint to quickly add notes to a page, creating the page if it doesn
     }
     ```
 
-### Properties (`/api/v1/properties.php`)
-Manages metadata properties for notes and pages.
+---
 
-#### **`POST /api/v1/properties.php` (Set)**
-*   **Description**: Creates or updates a property for a given entity.
-*   **Request**: `application/json`
-    ```json
-    {
-        "entity_type": "note",
-        "entity_id": 42,
-        "name": "priority",
-        "value": "High"
-    }
-    ```
-*   **Response (200 OK)**:
-    ```json
-    {
-        "status": "success",
-        "data": {
-            "property": {
-                "name": "priority",
-                "value": "High",
-                "internal": 0
-            }
-        }
-    }
-    ```
+### Properties (`/api/v1/properties.php`)
 
-#### **`POST /api/v1/properties.php` (Delete)**
-*   **Description**: Deletes all values for a given property name from an entity.
-*   **Request**: `application/json`
-    ```json
-    {
-        "action": "delete",
-        "entity_type": "note",
-        "entity_id": 42,
-        "name": "priority"
-    }
-    ```
-*   **Response (200 OK)**:
-    ```json
-    {
-        "status": "success",
-        "data": null
-    }
-    ```
+This endpoint is now **read-only**. It provides a way to query the `Properties` table index directly, which can be useful for advanced filtering or finding all entities with a specific property value, without needing to perform a full-text search.
 
 #### **`GET /api/v1/properties.php`**
-*   **Description**: Retrieves all properties for a given entity.
-*   **Example**: `GET /api/v1/properties.php?entity_type=note&entity_id=42&include_internal=1`
-*   **Response (200 OK)**:
-    ```json
-    {
-        "status": "success",
-        "data": {
-            "priority": [{"value": "High", "internal": 0}],
-            "status": [{"value": "TODO", "internal": 0}],
-            "_last_processed": [{"value": "2023-10-27 10:40:00", "internal": 1}]
-        }
-    }
-    ```
-
-### Property Definitions (`/api/v1/property_definitions.php`)
-Manages the schema and behavior of properties.
-
-#### **`POST /api/v1/property_definitions.php` (Create/Update)**
-*   **Description**: Defines or updates a property's behavior (e.g., making it internal).
-*   **Request**: `application/json`
-    ```json
-    {
-        "name": "secret_key",
-        "internal": 1,
-        "description": "A secret key for integration, should not be displayed.",
-        "auto_apply": 1
-    }
-    ```
-*   **Response (200 OK)**:
-    ```json
-    {
-        "status": "success",
-        "data": {
-            "message": "Property definition saved and applied to 0 existing properties"
-        }
-    }
-    ```
-
-#### **`GET /api/v1/property_definitions.php`**
-*   **Description**: Retrieves a list of all defined properties.
-*   **Response (200 OK)**:
-    ```json
-    {
-        "status": "success",
-        "data": [
-            {
-                "id": 1,
-                "name": "internal",
-                "internal": 1,
-                "description": "Properties that control note/page visibility",
-                "auto_apply": 1,
-                "...": "..."
-            }
-        ]
-    }
-    ```
-
-### Query Notes (`/api/v1/query_notes.php`)
-Executes safe, predefined SQL queries to find notes.
-
-#### **`POST /api/v1/query_notes.php`**
-*   **Description**: Fetches notes that match a specific, secure SQL query pattern.
-*   **Request**: `application/json`
-    ```json
-    {
-      "sql_query": "SELECT DISTINCT N.id FROM Notes N JOIN Properties P ON N.id = P.note_id WHERE P.name = 'status' AND P.value = 'TODO'",
-      "include_properties": true,
-      "page": 1,
-      "per_page": 5
-    }
-    ```
+*   **Description**: Retrieves all indexed properties for a specific entity.
+*   **Example Call**: `GET /api/v1/properties.php?entity_type=note&entity_id=42`
 *   **Response (200 OK)**:
     ```json
     {
         "status": "success",
         "data": {
-            "data": [
-                {
-                    "id": 42,
-                    "content": "This is a task that needs to be done. {status::TODO}",
-                    "properties": {
-                        "status": [{"value": "TODO", "internal": 0}]
-                    },
-                    "...": "..."
-                }
+            "status": [
+                { "id": 201, "value": "TODO", "weight": 2, "created_at": "2023-10-27 10:30:00" },
+                { "id": 205, "value": "DONE", "weight": 4, "created_at": "2023-10-27 10:31:00" }
             ],
-            "pagination": {
-                "current_page": 1,
-                "per_page": 5,
-                "total_count": 1,
-                "total_pages": 1
-            }
+            "priority": [
+                { "id": 202, "value": "High", "weight": 2, "created_at": "2023-10-27 10:30:00" }
+            ]
         }
     }
     ```
 
+---
+
 ### Search (`/api/v1/search.php`)
-Provides full-text, backlink, and task search capabilities.
+
+Provides powerful search capabilities. This is unchanged as it already queries the `Notes` content and `Properties` index.
 
 #### **`GET /api/v1/search.php?q={term}`**
-*   **Description**: Performs a full-text search across note content and page names.
+*   **Description**: Performs a full-text search across note/page content.
 *   **Response (200 OK)**:
     ```json
     {
@@ -653,7 +559,8 @@ Provides full-text, backlink, and task search capabilities.
                     "content": "The full content of the note mentioning the search term.",
                     "page_id": 10,
                     "page_name": "Project Alpha",
-                    "content_snippet": "... with the search <mark>term</mark> highlighted ..."
+                    "content_snippet": "... with the search <mark>term</mark> highlighted ...",
+                    "properties": { "...": "..." }
                 }
             ],
             "pagination": { "total": 1, "page": 1, "per_page": 20, "total_pages": 1 }
@@ -661,55 +568,42 @@ Provides full-text, backlink, and task search capabilities.
     }
     ```
 
-#### **`GET /api/v1/search.php?backlinks_for_page_name={name}`**
-*   **Description**: Finds all notes that link to the specified page name.
-*   **Response (200 OK)**:
+---
+
+### Query Notes (`/api/v1/query_notes.php`)
+
+Executes safe, predefined SQL queries against the indexed `Properties` table to find notes. This becomes even more powerful for historical queries.
+
+#### **`POST /api/v1/query_notes.php`**
+*   **Description**: Fetches notes that match a specific, secure SQL query pattern.
+*   **Request**: `application/json`
     ```json
     {
-        "status": "success",
-        "data": {
-            "results": [
-                {
-                    "note_id": 15,
-                    "content": "See details in [[Project Alpha]] for more info.",
-                    "page_id": 12,
-                    "source_page_name": "Meeting Summary",
-                    "content_snippet": "See details in <mark>[[Project Alpha]]</mark> for more info."
-                }
-            ],
-            "pagination": { "total": 1, "page": 1, "per_page": 20, "total_pages": 1 }
-        }
+      "sql_query": "SELECT N.id FROM Notes N JOIN Properties P ON N.id = P.note_id WHERE P.name = 'status' AND P.value = 'DONE' AND P.created_at > '2023-10-27'",
+      "page": 1,
+      "per_page": 10
     }
     ```
-
-#### **`GET /api/v1/search.php?tasks={status}`**
-*   **Description**: Finds all notes with a task status of `todo` or `done`.
-*   **Example**: `GET /api/v1/search.php?tasks=todo`
 *   **Response (200 OK)**:
     ```json
     {
         "status": "success",
-        "data": {
-            "results": [
-                {
-                    "note_id": 42,
-                    "content": "TODO Finalize the report",
-                    "page_id": 10,
-                    "page_name": "Project Alpha",
-                    "property_name": "status",
-                    "property_value": "TODO",
-                    "content_snippet": "<mark>TODO</mark> Finalize the report",
-                    "properties": {
-                        "status": [{"value": "TODO", "internal": 0}]
-                    }
-                }
-            ],
-            "pagination": { "total": 1, "page": 1, "per_page": 20, "total_pages": 1 }
-        }
+        "data": [
+            {
+                "id": 42,
+                "content": "This is an updated task.\n{status::::DONE}\n{priority::High}",
+                "properties": { "...": "..." },
+                "...": "..."
+            }
+        ],
+        "pagination": { "current_page": 1, "...": "..." }
     }
     ```
 
+---
+
 ### Templates (`/api/v1/templates.php`)
+
 Manages reusable templates for creating notes and pages.
 
 #### **`POST /api/v1/templates.php` (Create)**
@@ -717,6 +611,7 @@ Manages reusable templates for creating notes and pages.
 *   **Request**: `application/json`
     ```json
     {
+        "_method": "POST",
         "type": "note",
         "name": "daily-review",
         "content": "## Daily Review\n\n### What went well?\n\n- \n\n### What could be improved?\n\n- "
@@ -747,8 +642,10 @@ Manages reusable templates for creating notes and pages.
     }
     ```
 
+---
+
 ### Webhooks (`/api/v1/webhooks.php`)
-Manages webhook subscriptions for event notifications. To maintain consistency, all modification actions are done via `POST` with a URL query parameter `action`.
+Manages webhook subscriptions for event notifications.
 
 #### **`POST /api/v1/webhooks.php` (Create)**
 *   **Description**: Registers a new webhook.
@@ -813,7 +710,7 @@ Manages webhook subscriptions for event notifications. To maintain consistency,
     }
     ```
 
-#### **`GET /api/v1/webhooks.php`**
+#### **`GET /api/v1/webhooks.php` (List)**
 *   **Description**: Lists all configured webhooks.
 *   **Response (200 OK)**:
     ```json
diff --git a/index.php b/index.php
index 1b34023..cc60a6e 100644
--- a/index.php
+++ b/index.php
@@ -1,245 +1,24 @@
 <?php
-require_once 'config.php';
-// You might include more common PHP setup here if needed
-?>
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>notd</title>
-    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'></text></svg>">
-    <link rel="preconnect" href="https://fonts.googleapis.com">
-    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
-    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap" rel="stylesheet">
-    <?php require_once 'assets/css/theme_loader.php'; ?>
-    <link rel="stylesheet" href="assets/css/style.css">
-    <link rel="stylesheet" href="assets/css/icons.css">
-    <script>
-        window.APP_CONFIG = {
-            RENDER_INTERNAL_PROPERTIES: <?php echo RENDER_INTERNAL_PROPERTIES ? 'true' : 'false'; ?>,
-            SHOW_INTERNAL_PROPERTIES_IN_EDIT_MODE: <?php echo SHOW_INTERNAL_PROPERTIES_IN_EDIT_MODE ? 'true' : 'false'; ?>
-        };
-    </script>
-</head>
-<body>
-    <div id="splash-screen">
-        <div class="time-date-container">
-            <div id="clock" class="clock">12:00</div>
-            <div id="date" class="date">Monday, 1 January</div>
-        </div>
-        <div id="splash-background-bubbles-canvas">
-            <!-- Canvas for dynamic bubbles -->
-        </div>
-        <div id="splash-orb-container">
-            <div id="splash-orb-inner-core">
-                <div id="splash-orb-text-container">
-                    <p id="splash-orb-text">notd</p>
-                </div>
-                <div id="splash-orb-perimeter-dots">
-                    <!-- Dots will be generated by JS -->
-                </div>
-            </div>
-        </div>
-    </div>
-    
-    <div class="app-container">
-        <!-- Left Sidebar -->
-        <div id="left-sidebar-outer">
-            <button id="toggle-left-sidebar-btn" class="sidebar-toggle-btn left-toggle"></button>
-            <div id="left-sidebar" class="sidebar left-sidebar">
-                <div class="sidebar-content">
-                    <div class="app-header">
-                        <a href="#" id="app-title" class="app-title">notd</a>
-                    </div>
-
-                    <div class="calendar-widget">
-                        <div class="calendar-header">
-                            <button class="calendar-nav prev"><span class="icon icon-chevron-left"></span></button>
-                            <span class="current-month">September 2023</span>
-                            <button class="calendar-nav next"><span class="icon icon-chevron-right"></span></button>
-                        </div>
-                        <div class="calendar-grid">
-                            <div class="calendar-weekdays">
-                                <span>Su</span><span>Mo</span><span>Tu</span><span>We</span>
-                                <span>Th</span><span>Fr</span><span>Sa</span>
-                            </div>
-                            <div class="calendar-days">
-                                <!-- Calendar days will be populated by JavaScript -->
-                            </div>
-                        </div>
-                    </div>
-
-                    <!-- Global Search -->
-                    <div class="search-section">
-                        <input type="text" id="global-search-input" placeholder="Search notes..." class="search-input">
-                        <div id="search-results" class="search-results">
-                            <!-- Search results will be populated by JavaScript -->
-                        </div>
-                    </div>
-
-                    <div class="recent-pages">
-                        <h3>Recent Pages</h3>
-                        <div id="page-list">
-                            <!-- Pages will be populated by JavaScript -->
-                        </div>
-                    </div>
-
-                    <div class="sidebar-footer">
-                        <button id="open-page-search-modal-btn" class="action-button full-width-button">
-                            <span class="icon icon-search"></span>&nbsp;
-                            Search or Create Page
-                        </button>
-                    </div>
-                </div>
-            </div>
-        </div>
-
-        <!-- Main Content -->
-        <div id="main-content" class="main-content">
-            <div class="page-title-container">
-            <div id="page-title" class="page-title">
-                <!-- Page title and namespace breadcrumbs will be populated by JavaScript -->
-            </div>
-            <div id="page-properties"></div>
-            <div id="note-focus-breadcrumbs-container"></div>
-            </div>
-            <div id="notes-container" class="outliner">
-                <!-- Notes will be rendered here -->
-            </div>
-
-            <button id="add-root-note-btn" class="action-button round-button">
-                <span class="icon icon-plus"></span>
-            </button>
-        </div>
-
-        <div id="save-status-indicator" title="All changes saved">
-            <!-- Icon will be injected by JS -->
-        </div>
-        <div id="toggle-splash-btn" title="Toggle Splash Screen">
-            z
-        </div>
-
-        <!-- Right Sidebar -->
-        <div id="right-sidebar-outer">
-            <button id="toggle-right-sidebar-btn" class="sidebar-toggle-btn right-toggle"></button>
-            <div id="right-sidebar" class="sidebar right-sidebar">
-                <div class="sidebar-content">
-                    <div class="sidebar-header">
-                        <h3>Favorites</h3>
-                    </div>
-                    <div id="favorites-container"></div>
-                    
-                    <div class="backlinks-section">
-                        <h4>Backlinks</h4>
-                        <div id="backlinks-container">
-                            <!-- Backlinks will be populated by JavaScript -->
-                        </div>
-                    </div>
-
-                    <div class="extensions-section">
-                        <h4>Extensions</h4>
-                        <div id="extension-icons-container">
-                            <!-- Extension icons will be populated by JavaScript -->
-                        </div>
-                    </div>
-                </div>
-            </div>
-        </div>
-    </div>
-
-    <!-- Page Properties Modal -->
-    <div id="page-properties-modal" class="generic-modal">
-        <div class="generic-modal-content">
-            <div class="generic-modal-header">
-                <h2 id="page-properties-modal-title" class="generic-modal-title">Page Properties</h2>
-                <!-- modal-header-icons div might be redundant if close button is absolute, or can be kept for other icons -->
-                <div class="modal-header-icons">
-                    <div id="page-modal-encryption-button">
-                        <i data-feather="key" class="page-encryption-icon" id="page-encryption-icon" title="Set page encryption"></i>
-                    </div>
-                    <div id="page-modal-close-button">
-                        <button class="modal-close-x" aria-label="Close modal" id="page-properties-modal-close" data-target-modal="page-properties-modal">
-                            <i data-feather="x"></i>
-                        </button>
-                    </div>
-               </div>
-            </div>
-            <div id="page-properties-list" class="page-properties-list"></div>
-            <div class="generic-modal-actions">
-                <button class="button add-property-btn" id="add-page-property-btn">+ Add Property</button>
-            </div>
-        </div>
-    </div>
-
-    <!-- Page Search Modal -->
-    <div id="page-search-modal" class="generic-modal">
-        <div class="generic-modal-content page-search-modal-styling"> <!-- page-search-modal-styling was added in previous step -->
-            <div class="generic-modal-header">
-                <h2 id="page-search-modal-title" class="generic-modal-title">Search or Create Page</h2> <!-- Changed h3 to h2 for consistency with other modal titles -->
-                <button class="modal-close-x" aria-label="Close modal" data-target-modal="page-search-modal">
-                    <i data-feather="x"></i>
-                </button>
-            </div>
-            <input type="text" id="page-search-modal-input" class="generic-modal-input-field" placeholder="Type to search or create..." style="margin-top: var(--ls-space-2);">
-            <ul id="page-search-modal-results" class="page-search-results-list">
-                <!-- Results will be populated here by JavaScript -->
-            </ul>
-            <div class="generic-modal-actions">
-                <button id="page-search-modal-cancel" class="button secondary-button">Cancel</button>
-            </div>
-        </div>
-    </div>
-
-    <!-- Generic Input Modal -->
-    <div id="generic-input-modal" class="generic-modal">
-        <div class="generic-modal-content">
-            <div class="generic-modal-header">
-                <h2 id="generic-input-modal-title" class="generic-modal-title">Input Required</h2>
-                <button class="modal-close-x" aria-label="Close modal" data-target-modal="generic-input-modal">
-                    <i data-feather="x"></i>
-                </button>
-            </div>
-            <input type="text" id="generic-input-modal-input" class="generic-modal-input-field" style="margin-top: var(--ls-space-2);"> <!-- Added small margin-top for spacing from new header -->
-            <div class="generic-modal-actions">
-                <button id="generic-input-modal-cancel" class="button secondary-button">Cancel</button>
-                <button id="generic-input-modal-ok" class="button primary-button">OK</button>
-            </div>
-        </div>
-    </div>
-
-    <!-- Generic Confirm Modal -->
-    <div id="generic-confirm-modal" class="generic-modal">
-        <div class="generic-modal-content">
-            <div class="generic-modal-header">
-                <h2 id="generic-confirm-modal-title" class="generic-modal-title">Confirm Action</h2>
-                <button class="modal-close-x" aria-label="Close modal" data-target-modal="generic-confirm-modal">
-                    <i data-feather="x"></i>
-                </button>
-            </div>
-            <p id="generic-confirm-modal-message" style="margin-top: var(--ls-space-2);">Are you sure?</p> <!-- Added small margin-top -->
-            <div class="generic-modal-actions">
-                <button id="generic-confirm-modal-cancel" class="button secondary-button">Cancel</button>
-                <button id="generic-confirm-modal-ok" class="button primary-button">OK</button>
-            </div>
-        </div>
-    </div>
-
-    <!-- Simple Image Viewer Modal -->
-    <div id="image-viewer-modal" class="generic-modal image-viewer-modal">
-        <span class="image-viewer-close" id="image-viewer-modal-close">&times;</span>
-        <img src="" alt="Image Preview" id="image-viewer-modal-img">
-    </div>
-
-    <!-- SCRIPTS -->
-    <script src="assets/libs/sjcl.js"></script>
-    <script src="assets/libs/feather.min.js"></script>
-    <script src="assets/libs/marked.min.js"></script>
-    <script src="assets/libs/Sortable.min.js"></script>
-    <script type="module" src="assets/js/utils.js"></script>
-    <script src="assets/js/splash.js"></script>
-    <script type="module" src="assets/js/api_client.js"></script>
-    <script type="module" src="assets/js/ui.js"></script>
-    <script type="module" src="assets/js/app.js"></script>
-</body>
-</html>
\ No newline at end of file
+/**
+ * Application Entry Point
+ *
+ * This file's sole purpose is to determine the initial page to load
+ * and redirect the browser to the main application shell (page.php)
+ * with the correct page name as a URL parameter.
+ *
+ * The default initial page is today's journal page in 'YYYY-MM-DD' format.
+ */
+
+// Determine the initial page name. This should match the logic in the JS app.
+$initial_page_name = date('Y-m-d');
+
+// Construct the URL for the main application shell.
+// We use urlencode() to ensure the page name is safely passed in the URL.
+$redirect_url = 'page.php?page=' . urlencode($initial_page_name);
+
+// Perform a temporary (302) redirect, which is appropriate as the "home"
+// page changes daily. This prevents aggressive browser caching of the redirect.
+header('Location: ' . $redirect_url, true, 302);
+
+// Ensure no further code is executed after the redirect header is sent.
+exit;
\ No newline at end of file
diff --git a/page.php b/page.php
index 9f7981c..6c3fd67 100644
--- a/page.php
+++ b/page.php
@@ -1,137 +1,58 @@
 <?php
+// Include the main configuration file to make constants available.
 require_once 'config.php';
-require_once 'api/db_connect.php';
 
-// Get page ID from URL
-$pageId = isset($_GET['id']) ? (int)$_GET['id'] : null;
-$page = null;
-
-if ($pageId) {
-    // Try to get page data from database if ID is provided
-    try {
-        $pdo = get_db_connection();
-        $stmt = $pdo->prepare("SELECT * FROM Pages WHERE id = ?");
-        $stmt->execute([$pageId]);
-        $page = $stmt->fetch(PDO::FETCH_ASSOC);
-        // If page is not found, $page will be false. We'll let the next block handle it.
-    } catch (Exception $e) {
-        error_log("Error loading page data for ID {$pageId}: " . $e->getMessage());
-        // If there's an error, we'll treat it as page not found and try to create it or redirect.
-        $page = null; 
-    }
+// --- Failsafe Redirect ---
+// Get the page name from the URL.
+$pageName = isset($_GET['page']) ? trim($_GET['page']) : null;
+
+// If no page name is provided, this script was loaded directly without the
+// proper context. Redirect to the default journal page to ensure the
+// JavaScript application has a valid starting point.
+if (empty($pageName)) {
+    $default_page_name = date('Y-m-d');
+    $redirect_url = 'page.php?page=' . urlencode($default_page_name);
+    header('Location: ' . $redirect_url, true, 302);
+    exit;
 }
 
-// If page ID is not provided, or page was not found by ID (or an error occurred fetching it)
-if (!$page) {
-    $pageName = isset($_GET['name']) ? trim($_GET['name']) : null;
-
-    if ($pageName && !empty($pageName)) { // Ensure pageName is not empty
-        // Attempt to create the page via API
-        // Construct the API URL dynamically
-        $protocol = (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on' ? "https" : "http");
-        $host = $_SERVER['HTTP_HOST'];
-        // Correctly determine the base path for the API
-        // dirname($_SERVER['PHP_SELF']) might give unexpected results if page.php is in root
-        // Assuming api is always at <base_url>/api/v1/pages.php
-        $scriptPath = dirname($_SERVER['SCRIPT_NAME']); // SCRIPT_NAME is more reliable for path
-        if ($scriptPath === '/' || $scriptPath === '\\') {
-            $scriptPath = ''; // Avoid double slashes if script is in root
-        }
-        $apiUrl = $protocol . "://" . $host . $scriptPath . '/api/v1/pages.php';
-        
-        $data = json_encode(['name' => $pageName]);
-        
-        $options = [
-            'http' => [
-                'header'  => "Content-Type: application/json\r\n",
-                'method'  => 'POST',
-                'content' => $data,
-                'ignore_errors' => true // Allows us to read response body on errors
-            ],
-            // Add SSL context options if your server uses self-signed certificates (for development)
-            // 'ssl' => [
-            //     'verify_peer' => false,
-            //     'verify_peer_name' => false,
-            // ],
-        ];
-        
-        $context = stream_context_create($options);
-        $response = @file_get_contents($apiUrl, false, $context); // Use @ to suppress warnings, check response === false
-        
-        $statusCode = null;
-        if (isset($http_response_header) && is_array($http_response_header) && count($http_response_header) > 0) {
-            // Filter out any warning messages that might have been added to $http_response_header
-            $statusLine = '';
-            foreach ($http_response_header as $headerVal) {
-                if (strpos(strtolower($headerVal), 'http/') === 0) {
-                    $statusLine = $headerVal;
-                    break;
-                }
-            }
-            if (!empty($statusLine)) {
-                preg_match('{HTTP\/\S*\s(\d{3})}', $statusLine, $match);
-                if ($match) {
-                    $statusCode = (int)$match[1];
-                }
-            }
-        }
-
-        if ($response !== false && $statusCode === 201) {
-            $responseData = json_decode($response, true);
-            if (isset($responseData['id'])) {
-                // Page created successfully, redirect to the new page
-                header('Location: page.php?id=' . $responseData['id']);
-                exit;
-            } else {
-                // API returned success but no ID, log error and redirect to index
-                error_log("Page creation API call to {$apiUrl} succeeded (201) but no ID was returned. Page name: {$pageName}. Response: " . $response);
-                header('Location: /?error=creation_no_id');
-                exit;
-            }
-        } else {
-            // Page creation failed or other error
-            $phpError = error_get_last();
-            $phpErrorMessage = $phpError ? $phpError['message'] : 'No PHP error';
-            error_log("Page creation API call to {$apiUrl} failed. Page name: {$pageName}. Status: " . ($statusCode ?? 'Unknown') . ". Response: " . $response . ". PHP Error: " . $phpErrorMessage);
-            header('Location: /?error=creation_failed');
-            exit;
-        }
-    } else {
-        // No page name provided (or empty after trim), or page ID was initially provided but page not found
-        // If $pageId was set, it means the page for that ID was not found.
-        // If $pageId was not set, and $pageName was also not set or empty.
-        if ($pageId && !$pageName) { // This case means an ID was given, but page not found, and no 'name' param to create
-             error_log("Page with ID {$pageId} not found, and no 'name' parameter provided to create a new one.");
-        }
-        header('Location: /');
-        exit;
-    }
-}
+// --- Frontend Configuration ---
+// Pass relevant backend configuration settings to the frontend JavaScript.
+// This uses the PROPERTY_WEIGHTS constant from config.php.
+$renderInternal = PROPERTY_WEIGHTS[3]['visible_in_view_mode'] ?? false;
+$showInternalInEdit = PROPERTY_WEIGHTS[3]['visible_in_edit_mode'] ?? true;
 
-// If we reach here, it means a page with $pageId was found successfully and $page is populated.
-// The existing functionality for displaying the page continues.
 ?>
 <!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title><?php echo htmlspecialchars($page['title']); ?> - notd</title>
-    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'></text></svg>">
+    <title><?php echo htmlspecialchars($pageName); ?> - notd</title>
+    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'></text></svg>">
+    
+    <!-- Fonts and Core Styles -->
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap" rel="stylesheet">
+    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
+    
+    <!-- Theme and App Styles -->
     <?php include 'assets/css/theme_loader.php'; ?>
     <link rel="stylesheet" href="assets/css/style.css">
-    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
     <link rel="stylesheet" href="assets/css/icons.css">
+    <link rel="stylesheet" href="assets/css/calendar.css">
+    
+    <!-- Libraries -->
     <script src="assets/libs/feather.min.js"></script>
+    <script src="assets/libs/marked.min.js"></script>
+    <script src="assets/libs/Sortable.min.js"></script>
+    
     <script>
-        // Pass initial page data to JavaScript
-        window.initialPageData = <?php echo json_encode($page); ?>;
+        // Pass server-side configuration to JavaScript
         window.APP_CONFIG = {
-            RENDER_INTERNAL_PROPERTIES: <?php echo RENDER_INTERNAL_PROPERTIES ? 'true' : 'false'; ?>,
-            SHOW_INTERNAL_PROPERTIES_IN_EDIT_MODE: <?php echo SHOW_INTERNAL_PROPERTIES_IN_EDIT_MODE ? 'true' : 'false'; ?>
+            RENDER_INTERNAL_PROPERTIES: <?php echo json_encode($renderInternal); ?>,
+            SHOW_INTERNAL_PROPERTIES_IN_EDIT_MODE: <?php echo json_encode($showInternalInEdit); ?>
         };
     </script>
 </head>
@@ -145,26 +66,31 @@ if (!$page) {
                     <div class="app-header">
                         <a href="/" id="app-title" class="app-title">notd</a>
                     </div>
-
-                    <!-- Global Search -->
-                    <div class="search-section">
-                        <input type="text" id="global-search-input" placeholder="Search notes..." class="search-input">
-                        <div id="search-results" class="search-results">
-                            <!-- Search results will be populated by JavaScript -->
+                    <div class="sidebar-section calendar-section">
+                        <h4>Calendar</h4>
+                        <div id="calendar-widget" class="calendar-widget">
+                            <div class="calendar-header">
+                                <button id="prev-month-btn" class="arrow-btn"><i data-feather="chevron-left"></i></button>
+                                <span id="current-month-year" class="month-year-display"></span>
+                                <button id="next-month-btn" class="arrow-btn"><i data-feather="chevron-right"></i></button>
+                            </div>
+                            <div class="calendar-grid calendar-weekdays">
+                                <span>Mon</span><span>Tue</span><span>Wed</span><span>Thu</span><span>Fri</span><span>Sat</span><span>Sun</span>
+                            </div>
+                            <div id="calendar-days-grid" class="calendar-grid calendar-days"></div>
                         </div>
                     </div>
-
+                    <div class="search-section">
+                        <input type="text" id="global-search-input" placeholder="Search..." class="search-input">
+                        <div id="search-results" class="search-results"></div>
+                    </div>
                     <div class="recent-pages">
-                        <h3>Recent Pages</h3>
-                        <div id="page-list">
-                            <!-- Pages will be populated by JavaScript -->
-                        </div>
+                        <h3>Recent</h3>
+                        <div id="page-list"></div>
                     </div>
-
                     <div class="sidebar-footer">
                         <button id="open-page-search-modal-btn" class="action-button full-width-button">
-                            <span class="icon icon-search"></span>&nbsp;
-                            Search or Create Page
+                            <i data-feather="search"></i> Search or Create Page
                         </button>
                     </div>
                 </div>
@@ -173,115 +99,99 @@ if (!$page) {
 
         <!-- Main Content -->
         <div id="main-content" class="main-content">
-        <div class="page-title-container">
-        <div id="page-title" class="page-title">
-                <!-- Page title and namespace breadcrumbs will be populated by JavaScript -->
+            <div class="page-title-container">
+                <h1 id="page-title" class="page-title">
+                    <!-- Page title and breadcrumbs populated by JS -->
+                </h1>
+                <div id="page-properties-container" class="page-properties-inline"></div>
             </div>
-            <div id="page-properties"></div>
             <div id="note-focus-breadcrumbs-container"></div>
-            </div>
             <div id="notes-container" class="outliner">
-                <!-- Notes will be rendered here -->
+                <!-- Notes will be rendered here by JavaScript -->
             </div>
-
-            <button id="add-root-note-btn" class="action-button round-button">
-                <span class="icon icon-plus"></span>
+            <div id="child-pages-container">
+                <!-- Child pages will be rendered here by JavaScript -->
+            </div>
+            <button id="add-root-note-btn" class="action-button round-button" title="Add new note to page">
+                <i data-feather="plus"></i>
             </button>
         </div>
 
-        <div id="save-status-indicator" title="All changes saved">
-            <!-- Icon will be injected by JS -->
-        </div>
-
         <!-- Right Sidebar -->
         <div id="right-sidebar-outer">
             <button id="toggle-right-sidebar-btn" class="sidebar-toggle-btn right-toggle"></button>
             <div id="right-sidebar" class="sidebar right-sidebar">
                 <div class="sidebar-content">
-                    <div class="sidebar-header">
-                        <h3>Favorites</h3>
+                    <div class="sidebar-section">
+                        <h4>Favorites</h4>
+                        <div id="favorites-container"></div>
                     </div>
-                    <div id="favorites-container"></div>
-                    
-                    <div class="backlinks-section">
+                    <div class="sidebar-section backlinks-section">
                         <h4>Backlinks</h4>
-                        <div id="backlinks-container">
-                            <!-- Backlinks will be populated by JavaScript -->
-                        </div>
+                        <div id="backlinks-container"></div>
                     </div>
-
-                    <div class="extensions-section">
+                    <div class="sidebar-section extensions-section">
                         <h4>Extensions</h4>
-                        <div id="extension-icons-container">
-                            <!-- Extension icons will be populated by JavaScript -->
-                        </div>
+                        <div id="extension-icons-container"></div>
                     </div>
                 </div>
             </div>
         </div>
+        
+        <!-- Save Status Indicator -->
+        <div id="save-status-indicator" title="All changes saved"></div>
+    </div>
+
+    <!-- Password Modal for Encrypted Pages -->
+    <div id="password-modal" class="modal-container" style="display: none;">
+        <div class="modal-content">
+            <h3>Encrypted Page</h3>
+            <p>This page is encrypted. Please enter the password to view it.</p>
+            <input type="password" id="password-input" placeholder="Password">
+            <div class="modal-actions">
+                <button id="password-submit">Decrypt</button>
+                <button id="password-cancel">Cancel</button>
+            </div>
+        </div>
     </div>
 
     <!-- Page Properties Modal -->
-    <div id="page-properties-modal" class="generic-modal">
-        <div class="generic-modal-content">
+    <div id="page-properties-modal" class="modal-container" style="display: none;">
+        <div class="modal-content">
             <div class="generic-modal-header">
                 <h2 id="page-properties-modal-title" class="generic-modal-title">Page Properties</h2>
-                <div class="modal-header-icons">
-                    <div id="page-modal-encryption-button">
-                        <button class="modal-icon-button" id="page-encryption-icon" title="Set page encryption">
-                            <i data-feather="key"></i>
-                        </button>
-                    </div>
-                    <div id="page-modal-close-button">
-                        <button class="modal-icon-button" id="page-properties-modal-close" aria-label="Close modal">
-                            <i data-feather="x"></i>
-                        </button>
-                    </div>
-                </div>
+                <button id="page-properties-modal-close" class="modal-close-x" aria-label="Close">
+                    <i data-feather="x"></i>
+                </button>
             </div>
             <div id="page-properties-list" class="page-properties-list"></div>
             <div class="generic-modal-actions">
-                <button class="button add-property-btn" id="add-page-property-btn">+ Add Property</button>
+                <button id="add-page-property-btn" class="button">+ Add Property</button>
             </div>
         </div>
     </div>
 
-    <!-- Page Search Modal -->
     <div id="page-search-modal" class="generic-modal">
         <div class="generic-modal-content page-search-modal-styling">
-            <div class="generic-modal-header">
-                <h2 id="page-search-modal-title" class="generic-modal-title">Search or Create Page</h2>
-                <button class="modal-close-x" aria-label="Close modal" data-target-modal="page-search-modal">
-                    <i data-feather="x"></i>
-                </button>
-            </div>
-            <input type="text" id="page-search-modal-input" class="generic-modal-input-field" placeholder="Type to search or create..." style="margin-top: var(--ls-space-2);">
-            <ul id="page-search-modal-results" class="page-search-results-list">
-                <!-- Results will be populated here by JavaScript -->
-            </ul>
+            <input type="text" id="page-search-modal-input" class="generic-modal-input-field" placeholder="Type to search or create...">
+            <ul id="page-search-modal-results" class="page-search-results-list"></ul>
             <div class="generic-modal-actions">
                 <button id="page-search-modal-cancel" class="button secondary-button">Cancel</button>
             </div>
         </div>
     </div>
-
-    <!-- Generic Input Modal -->
-    <div id="generic-input-modal" class="generic-modal">
+    
+    <div id="image-viewer-modal" class="generic-modal image-viewer">
         <div class="generic-modal-content">
-            <h2 id="generic-input-modal-title" class="generic-modal-title">Input Required</h2>
-            <input type="text" id="generic-input-modal-input" class="generic-modal-input-field">
-            <div class="generic-modal-actions">
-                <button id="generic-input-modal-cancel" class="button secondary-button">Cancel</button>
-                <button id="generic-input-modal-ok" class="button primary-button">OK</button>
-            </div>
+             <button id="image-viewer-modal-close" class="modal-close-x" aria-label="Close">
+                <i data-feather="x"></i>
+            </button>
+            <img id="image-viewer-modal-img" src="" alt="Full size view">
         </div>
     </div>
 
     <!-- Scripts -->
     <script src="assets/libs/sjcl.js"></script>
-    <script type="module" src="assets/js/api_client.js"></script>
-    <script type="module" src="assets/js/ui.js"></script>
-    <script src="assets/js/templates.js"></script>
     <script type="module" src="assets/js/app.js"></script>
 </body>
-</html> 
\ No newline at end of file
+</html>
\ No newline at end of file
