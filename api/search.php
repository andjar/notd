<?php
require_once 'db_connect.php';

header('Content-Type: application/json');
$pdo = get_db_connection();
$method = $_SERVER['REQUEST_METHOD'];

// Helper function to get content snippet with context
function get_content_snippet($content, $term, $context_length = 100) {
    $term_pos = stripos($content, $term);
    if ($term_pos === false) {
        return substr($content, 0, $context_length) . '...';
    }

    $start = max(0, $term_pos - $context_length / 2);
    $snippet = substr($content, $start, $context_length);
    
    if ($start > 0) {
        $snippet = '...' . $snippet;
    }
    if ($start + $context_length < strlen($content)) {
        $snippet .= '...';
    }
    
    return $snippet;
}

// Helper function to sanitize search term for FTS5
function sanitize_fts_term($term) {
    // Remove special FTS5 characters and escape quotes
    $term = str_replace(['"', "'", '(', ')', '[', ']', '{', '}', ':', ';', '!', '@', '#', '$', '%', '^', '&', '*', '+', '=', '|', '\\', '/', '<', '>', '?', '~', '`'], ' ', $term);
    // Trim and collapse whitespace
    $term = preg_replace('/\s+/', ' ', trim($term));
    return $term;
}

if ($method === 'GET') {
    try {
        if (isset($_GET['q'])) {
            // Full-text search
            $term = sanitize_fts_term($_GET['q']);
            if (empty($term)) {
                echo json_encode(['success' => true, 'data' => []]);
                exit;
            }

            // Check if FTS5 is available
            $fts_check = $pdo->query("SELECT name FROM sqlite_master WHERE type='table' AND name='Notes_fts'")->fetch();
            
            if ($fts_check) {
                // Use FTS5 for better performance
                $stmt = $pdo->prepare("
                    SELECT 
                        N.id as note_id,
                        N.content,
                        N.page_id,
                        P.name as page_name,
                        snippet(Notes_fts, 0, '<mark>', '</mark>', '...', 64) as content_snippet
                    FROM Notes N 
                    JOIN Pages P ON N.page_id = P.id 
                    JOIN Notes_fts FTS ON N.id = FTS.rowid 
                    WHERE Notes_fts MATCH ?
                    ORDER BY rank
                    LIMIT 100
                ");
                $stmt->execute([$term]);
            } else {
                // Fallback to LIKE search
                $stmt = $pdo->prepare("
                    SELECT 
                        N.id as note_id,
                        N.content,
                        N.page_id,
                        P.name as page_name
                    FROM Notes N 
                    JOIN Pages P ON N.page_id = P.id 
                    WHERE N.content LIKE ? OR P.name LIKE ?
                    LIMIT 100
                ");
                $like_term = '%' . str_replace('%', '\\%', $term) . '%';
                $stmt->execute([$like_term, $like_term]);
            }

            $results = $stmt->fetchAll();
            
            // If using LIKE search, generate snippets manually
            if (!$fts_check) {
                foreach ($results as &$result) {
                    $result['content_snippet'] = get_content_snippet($result['content'], $term);
                }
            }

            echo json_encode(['success' => true, 'data' => $results]);

        } elseif (isset($_GET['backlinks_for_page_name'])) {
            // Backlink search using 'links_to_page' properties
            $target_page_name = trim($_GET['backlinks_for_page_name']);
            if (empty($target_page_name)) {
                echo json_encode(['success' => true, 'data' => []]);
                exit;
            }

            $stmt = $pdo->prepare("
                SELECT 
                    N.id as note_id,
                    N.content,
                    N.page_id,
                    P.name as source_page_name -- This is the page that CONTAINS the link
                FROM Properties Prop
                JOIN Notes N ON Prop.note_id = N.id
                JOIN Pages P ON N.page_id = P.id
                WHERE Prop.name = 'links_to_page' AND Prop.value = ? AND Prop.note_id IS NOT NULL
                ORDER BY N.updated_at DESC
            ");
            
            $stmt->execute([$target_page_name]);
            $results = $stmt->fetchAll();

            // Generate snippets with context around the backlink
            // The snippet should still be generated from N.content, looking for [[target_page_name]]
            foreach ($results as &$result) {
                // Ensure the snippet is generated by looking for the actual link syntax
                // in the content of the linking note.
                $result['content_snippet'] = get_content_snippet($result['content'], '[[' . $target_page_name . ']]');
            }
            unset($result); // release reference

            echo json_encode(['success' => true, 'data' => $results]);

        } elseif (isset($_GET['tasks'])) {
            // Task search
            $status_filter = strtolower($_GET['tasks']);
            if (!in_array($status_filter, ['todo', 'done'])) {
                http_response_code(400);
                echo json_encode(['success' => false, 'error' => 'Invalid task status. Use "todo" or "done"']);
                exit;
            }

            // Map 'todo'/'done' to actual status property values used by the app
            // Based on app.js, it seems to be 'TODO' and 'DONE' (uppercase)
            $property_value = $status_filter === 'todo' ? 'TODO' : 'DONE';
            
            $stmt = $pdo->prepare("
                SELECT 
                    N.id as note_id,
                    N.content,
                    N.page_id,
                    Pg.name as page_name,
                    Prop.name as property_name,  -- For debugging/verification
                    Prop.value as property_value -- For debugging/verification
                FROM Properties Prop
                JOIN Notes N ON Prop.note_id = N.id
                JOIN Pages Pg ON N.page_id = Pg.id
                WHERE Prop.name = 'status' AND Prop.value = ? AND Prop.note_id IS NOT NULL
                ORDER BY N.updated_at DESC
            ");
            $stmt->execute([$property_value]);
            $results = $stmt->fetchAll();

            // Properties are already implicitly part of the main query's selection criteria.
            // We might still want to fetch *all* properties for each note if the UI expects them.
            // For now, let's simplify and assume the primary goal is finding the notes.
            // If all properties are needed, the N+1 loop would still be here,
            // but the initial filtering of notes is much faster.

            // The old code fetched all properties for each note. Let's keep that for consistency,
            // but the initial selection of notes is now much more efficient.
            foreach ($results as &$result) {
                // Snippet generation should use the actual task marker from content,
                // which might be more complex than just 'TODO' or 'DONE' if content has other text.
                // For simplicity, we'll use the status_filter for get_content_snippet.
                // A more robust way would be to find the exact task marker in N.content.
                $result['content_snippet'] = get_content_snippet($result['content'], $property_value);

                // Fetch other properties for the note
                $prop_stmt = $pdo->prepare("SELECT name, value FROM Properties WHERE note_id = ?");
                $prop_stmt->execute([$result['note_id']]);
                $note_properties = $prop_stmt->fetchAll(PDO::FETCH_KEY_PAIR);
                $result['properties'] = $note_properties;
            }
            unset($result); // release reference

            echo json_encode(['success' => true, 'data' => $results]);

        } else {
            http_response_code(400);
            echo json_encode(['success' => false, 'error' => 'Missing search parameter. Use q, backlinks_for_page_name, or tasks']);
        }
    } catch (PDOException $e) {
        http_response_code(500);
        echo json_encode(['success' => false, 'error' => 'Search failed: ' . $e->getMessage()]);
    }
} else {
    http_response_code(405);
    echo json_encode(['success' => false, 'error' => 'Method Not Allowed']);
}
