<?php
require_once 'db_connect.php';
require_once 'response_utils.php'; // Include the new response utility
require_once 'data_manager.php';   // Include the new DataManager

// header('Content-Type: application/json'); // Will be handled by ApiResponse
$pdo = get_db_connection();
$dataManager = new DataManager($pdo); // Instantiate DataManager
$method = $_SERVER['REQUEST_METHOD'];

// Helper function to get content snippet with context
function get_content_snippet($content, $term, $context_length = 100) {
    $term_pos = stripos($content, $term);
    if ($term_pos === false) {
        return substr($content, 0, $context_length) . '...';
    }

    $start = max(0, $term_pos - $context_length / 2);
    $snippet = substr($content, $start, $context_length);
    
    if ($start > 0) {
        $snippet = '...' . $snippet;
    }
    if ($start + $context_length < strlen($content)) {
        $snippet .= '...';
    }
    
    return $snippet;
}

// Helper function to sanitize search term for FTS5
function sanitize_fts_term($term) {
    // Remove special FTS5 characters and escape quotes
    $term = str_replace(['"', "'", '(', ')', '[', ']', '{', '}', ':', ';', '!', '@', '#', '$', '%', '^', '&', '*', '+', '=', '|', '\\', '/', '<', '>', '?', '~', '`'], ' ', $term);
    // Trim and collapse whitespace
    $term = preg_replace('/\s+/', ' ', trim($term));
    return $term;
}

if ($method === 'GET') {
    try {
        if (isset($_GET['q'])) {
            // Full-text search
            $term = sanitize_fts_term($_GET['q']);
            if (empty($term)) {
                ApiResponse::success([]);
                exit;
            }

            // Check if FTS5 is available
            $fts_check = $pdo->query("SELECT name FROM sqlite_master WHERE type='table' AND name='Notes_fts'")->fetch();
            
            if ($fts_check) {
                // Use FTS5 for better performance
                $stmt = $pdo->prepare("
                    SELECT 
                        N.id as note_id,
                        N.content,
                        N.page_id,
                        P.name as page_name,
                        snippet(Notes_fts, 0, '<mark>', '</mark>', '...', 64) as content_snippet
                    FROM Notes N 
                    JOIN Pages P ON N.page_id = P.id 
                    JOIN Notes_fts FTS ON N.id = FTS.rowid 
                    WHERE Notes_fts MATCH ?
                    ORDER BY rank
                    LIMIT 100
                ");
                $stmt->execute([$term]);
            } else {
                // Fallback to LIKE search
                $stmt = $pdo->prepare("
                    SELECT 
                        N.id as note_id,
                        N.content,
                        N.page_id,
                        P.name as page_name
                    FROM Notes N 
                    JOIN Pages P ON N.page_id = P.id 
                    WHERE N.content LIKE ? OR P.name LIKE ?
                    LIMIT 100
                ");
                $like_term = '%' . str_replace('%', '\\%', $term) . '%';
                $stmt->execute([$like_term, $like_term]);
            }

            $results = $stmt->fetchAll();
            
            // If using LIKE search, generate snippets manually
            if (!$fts_check) {
                foreach ($results as &$result) {
                    $result['content_snippet'] = get_content_snippet($result['content'], $term);
                }
            }

            ApiResponse::success($results);

        } elseif (isset($_GET['backlinks_for_page_name'])) {
            // Backlink search using 'links_to_page' properties
            $target_page_name = trim($_GET['backlinks_for_page_name']);
            if (empty($target_page_name)) {
                ApiResponse::success([]);
                exit;
            }

            $stmt = $pdo->prepare("
                SELECT 
                    N.id as note_id,
                    N.content,
                    N.page_id,
                    P.name as source_page_name -- This is the page that CONTAINS the link
                FROM Properties Prop
                JOIN Notes N ON Prop.note_id = N.id
                JOIN Pages P ON N.page_id = P.id
                WHERE Prop.name = 'links_to_page' AND Prop.value = ? AND Prop.note_id IS NOT NULL
                ORDER BY N.updated_at DESC
            ");
            
            $stmt->execute([$target_page_name]);
            $results = $stmt->fetchAll();

            // Generate snippets with context around the backlink
            // The snippet should still be generated from N.content, looking for [[target_page_name]]
            foreach ($results as &$result) {
                // Ensure the snippet is generated by looking for the actual link syntax
                // in the content of the linking note.
                $result['content_snippet'] = get_content_snippet($result['content'], '[[' . $target_page_name . ']]');
            }
            unset($result); // release reference

            ApiResponse::success($results);

        } elseif (isset($_GET['tasks'])) {
            // Task search
            $status_filter = strtolower($_GET['tasks']);
            if (!in_array($status_filter, ['todo', 'done'])) {
                ApiResponse::error('Invalid task status. Use "todo" or "done"', 400);
                exit;
            }

            // Map 'todo'/'done' to actual status property values used by the app
            // Based on app.js, it seems to be 'TODO' and 'DONE' (uppercase)
            $property_value = $status_filter === 'todo' ? 'TODO' : 'DONE';
            
            $stmt = $pdo->prepare("
                SELECT 
                    N.id as note_id,
                    N.content,
                    N.page_id,
                    Pg.name as page_name,
                    Prop.name as property_name,  -- For debugging/verification
                    Prop.value as property_value -- For debugging/verification
                FROM Properties Prop
                JOIN Notes N ON Prop.note_id = N.id
                JOIN Pages Pg ON N.page_id = Pg.id
                WHERE Prop.name = 'status' AND Prop.value = ? AND Prop.note_id IS NOT NULL
                ORDER BY N.updated_at DESC
            ");
            $stmt->execute([$property_value]);
            $results = $stmt->fetchAll();

            // Properties are already implicitly part of the main query's selection criteria.
            // We might still want to fetch *all* properties for each note if the UI expects them.
            // For now, let's simplify and assume the primary goal is finding the notes.
            // If all properties are needed, the N+1 loop would still be here,
            // but the initial filtering of notes is much faster.

            // The old code fetched all properties for each note. Let's keep that for consistency,
            // but the initial selection of notes is now much more efficient.
            
            $noteIds = array_column($results, 'note_id');
            $propertiesByNoteId = [];

            if (!empty($noteIds)) {
                // Decide on includeInternal for properties. For task search, usually all properties are relevant.
                // If a specific include_internal GET param was available for task search, it would be used here.
                // Defaulting to true for now to get all properties and let formatting handle if some are internal.
                $includeInternalProperties = true; 
                $propertiesByNoteId = $dataManager->getPropertiesForNoteIds($noteIds, $includeInternalProperties);
            }

            foreach ($results as &$result) {
                $result['content_snippet'] = get_content_snippet($result['content'], $property_value);
                $result['properties'] = $propertiesByNoteId[$result['note_id']] ?? [];
            }
            unset($result);

            ApiResponse::success($results);

        } else {
            ApiResponse::error('Missing search parameter. Use q, backlinks_for_page_name, or tasks', 400);
        }
    } catch (PDOException $e) {
        ApiResponse::error('Search failed: ' . $e->getMessage(), 500);
    }
} else {
    ApiResponse::error('Method Not Allowed', 405);
}
