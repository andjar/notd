<!DOCTYPE html>
<html>
	<head>
		<!-- MISC/META -->
		<title>ZenPen ~ Minimal Distraction, Maximum Zen</title>
		<meta charset="utf-8" />
		<meta
			name="description"
			content="Zenpen - A minimal text editor, made to stay out of the way while you get the words down."
		/>

		<!-- CSS -->
		<link
			href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"
			rel="stylesheet"
			type="text/css"
		/>
		<link href="css/style.css" rel="stylesheet" />
		<link href="css/fonts.css" rel="stylesheet" />
		<script src="https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js" defer></script>
	</head>

	<body class="yin" x-data="zenPen()" x-init="init()">
		<div class="overlay" x-show="showOverlay" @click="removeOverlay()">
			<div class="wordcount modal" x-show="showWordCountModal">
				<h1>Target Word Count</h1>
				<div>
					<input type="number" name="quantity" value="0" min="0" x-model="wordCountTarget" @keyup.enter="setWordCount()" @change="setWordCount()" />
				</div>
			</div>

			<div class="saveoverlay modal" x-show="showSaveModal">
				<h1>Select save format</h1>
				<p class="saveselection">
					<span data-format="markdown" @click="selectFormat('markdown')" :class="{ active: saveFormat === 'markdown' }">Markdown</span>
					<span data-format="html" @click="selectFormat('html')" :class="{ active: saveFormat === 'html' }">HTML</span>
					<span data-format="plain" @click="selectFormat('plain')" :class="{ active: saveFormat === 'plain' }">Plain Text</span>
				</p>
				<button class="savebutton useicons" @click="saveText()">&#xe006;</button>
				<div>
					Or select format and press ctrl+c (cmd+c on mac) to copy the text.
				</div>
				<textarea class="hiddentextbox" x-ref="hiddenTextbox"></textarea>
			</div>
		</div>

		<div class="text-options" :class="{ active: showTextOptions, fade: textOptionsFading }" :style="textOptionsStyle">
			<div class="options">
				<span class="no-overflow">
					<span class="lengthen ui-inputs">
						<button class="url useicons" :class="{ active: hasUrl }" @mousedown="onUrlClick()">&#xe005;</button>
						<input
							class="url-input"
							type="text"
							placeholder="Type or Paste URL here"
							x-model="urlInput"
							@blur="onUrlInputBlur()"
							@keydown.enter="onUrlInputBlur()"
							x-show="showUrlInput"
						/>
						<button class="bold" :class="{ active: hasBold }" @click="onBoldClick()">b</button>
						<button class="italic" :class="{ active: hasItalic }" @click="onItalicClick()">i</button>
						<button class="quote" :class="{ active: hasQuote }" @click="onQuoteClick()">&rdquo;</button>
					</span>
				</span>
			</div>
		</div>

		<div class="ui">
			<div class="wrapper">
				<div class="top editing">
					<button class="fullscreen useicons" title="Toggle fullscreen" @click="toggleFullscreen()" x-html="fullscreenIcon">
						&#xe000;
					</button>

					<button class="color-flip useicons" title="Invert colors" @click="toggleColorLayout()">
						&#xe002;
					</button>

					<button class="target useicons" title="Set target word count" @click="showWordCountModal = true; showOverlay = true">
						&#xe001;
					</button>
					<button class="save useicons" title="Save Text" @click="showSaveModal = true; showOverlay = true" x-show="supportsSave">
						&#xe003;
					</button>
				</div>

				<div class="bottom">
					<a
						class="about"
						href="https://www.buymeacoffee.com/tholman"
						target="_blank"
					>
						â˜•
					</a>
				</div>
			</div>
		</div>

		<div class="word-counter" :class="{ active: wordCountActive }">
			<span class="progress" :style="wordCounterProgressStyle"></span>
		</div>

		<section>
			<article contenteditable="true" class="markdown-editor" 
				@keyup="onArticleKeyUp()"
				@mouseup="checkTextHighlighting()"
				@mousedown="checkTextHighlighting()"
				@input="saveNoteToDB()"
				x-ref="contentField">
			</article>
		</section>

		<!-- LIBS -->
		<script src="../../assets/libs/marked.min.js"></script>
		<script src="../../assets/js/api_client.js" type="module"></script>
		<script src="js/libs/FileSaver.min.js"></script>
		<script src="js/libs/Blob.min.js"></script>
		<script src="js/libs/screenfull.min.js"></script>

		<!-- Alpine.js Component -->
		<script type="module">
			import { notesAPI } from '../../assets/js/api_client.js';

			function zenPen() {
				return {
					// State
					content: '',
					wordCount: 0,
					wordCountTarget: 0,
					wordCountActive: false,
					showOverlay: false,
					showWordCountModal: false,
					showSaveModal: false,
					showTextOptions: false,
					textOptionsFading: false,
					textOptionsStyle: { top: '-999px', left: '-999px' },
					wordCounterProgressStyle: { width: '0%' },
					
					// Text formatting state
					hasBold: false,
					hasItalic: false,
					hasQuote: false,
					hasUrl: false,
					showUrlInput: false,
					urlInput: '',
					
					// Save functionality
					supportsSave: false,
					saveFormat: '',
					textToWrite: '',
					
					// UI state
					darkLayout: false,
					fullscreenIcon: '&#xe000;',
					
					// Note management
					zenNoteId: null,
					lastSelection: null,
					composing: false,

					init() {
						this.supportsSave = !!new Blob();
						this.loadState();
						this.loadNoteFromDB();
						this.$refs.contentField.focus();
						
						// Set up fullscreen listener
						if (window.screenfull && window.screenfull.enabled) {
							document.addEventListener(window.screenfull.raw.fullscreenchange, () => {
								this.fullscreenIcon = window.screenfull.isFullscreen ? '&#xe004;' : '&#xe000;';
							});
						}
						
						// Set up composition listeners
						document.addEventListener('compositionstart', () => this.composing = true);
						document.addEventListener('compositionend', () => this.composing = false);
						
						// Set up window resize listener
						window.addEventListener('resize', () => this.updateBubblePosition());
					},

					// Word count functionality
					setWordCount() {
						const count = parseInt(this.wordCountTarget);
						if (count > 0) {
							this.wordCountTarget = count;
							this.wordCountActive = true;
							this.updateWordCount();
						} else {
							this.wordCountTarget = 0;
							this.wordCountActive = false;
						}
						this.saveState();
						this.removeOverlay();
						this.$refs.contentField.focus();
					},

					updateWordCount() {
						if (!this.wordCountActive) return;
						
						const progress = Math.min((this.wordCount / this.wordCountTarget) * 100, 100);
						this.wordCounterProgressStyle = { width: progress + '%' };
					},

					// Text highlighting and formatting
					checkTextHighlighting() {
						if (this.composing) return;
						
						const selection = window.getSelection();
						
						if (selection.isCollapsed) {
							this.onSelectorBlur();
							return;
						}
						
						const currentNodeList = this.findNodes(selection.focusNode);
						
						if (this.hasNode(currentNodeList, 'ARTICLE')) {
							this.updateBubbleStates(currentNodeList);
							this.updateBubblePosition();
							this.showTextOptions = true;
						}
					},

					findNodes(element) {
						const nodeNames = {};
						while (element.parentNode) {
							nodeNames[element.nodeName] = true;
							element = element.parentNode;
							if (element.nodeName === 'A') {
								nodeNames.url = element.href;
							}
						}
						return nodeNames;
					},

					hasNode(nodeList, name) {
						return nodeList[name] === true;
					},

					updateBubbleStates(nodeList) {
						this.hasBold = this.hasNode(nodeList, 'B');
						this.hasItalic = this.hasNode(nodeList, 'I');
						this.hasQuote = this.hasNode(nodeList, 'BLOCKQUOTE');
						this.hasUrl = this.hasNode(nodeList, 'A');
					},

					updateBubblePosition() {
						const selection = window.getSelection();
						if (!selection.rangeCount) return;
						
						const range = selection.getRangeAt(0);
						const boundary = range.getBoundingClientRect();
						
						this.textOptionsStyle = {
							top: (boundary.top - 5 + window.pageYOffset) + 'px',
							left: ((boundary.left + boundary.right) / 2) + 'px'
						};
					},

					onSelectorBlur() {
						this.textOptionsFading = true;
						setTimeout(() => {
							if (this.textOptionsFading) {
								this.showTextOptions = false;
								this.textOptionsFading = false;
								this.textOptionsStyle = { top: '-999px', left: '-999px' };
							}
						}, 260);
					},

					// Text formatting actions
					onBoldClick() {
						document.execCommand('bold', false, null);
						this.checkTextHighlighting();
					},

					onItalicClick() {
						document.execCommand('italic', false, null);
						this.checkTextHighlighting();
					},

					onQuoteClick() {
						document.execCommand('formatBlock', false, '<blockquote>');
						this.checkTextHighlighting();
					},

					onUrlClick() {
						this.showUrlInput = true;
						this.$nextTick(() => {
							const urlInput = document.querySelector('.url-input');
							if (urlInput) urlInput.focus();
						});
					},

					onUrlInputBlur() {
						if (this.urlInput.trim()) {
							this.applyURL(this.urlInput.trim());
						}
						this.showUrlInput = false;
						this.urlInput = '';
					},

					applyURL(url) {
						const selection = window.getSelection();
						if (selection.toString()) {
							document.execCommand('createLink', false, url);
						}
						this.checkTextHighlighting();
					},

					// UI actions
					toggleFullscreen() {
						if (window.screenfull && window.screenfull.enabled) {
							window.screenfull.toggle();
						}
					},

					toggleColorLayout() {
						this.darkLayout = !this.darkLayout;
						document.body.className = this.darkLayout ? 'yang' : 'yin';
						this.saveState();
					},

					removeOverlay() {
						this.showOverlay = false;
						this.showWordCountModal = false;
						this.showSaveModal = false;
					},

					// Save functionality
					selectFormat(format) {
						this.saveFormat = format;
					},

					saveText() {
						if (!this.saveFormat) {
							document.querySelector('.saveoverlay h1').style.color = '#FC1E1E';
							return;
						}
						
						this.textToWrite = this.formatText(this.saveFormat, this.$refs.contentField.innerHTML);
						const blob = new Blob([this.textToWrite], {type: "text/plain;charset=utf-8"});
						saveAs(blob, 'ZenNote.txt');
					},

					formatText(type, content) {
						switch(type) {
							case 'markdown':
								return this.htmlToMarkdown(content);
							case 'html':
								return content;
							case 'plain':
								return this.getText(this.$refs.contentField);
							default:
								return content;
						}
					},

					htmlToMarkdown(html) {
						// Simple HTML to Markdown conversion
						let markdown = html
							.replace(/<br\s*\/?>/gi, '\n')
							.replace(/<p>/gi, '')
							.replace(/<\/p>/gi, '\n\n')
							.replace(/<b>(.*?)<\/b>/gi, '**$1**')
							.replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
							.replace(/<i>(.*?)<\/i>/gi, '*$1*')
							.replace(/<em>(.*?)<\/em>/gi, '*$1*')
							.replace(/<blockquote>(.*?)<\/blockquote>/gi, '> $1')
							.replace(/<a href="([^"]*)">(.*?)<\/a>/gi, '[$2]($1)')
							.replace(/<[^>]*>/g, '');
						
						return markdown.trim();
					},

					getText(el) {
						let ret = " ";
						const length = el.childNodes.length;
						for(let i = 0; i < length; i++) {
							const node = el.childNodes[i];
							if(node.nodeType != 8) {
								if (node.nodeType != 1) {
									ret += node.nodeValue;
								} else {
									ret += this.getText(node);
								}
							}
						}
						return this.trim(ret);
					},

					trim(string) {
						return string.replace(/^\s+|\s+$/g, '');
					},

					// Article key up handler
					onArticleKeyUp() {
						this.checkTextHighlighting();
						this.saveNoteToDB();
					},

					// State management
					loadState() {
						if (this.supportsHtmlStorage()) {
							if (localStorage['wordCount'] && localStorage['wordCount'] !== "0") {
								this.wordCountTarget = parseInt(localStorage['wordCount']);
								this.wordCountActive = true;
								this.updateWordCount();
							}
							
							if (localStorage['darkLayout'] === 'true') {
								this.darkLayout = true;
								document.body.className = 'yang';
							}
						}
					},

					saveState() {
						if (this.supportsHtmlStorage()) {
							localStorage['darkLayout'] = this.darkLayout;
							localStorage['wordCount'] = this.wordCountTarget;
						}
					},

					supportsHtmlStorage() {
						try {
							return 'localStorage' in window && window['localStorage'] !== null;
						} catch (e) {
							return false;
						}
					},

					// Note management
					async saveNoteToDB() {
						const content = this.$refs.contentField.innerHTML;
						this.content = content;
						this.wordCount = this.getWordCount();
						this.updateWordCount();
						
						if (!content.trim()) return;
						
						try {
							const noteData = {
								content: content,
								properties: {
									zen_editor: [{ value: 'true' }],
									word_count: [{ value: this.wordCount.toString() }]
								}
							};
							
							if (this.zenNoteId) {
								// Update existing note
								const response = await notesAPI.updateNote(this.zenNoteId, noteData);
								if (response && response.status === 'success') {
									console.log('Zen note updated successfully');
								}
							} else {
								// Create new note
								const response = await notesAPI.createNote(noteData);
								if (response && response.status === 'success' && response.data && response.data.note) {
									this.zenNoteId = response.data.note.id;
									console.log('Zen note created successfully');
								}
							}
						} catch (error) {
							console.error('Error saving zen note:', error);
						}
					},

					async loadNoteFromDB() {
						try {
							// Try to find existing zen note
							const response = await notesAPI.searchNotes('zen_editor:true', { limit: 1 });
							if (response && response.results && response.results.length > 0) {
								const note = response.results[0];
								this.zenNoteId = note.id;
								this.$refs.contentField.innerHTML = note.content || this.getDefaultContent();
								this.content = note.content;
								this.wordCount = this.getWordCount();
								this.updateWordCount();
							} else {
								// Load default content
								this.$refs.contentField.innerHTML = this.getDefaultContent();
								this.content = this.getDefaultContent();
								this.wordCount = this.getWordCount();
								this.updateWordCount();
							}
						} catch (error) {
							console.error('Error loading zen note:', error);
							this.$refs.contentField.innerHTML = this.getDefaultContent();
						}
					},

					getDefaultContent() {
						return '<p>A minimalist writing zone, where you can block out all distractions and get to what\'s important. The writing!</p><p>To get started, all you need to do is delete this text (seriously, just highlight it and hit delete), and fill the page with your own fantastic words. You can even change the title!</p><p>You can use <b>bold</b>, <i>italics</i>, <b><i>both</i></b> and <a href="http://zenpen.io">urls</a> just by highlighting the text and selecting them from the tiny options box that appears above it.</p><blockquote>Quotes are easy to add too!</blockquote><p>If you\'re using ZenPen, and want to contribute a few dollars, there\'s a small donate button on the bottom left.</p><p>Happy Typing! ~ <b>Tim Holman (@twholman)</b></p>';
					},

					getWordCount() {
						const text = this.getText(this.$refs.contentField);
						return text.trim().split(/\s+/).filter(word => word.length > 0).length;
					}
				};
			}
			
			window.zenPen = zenPen;
		</script>
	</body>
</html>