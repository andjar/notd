<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pomodoro Timer</title>
    <!-- Theme and App Styles -->
    <?php include '../../assets/css/theme_loader.php'; ?>
    <link rel="stylesheet" type="text/css" href="../../assets/css/style.css">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.9/dist/cdn.min.js" defer></script>
</head>
<body>
    <div id="pomodoro-container" x-data="pomodoroTimer()">
        <div class="time-date-container">
            <div id="clock" class="clock" x-text="currentTimeDisplay">12:00</div>
            <div id="date" class="date" x-text="currentDateDisplay">Monday, 1 January</div>
        </div>
        <div id="pomodoro-background-bubbles-canvas">
            <!-- Canvas for dynamic bubbles -->
        </div>
        <div id="pomodoro-orb-container">
            <div id="pomodoro-orb-inner-core">
                <div id="timer-display" x-text="formatTime(timer.currentTime)">25:00</div>
                <div id="controls">
                    <button id="start" x-on:click="startPauseResume()" x-text="timer.startButtonText">Start</button>
                    <button id="reset" x-on:click="resetTimer()">Reset</button>
                </div>
                <div id="pomodoro-orb-perimeter-dots">
                    <!-- Dots will be generated by JS -->
                </div>
            </div>
        </div>
        <div id="notes-config">
            <textarea id="note-properties" placeholder="key:value, key2:value2" x-model="noteProperties"></textarea>
        </div>
    </div>
    
    <script src="animations.js"></script>
    <script>
        function pomodoroTimer() {
            return {
                // --- Configuration Store ---
                config: {
                    workDurationMinutes: 25,
                    shortBreakDurationMinutes: 5,
                    longBreakDurationMinutes: 15,
                    pomodorosBeforeLongBreak: 4,
                    workDurationSeconds: 25 * 60,
                    shortBreakDurationSeconds: 5 * 60,
                    longBreakDurationSeconds: 15 * 60,
                },
                // --- Time/Date Display ---
                currentTimeDisplay: '12:00',
                currentDateDisplay: 'Monday, 1 January',
                timeDateIntervalId: null,
                updateTimeDate() {
                    const now = new Date();
                    this.currentTimeDisplay = now.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: true
                    });
                    this.currentDateDisplay = now.toLocaleDateString('en-US', {
                        weekday: 'long',
                        month: 'long',
                        day: 'numeric'
                    });
                },
                startTimeDateUpdates() {
                    this.updateTimeDate(); // Initial update
                    this.timeDateIntervalId = setInterval(() => this.updateTimeDate(), 1000); // Update every second
                },
                // --- Timer Core Functionality ---
                timer: {
                    currentTime: 25 * 60, // Will be initialized after config load
                    timerState: 'stopped', // 'running', 'paused', 'stopped'
                    currentSessionType: 'work', // 'work', 'shortBreak', 'longBreak'
                    pomodorosCompleted: 0,
                    timerInterval: null,
                    startButtonText: 'Start',
                    startTimestamp: null,      // NEW: wall clock start time
                    remainingTime: 25 * 60,    // NEW: time left when paused/stopped
                },
                noteProperties: '',
                // DOM Elements are accessed via x-ref if needed, or direct binding
                // timerOrb: null, // For animations, might need specific handling if direct DOM manipulation is in animations.js

                formatTime(timeInSeconds) {
                    const minutes = Math.floor(timeInSeconds / 60);
                    const seconds = timeInSeconds % 60;
                    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                },

                startPauseResume() {
                    if (this.timer.timerState === 'running') {
                        this.pauseTimer();
                    } else { // 'stopped' or 'paused'
                        this.startTimer();
                    }
                },

                startTimer() {
                    // If starting a new session, set remainingTime to full duration
                    if (this.timer.timerState === 'stopped') {
                        this.timer.remainingTime = this.getDurationForSessionType(this.timer.currentSessionType) * 60;
                    }
                    // If resuming from pause, remainingTime is already set
                    this.timer.startTimestamp = Date.now();
                    this.timer.timerState = 'running';
                    this.timer.startButtonText = 'Pause';

                    // Immediately update currentTime for UI
                    this.timer.currentTime = this.timer.remainingTime;

                    // Clear any previous interval
                    if (this.timer.timerInterval) clearInterval(this.timer.timerInterval);

                    this.timer.timerInterval = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - this.timer.startTimestamp) / 1000);
                        this.timer.currentTime = this.timer.remainingTime - elapsed;
                        if (this.timer.currentTime <= 0) {
                            this.timer.currentTime = 0;
                            clearInterval(this.timer.timerInterval);
                            this.handleSessionEnd();
                        }
                    }, 500); // update twice per second for smoothness
                },

                pauseTimer() {
                    if (this.timer.timerState === 'running') {
                        const elapsed = Math.floor((Date.now() - this.timer.startTimestamp) / 1000);
                        this.timer.remainingTime = this.timer.remainingTime - elapsed;
                        clearInterval(this.timer.timerInterval);
                        this.timer.timerState = 'paused';
                        this.timer.startButtonText = 'Resume';
                    }
                },

                resetTimer() {
                    clearInterval(this.timer.timerInterval);
                    this.timer.timerState = 'stopped';
                    this.timer.currentSessionType = 'work';
                    this.timer.currentTime = this.config.workDurationSeconds;
                    this.timer.remainingTime = this.config.workDurationSeconds;
                    this.timer.startButtonText = 'Start';
                },

                async logSession(sessionType, durationMinutes, customProperties) {
                    console.log(`Logging session: ${sessionType}, Duration: ${durationMinutes} mins`, customProperties);
                    const now = new Date();
                    // --- Page Name Logic ---
                    let pageTemplate = this.config.pageTemplate || '<today>';
                    let todayStr = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                    let pageName = pageTemplate
                        .replace(/<today>/g, todayStr)
                        .replace(/<year>/g, now.getFullYear())
                        .replace(/<month>/g, (now.getMonth() + 1).toString().padStart(2, '0'))
                        .replace(/<day>/g, now.getDate().toString().padStart(2, '0'));

                    // --- Date Placeholder for Note ---
                    let dateStr = todayStr;

                    let noteTitle = '';
                    let pomodoroType = '';

                    switch (sessionType) {
                        case 'work':
                            noteTitle = `Pomodoro Work Session - ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
                            pomodoroType = 'work';
                            break;
                        case 'shortBreak':
                            noteTitle = `Short Break - ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
                            pomodoroType = 'short_break';
                            break;
                        case 'longBreak':
                            noteTitle = `Long Break - ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
                            pomodoroType = 'long_break';
                            break;
                    }

                    // Prepare custom properties as {name::<value>} pairs
                    let customPropsString = '';
                    for (const key in customProperties) {
                        customPropsString += `{${key}::${customProperties[key]}}\n`;
                    }

                    // Structured properties for duration and pomodoro_type
                    const durationProp = `{duration::${durationMinutes}}`;
                    const pomodoroTypeProp = `{pomodoro_type::${pomodoroType}}`;

                    // Use template from config if available
                    let content = '';
                    if (this.config.noteTemplate) {
                        content = this.config.noteTemplate
                            .replace(/\{noteTitle\}/g, noteTitle)
                            .replace(/\{date\}/g, dateStr)
                            .replace(/\{duration\}/g, durationProp)
                            .replace(/\{pomodoroType\}/g, pomodoroTypeProp)
                            .replace(/\{customProperties\}/g, customPropsString.trim());
                    } else {
                        content = `## ${noteTitle}\n\n${dateStr}\n${durationProp}\n${pomodoroTypeProp}\n${customPropsString}`;
                    }

                    try {
                        const response = await fetch(`../../api/v1/append_to_page.php`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                page_name: pageName,
                                notes: content.trim()
                            })
                        });
                        if (response.ok) {
                            const responseData = await response.json();
                            if (responseData && responseData.status === 'success' && responseData.data && responseData.data.appended_notes) {
                                console.log('Pomodoro session logged successfully to page:', pageName, responseData.data.appended_notes);
                            } else {
                                console.error('Failed to log session: API response error or invalid data structure.', responseData);
                            }
                        } else {
                            console.error('Failed to log session:', response.status, await response.text());
                        }
                    } catch (error) {
                        console.error('Error logging session:', error);
                    }
                },

                // --- Cycle Logic ---
                getNextSessionType(currentIndex) {
                    if (Array.isArray(this.config.cycle) && this.config.cycle.length > 0) {
                        return this.config.cycle[currentIndex % this.config.cycle.length];
                    }
                    // Fallback to default logic
                    return (currentIndex % 2 === 0) ? 'work' : 'shortBreak';
                },
                handleSessionEnd() {
                    console.log(`${this.timer.currentSessionType} session ended.`);
                    this.logSession(this.timer.currentSessionType, this.getDurationForSessionType(this.timer.currentSessionType), this.getCustomProperties());

                    // --- Use cycle array for next session ---
                    if (!this._cycleIndex) this._cycleIndex = 0;
                    this._cycleIndex = (this._cycleIndex || 0) + 1;
                    const nextType = this.getNextSessionType(this._cycleIndex);
                    this.timer.currentSessionType = nextType;

                    // Set up for next session
                    if (this.timer.currentSessionType === 'work') {
                        this.timer.currentTime = this.config.workDurationSeconds;
                        this.timer.remainingTime = this.config.workDurationSeconds;
                    } else if (this.timer.currentSessionType === 'shortBreak') {
                        this.timer.currentTime = this.config.shortBreakDurationSeconds;
                        this.timer.remainingTime = this.config.shortBreakDurationSeconds;
                    } else if (this.timer.currentSessionType === 'longBreak') {
                        this.timer.currentTime = this.config.longBreakDurationSeconds;
                        this.timer.remainingTime = this.config.longBreakDurationSeconds;
                    }
                    console.log(`Next session: ${this.timer.currentSessionType}. Pomodoros: ${this.timer.pomodorosCompleted}`);
                    this.startTimer(); // Automatically start the next timer
                },

                getDurationForSessionType(sessionType) {
                    if (sessionType === 'work') return this.config.workDurationMinutes;
                    if (sessionType === 'shortBreak') return this.config.shortBreakDurationMinutes;
                    if (sessionType === 'longBreak') return this.config.longBreakDurationMinutes;
                    return 0;
                },

                getCustomProperties() {
                    const propertiesText = this.noteProperties.trim();
                    if (!propertiesText) return {};
                    const properties = {};
                    propertiesText.split('\n').forEach(line => {
                        const [key, value] = line.split(':');
                        if (key && value) {
                            properties[key.trim()] = value.trim();
                        }
                    });
                    return properties;
                },

                // --- Initialization ---
                async initializeTimer() {
                    try {
                        const response = await fetch('./config.json');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const fetchedConfig = await response.json();

                        this.config.workDurationMinutes = fetchedConfig.workDurationMinutes || 25;
                        this.config.shortBreakDurationMinutes = fetchedConfig.shortBreakDurationMinutes || 5;
                        this.config.longBreakDurationMinutes = fetchedConfig.longBreakDurationMinutes || 15;
                        this.config.pomodorosBeforeLongBreak = fetchedConfig.pomodorosBeforeLongBreak || 4;

                        this.config.workDurationSeconds = this.config.workDurationMinutes * 60;
                        this.config.shortBreakDurationSeconds = this.config.shortBreakDurationMinutes * 60;
                        this.config.longBreakDurationSeconds = this.config.longBreakDurationMinutes * 60;

                        console.log("Configuration loaded:", this.config);
                    } catch (error) {
                        console.error("Failed to load config.json. Using default values.", error);
                        // Default values are already set in the config object, ensure seconds are calculated
                        this.config.workDurationSeconds = this.config.workDurationMinutes * 60;
                        this.config.shortBreakDurationSeconds = this.config.shortBreakDurationMinutes * 60;
                        this.config.longBreakDurationSeconds = this.config.longBreakDurationMinutes * 60;
                    }

                    this.timer.currentTime = this.config.workDurationSeconds;
                    this.timer.currentSessionType = 'work';
                    this.timer.timerState = 'stopped';
                    this.timer.startButtonText = 'Start';

                    this.startTimeDateUpdates();

                    if (window.pomodoroAnimations) {
                        // Consider how animations.js interacts with Alpine.
                        // It might need adjustments if it directly manipulates DOM elements now controlled by Alpine.
                        window.pomodoroAnimations.start();
                    }

                    console.log("Pomodoro Timer Initialized with Alpine.js");
                    console.log(`Initial settings from config: Work: ${this.config.workDurationMinutes}m, Short Break: ${this.config.shortBreakDurationMinutes}m, Long Break: ${this.config.longBreakDurationMinutes}m, Pomos: ${this.config.pomodorosBeforeLongBreak}`);
                },

                // --- Alpine specific init ---
                init() {
                    this.initializeTimer().then(() => {
                        console.log("Alpine Pomodoro Timer component initialized after config load.");
                    }).catch(error => {
                        console.error("Error during Alpine component async initialization:", error);
                    });

                    // For animations.js, if it relies on specific DOM elements existing, ensure they do.
                    // If animations.js manipulates #timer-orb or #timer-display directly, conflicts might arise.
                    // For now, we assume animations.js is compatible or will be adjusted separately.
                }
            }
        }
    </script>
</body>
</html>
